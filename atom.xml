<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sam的个人博客</title>
  
  <subtitle>一个程序员的成长记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ydstudios.gitee.io/"/>
  <updated>2021-08-24T03:20:42.773Z</updated>
  <id>https://ydstudios.gitee.io/</id>
  
  <author>
    <name>Sam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis高可用之主从复制实践</title>
    <link href="https://ydstudios.gitee.io/post/2b577ce1.html"/>
    <id>https://ydstudios.gitee.io/post/2b577ce1.html</id>
    <published>2021-08-23T17:22:10.000Z</published>
    <updated>2021-08-24T03:20:42.773Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Redis支持多种高可用方案如Redis Sentinel 集群和 Redis 数据集群，但是今天我们的主题是Redis的主从复制。而且今天我们重点在于如何搭建Redis的主从复制，不着重与主从复制的原理。废话不多说，那么我们就来实践Redis主从复制的搭建。</p><a id="more"></a><h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h4><p>开始动手之前，我们先简单聊一聊什么是主从复制？主从复制是指将一个Redis服务器的数据，复制到其他的Redis服务器，这就叫做主从复制。在这个现象中前者称之为主节点(master)，后者称之为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有0个或者有1个以上的从节点，但一个从节点只能有一个主节点。</p><h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><p>当我们知道了什么是主从复制，那我们肯定也要知道为啥需要主从复制了，不然只知道怎么去做，不知道为啥去做，也是蛮烦恼的。Redis的主从复制到底有啥用，这个我们就可以看看如果只有单机情况下的Redis宕机，我们到底会面临啥问题，自然就能得出Redis的主从复制的作用，这里我们就不展开说，直接给出结论。Redis的主从复制主要有以下几种作用：</p><ul><li><p>数据备份。单个Redis一旦宕机，就有可能丢失所有数据，主从复制实现了数据的热备份，即使master宕机丢失数据，只要有slave存在我们就可以找回数据。</p></li><li><p>负载均衡。搭建好了主从，我们就可以只让主负责写服务，其他从负责读服务，这样在读多写少的场景下，通过多个从节点的分担读请求，就可以实现提高Redis的并发量，从而提高系统的性能。</p></li><li><p>高可用基础。Redis这种主从复制在master发生故障时不能自动从slave中选举、切换master，需要人工干预。总的来说不够智能，后续的哨兵模式、Redis集群能够解决这些问题，但是又建立在Redis这种主从复制上，所以说他是高可用的基础。</p></li></ul><p>  后面我们就来说一说，如何搭建Redis的主从复制。</p><h4 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h4><p>目前手里买的服务器都已经过期了，只能拿自己的电脑做实验，所以直接把Redis目录复制三份，并将每一份的配置文件redis.conf中端口号port配置进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将端口号6379分别修改成下表中的样子</span></span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">ip</th><th align="center">端口</th><th align="center">角色</th></tr></thead><tbody><tr><td align="center">192.168.0.103</td><td align="center">6379</td><td align="center">master</td></tr><tr><td align="center">192.168.0.103</td><td align="center">6380</td><td align="center">slave</td></tr><tr><td align="center">192.168.0.103</td><td align="center">6381</td><td align="center">slave</td></tr></tbody></table><h4 id="建立复制的相关命令"><a href="#建立复制的相关命令" class="headerlink" title="建立复制的相关命令"></a>建立复制的相关命令</h4><p>需要注意的是，Redis主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</p><p>从节点开启主从复制，有以下三种方式：</p><ul><li>通过配置文件开启<br>在从服务器的配置文件中指定具体的master的地址，配置格式如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果master有密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure><p>在配置文件redis.conf中添加以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.103 6379  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果master有密码</span></span><br><span class="line">masterauth 2021</span><br></pre></td></tr></table></figure><ul><li><p>启动从服务器时开启<br>redis-server启动命令后加入参数  <code>--slaveof &lt;masterip&gt; &lt;masterport&gt;</code>，如果master有密码，则需要加入密码参数。 <code>--requirepass &lt;password&gt;</code><br>最终的启动命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe  ./redis.conf  --slaveof 127.0.0.1 6379 --masterauth 2021</span><br></pre></td></tr></table></figure></li><li><p>客户端处执行命令开启<br>在Redis客户端如redis-cli 中执行命令<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>来指定主服务器，如果master有密码则需要紧接着执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set masterauth 2021</span><br></pre></td></tr></table></figure></li></ul><p>上述3种方式最终的效果都是一样的的，大家可以自己试一试。这里以第二种方式为例，看一下当执行了slaveof后，Redis主节点和从节点的变化。</p><h4 id="观察效果"><a href="#观察效果" class="headerlink" title="观察效果"></a>观察效果</h4><p>在master的客户端上执行命令<code>info replication</code> 和<code>client list</code>可以看到下图所示的信息：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824101943.png" alt="master客户端执行命令" style="zoom:50%;" /><p>在端口号为6381的slave上执行<code>info replication</code>命令可以看到下面的信息：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824103126.png" alt="image-20210824102950905" style="zoom: 80%;" /><p>由两张图的信息可以看出，端口号为6379的服务器角色是master，端口号6380和6381的服务器角色是slave，那么接下来我们试试到底他们之间能不能同步数据。</p><p>从下图可以看出master和slave都是没有数据的（6380的机器也是一样我就没有放上来）</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824103634.png" alt="image-20210824103634434"></p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824103710.png" alt="image-20210824103710285"></p><p>那么我们接下来就开始测试：</p><ol><li><p>在master上执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set test 123</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824104056.png" alt="image-20210824104056704"></p></li><li><p>到对应的slave去查询这个key</p></li></ol><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824104139.png" alt="image-20210824104139046"></p><p>从节点已经有了数据，读取出来数据也是正确的。</p><ol start="3"><li><p>接下来我们在master上删除这个key。</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824104302.png" alt="image-20210824104302555"></p></li><li><p>再到对应的slave上读取这个key，可以发现数据已经没有了。</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824104352.png" alt="image-20210824104352911"></p></li><li><p>我们在master在增加一些数据，然后将slave6381和master断开主从关系，看看有什么现象。</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824104725.png" alt="image-20210824104725960"></p></li></ol><p>在确保slave6381已经有了上述数据之后，我们执行下面的命令断开主从关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure><blockquote><p>记住我们在前文说到过“Redis主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情”，所以这个命令是在slave6381上执行的，大家千万别搞错了！</p></blockquote><p>slave6381执行命令之后信息如图所示，我们发现断开了关系，但是slave6381上从master上同步过来的数据仍然存在。因为从节点断开复制后，不会删除已有的数据，只是不再同步主节点新的数据变化。</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824105216.png" alt="image-20210824105216945"></p><p>主节点打印的日志如下图所示，显示slave6381已经下线。</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210824105600.png" alt="主节点打印的日志"></p><p>下面是redis主从复制场景的一些可调参数，需要根据实际环境调整</p><ul><li>slave-serve-stale-data yes ： 是否可以把不新鲜的数据服务与客户端</li><li>slave-read-only yes ： 从节点只读，启用slaveof定义后才生效</li><li>repl-diskless-sync no ：是否同时向多个从节点同时发数据</li><li>repl-diskless-sync-delay 5 ：发送的延迟时间</li><li>repl-ping-slave-period 10 探测从节点状态</li><li>repl-timeout 60 探测节点超时时间</li><li>repl-disable-tcp-nodelay no ： 启用nodelay</li><li>repl-backlog-size 1mb</li><li>slave-priority 100 ： 从节点优先级,复制集群中，主节点故障时，sentinel应用场景中的主节点选举时使用的优先级；数字越小优先级越高，但0表示不参与选举；</li><li>min-slaves-to-write 3：主节点仅允许其能够通信的从节点数量大于等于此处的值时接受写操作；</li><li>min-slaves-max-lag 10：从节点延迟时长超出此处指定的时长时，主节点会拒绝写入操作</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上所述，简单的Redis主从复制就搭建好了。另外提一下，slave 可以接受其他 slave 的连接。除了多个 slave 可以连接到同一个 master 之外， slave 之间也可以像层叠状的结构（cascading-like structure）连接到其他 slave 。自 Redis 4.0 起，所有的 sub-slave 将会从 master 收到完全一样的复制流。本文这里呢只是简单搭建一下主从复制，有兴趣的同学可以自己试一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Redis支持多种高可用方案如Redis Sentinel 集群和 Redis 数据集群，但是今天我们的主题是Redis的主从复制。而且今天我们重点在于如何搭建Redis的主从复制，不着重与主从复制的原理。废话不多说，那么我们就来实践Redis主从复制的搭建。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="https://ydstudios.gitee.io/tags/redis/"/>
    
      <category term="主从复制" scheme="https://ydstudios.gitee.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
      <category term="高可用" scheme="https://ydstudios.gitee.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>缓存之缓存穿透、击穿和雪崩</title>
    <link href="https://ydstudios.gitee.io/post/1d659c02.html"/>
    <id>https://ydstudios.gitee.io/post/1d659c02.html</id>
    <published>2021-08-20T17:59:52.000Z</published>
    <updated>2021-08-23T04:46:27.329Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在系统出现性能瓶颈，要进行性能优化的时候，我们可能会考虑使用如Redis这样的中间件实现缓存来提高系统的性能。当然这个肯定要考虑业务场景，不是所有的业务场景都是可以使用缓存的。本文重点不是引入缓存的时机，也不是缓存架构如何实现，今天只是来说说引入缓存之后带来的缓存穿透、缓存击穿和缓存雪崩这三个问题。</p><a id="more"></a><h4 id="使用缓存时数据访问的流程"><a href="#使用缓存时数据访问的流程" class="headerlink" title="使用缓存时数据访问的流程"></a>使用缓存时数据访问的流程</h4><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210823123516.png" alt="使用缓存时的流程" style="zoom:60%;" /><p>使用cache之后，访问数据的流程就不再像之前那样直接请求数据库，而是先请求cache，cache中没有数据，则再去请求数据库。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><h5 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h5><p>当请求cache时，cache中对应的缓存不存在，然后去请求数据库，但是数据库中也没有对应的数据。这样的请求每次都无法命中缓存，缓存失去了他的用处。</p><h5 id="有什么问题"><a href="#有什么问题" class="headerlink" title="有什么问题"></a>有什么问题</h5><p>假设在商品详情页，有人直接改动浏览器上地址，去访问id&lt;=0的商品，id&lt;=0的商品对应的数据无论是在cache还是在数据库中都不会有，那么如果有黑客利用此漏洞进行攻击，则有大可能压垮数据库。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><h5 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h5><p>当请求cache时，cache中对应的缓存不存在，然后去请求数据库，数据库存在对应的数据。</p><h5 id="有什么问题-1"><a href="#有什么问题-1" class="headerlink" title="有什么问题"></a>有什么问题</h5><p>如有高并发的场景下，在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让数据库崩溃。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h5 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h5><p>缓存服务器重启或者缓存服务器中的缓存在同一时间失效。缓存击穿关注的是单个缓存key，缓存雪崩关注的是一大批缓存key。</p><h5 id="有什么问题-2"><a href="#有什么问题-2" class="headerlink" title="有什么问题"></a>有什么问题</h5><p>缓存在同一时间失效，这时有高并发的场景，短时间内请求都打到了数据库上，也会压垮数据库。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="如何解决缓存穿透的问题"><a href="#如何解决缓存穿透的问题" class="headerlink" title="如何解决缓存穿透的问题"></a>如何解决缓存穿透的问题</h5><p>解决这个问题，我们可以看看小伙伴在使用缓存的时候代码是怎么写的，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">findDataById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    Object data = Cache.get(id);</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    Object data = DB.findById(id);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cache.set(id,data,time);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想小伙伴们差不多都是这么写的，这样写在正常的情况下是没有问题的，但是一旦id是一个小于0数或者id对应的数据在数据库中就是没有，系统在高并发、大流量的情况下，问题就随之而来了。那我们应该如何解决呢？</p><ul><li><p>进行一定的数据校验，其他的直接缓存null<br>对于商品id来说，这样的数据是肯定是没有小于0的，所以我们可以在方法的入口，增加对应的数据校验，id小于等于0的请求直接拦截。符合校验规则，但是数据库中确实没有的则也直接缓存，但是注意他的缓存时间设置的不会太长，具体时间看大家的业务要求。所以上面的伪代码可以优化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">findDataById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"id不合法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object data = Cache.get(id);</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">3</span>;</span><br><span class="line">    Object data = DB.findById(id);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>)&#123;</span><br><span class="line">        time = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cache.set(id,data,time);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样的写法不够优美，不符合单一原则，毕竟只是伪代码，大家凑活着</p></blockquote></li><li><p>使用布隆过滤器拦截<br>利用布隆过滤器（Bloom Filter），它可以使用很小的内存空间内查找某个数据是否存在。我们可以将可能存在的key都保存到bitMap中，根据布隆过滤器的特点，一个数据如果判定为存在的时候，数据不一定存在，但是判定结果为不存在的时候，则数据一定不存在，这样我们就可以过滤那些不存在的key。</p></li></ul><blockquote><p>对比两种解决方案，我比较倾向于前一种，实现简单，一般场景下也是没有问题的。</p></blockquote><h5 id="如何解决缓存击穿的问题"><a href="#如何解决缓存击穿的问题" class="headerlink" title="如何解决缓存击穿的问题"></a>如何解决缓存击穿的问题</h5><ul><li>key不设置过期时间</li></ul><p>我们将数据缓存到Cache中，一般都是会设定过期时间的，那对于发生了缓存击穿（热点）的key来说，我们可不可以不设置过期时间，即key永远不过期，如果数据有变动则直接删除key。</p><blockquote><p>如何发现热点key？这里给出两个简单的方法。1. 根据业务经验预估  2.使用redis自带的命令预估，如monitor命令进行分析或者redis-cli使用hotkeys参数</p><p>如果数据有变动则直接删除key，这个要是拿来说一说，也是可以水一篇文章的。</p></blockquote><ul><li>使用互斥锁</li></ul><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">    Object value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    String mutexKey = <span class="string">"mutex"</span> + key;</span><br><span class="line">    <span class="comment">// 设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(mutexKey, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        value = db.get(key);</span><br><span class="line">        redis.set(key, value, expire_secs);</span><br><span class="line">        redis.del(mutexKey);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(randomTime);</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        value = get(key); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>缓存预热</p><p>缓存预热就是系统直接把缓存创建起来，不需要走之前那一套缓存建立的流程。这个方案适用于上架一个商品，业务在后台配置好之后，直接起一个线程处理好这个商品的相关缓存。</p></li></ul><h5 id="如何解决缓存雪崩的问题"><a href="#如何解决缓存雪崩的问题" class="headerlink" title="如何解决缓存雪崩的问题"></a>如何解决缓存雪崩的问题</h5><p>缓存雪崩其实是缓存击穿的极端情况。前面说到了发生缓存雪崩的两个场景，一是因为服务发生了宕机导致缓存不可用，二是因为大批缓存的key在短时间内同时失效，所以针对这两种情况，我们可以给出以下的解决方案。</p><ul><li><p>缓存系统的高可用</p><p>redis的支持多种高可用的方案，如哨兵模式、Redis Cluster等。</p></li><li><p>避免热点key的过期时间相同</p><p>缓存key在设置过期时间时，在正常的过期时间上加上一个随机时间，这样可以让缓存失效的时间点尽量均匀。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>前文说了本文的重点只是探讨缓存穿透、缓存击穿和缓存雪崩三个问题，缓存其他的问题都没有涉猎。再说一次缓存不是提高系统性能的万精油，而且解决上述问题的各种方案也是需要看自己系统情况和业务要求去灵活的运用。大家如有什么疑问或者不同的意见可以提出来我们讨论讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在系统出现性能瓶颈，要进行性能优化的时候，我们可能会考虑使用如Redis这样的中间件实现缓存来提高系统的性能。当然这个肯定要考虑业务场景，不是所有的业务场景都是可以使用缓存的。本文重点不是引入缓存的时机，也不是缓存架构如何实现，今天只是来说说引入缓存之后带来的缓存穿透、缓存击穿和缓存雪崩这三个问题。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="缓存" scheme="https://ydstudios.gitee.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="缓存击穿" scheme="https://ydstudios.gitee.io/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    
      <category term="缓存雪崩" scheme="https://ydstudios.gitee.io/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ydstudios.gitee.io/post/4a17b156.html"/>
    <id>https://ydstudios.gitee.io/post/4a17b156.html</id>
    <published>2021-08-19T09:06:25.873Z</published>
    <updated>2020-12-06T05:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>怎样才能将模板和策略设计模式结合起来使用</title>
    <link href="https://ydstudios.gitee.io/post/818451b0.html"/>
    <id>https://ydstudios.gitee.io/post/818451b0.html</id>
    <published>2021-05-16T10:29:55.000Z</published>
    <updated>2021-05-16T15:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我在之前的文章<a href="https://juejin.cn/post/6932340144645079053" target="_blank" rel="noopener">孔乙己“茴”字四种写法引起我对策略模式实现的思考</a>中留下了一个悬念，文章中的代码实现出现了较多的重复代码块，这样的问题对于一个对代码质量有较高要求的人是不可容忍的。为啥这么说呢？因为这样的不合格的代码，无论是你还是他人进行维护或者更新新的功能，都必将难以下手，终将成为令众人“敬仰”的祖传代码。</p><a id="more"></a><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210516104524.jpeg" alt="给我安排上"><br>我们先大致回顾一下前文的内容，前文设定了一个抽奖的业务场景，奖品共有现金、优惠券、积分和谢谢参与四类，后续很大可能增加新的奖品类型如赠送抽奖次数，用户抽中则实时将奖励发送给用户。现在呢我们稍稍的改变下业务场景，我们还是回到之前的订单活动业务场景，活动分为多次住宿活动、连住订单活动、首次入住活动、会籍订单活动等等，订单满足活动条件会赠送积分、优惠券、会籍等奖品。由此可见，活动的类型和奖品的类型都是会逐渐的增多，所以针对此场景引出了策略设计模式，同时在编码的过程中发现很多重复的代码块和固定的的流程和逻辑，这个场景符合模板设计模式，于是引出了我们本文的另一主角：模板设计模式。</p><h4 id="问题在哪里"><a href="#问题在哪里" class="headerlink" title="问题在哪里"></a>问题在哪里</h4><p>首先我们先找出有哪些重复代码块：</p><ul><li>IRewardSendStrategy 接口的 isTypeMatch 方法，每个策略的最终实现内容都是一样的，这个是重复代码。</li><li>使用实现 InitializingBean 接口的方式组合策略类时，afterPropertiesSet 方法的实现，每个策略类的实现代码也都是重复代码。</li><li>判断订单是否符合活动的条件，符合条件则发送奖励，不符合则结束处理。这些逻辑是固定的，具体的判断过程和具体的奖励发放过程是不固定的，我们可以控制判断、发奖励的流程，让具体的判断过程和具体的奖励发放过程让子类去实现。</li></ul><p>重复代码块的出现，明显是不符合面向对象OOP的开发原则的，必将对软件的健康带来影响，那接下来我们来看看如何用模板设计模式来解决。</p><h4 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h4><p>我们知道可以用模板设计模式来解决重复代码的问题，提高代码利用率的同时，也可以让代码更加的健壮。那什么是模板设计模式？我先介绍一下模板设计模式。</p><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行，这种类型的设计模式属于行为型模式。模板模式中涉及到在父类实现算法骨架，具体步骤在子类实现，所以必须要有抽象类（Java8中的接口的 default 方法貌似也可以实现）。</p><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><ul><li>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li><li>主要解决：一些方法通用，却在每一个子类都重新写了这一方法。</li><li>何时使用：有一些通用的方法。</li><li>如何解决：将这些通用算法抽象出来。</li><li>关键代码：在抽象类实现，其他步骤延迟到子类实现。</li></ul><h5 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h5><ul><li>JDK中 ReentrantLock中公平锁和非公平锁的实现 </li><li>Spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session  等。</li></ul><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>封装不变部分，扩展可变部分。 </li><li>提取公共代码，便于维护。 </li><li>行为由父类控制，子类实现。</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>可能会增加代码的阅读难度。</li><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li></ul><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><ul><li>有多个子类共有的方法，且逻辑相同。 </li><li>重要的、复杂的方法，可以考虑作为模板方法。</li></ul><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><blockquote><p> 为防止子类重写，一般模板方法都加上 final 关键词。</p></blockquote><h4 id="具体应该怎样做"><a href="#具体应该怎样做" class="headerlink" title="具体应该怎样做"></a>具体应该怎样做</h4><p>接下来我就用代码来展现具体的做法，参照之前的代码，进行一些改动，具体代码我都会直接贴在文章中，我建议大家学习时，还是要动手去敲一敲，不要上来就要源码。要知道纸上得来终觉浅，自己还是要亲自去实践一把，才能得到不一样的经验。不要再说了，赶快开始吧！！！</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210516165507.jpeg" alt="talk is cheap , show me the code"></p><p>改造好的代码的UML图和机构图如下：</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210516161115.png" alt="代码的UML图"></p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210516160100.png" alt="代码结构"></p><ol><li><p>定义奖励、活动类型枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RewardTypeEnum &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 现金奖励</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CASH(<span class="string">"1"</span>,<span class="string">"现金"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 积分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    POINT(<span class="string">"2"</span>,<span class="string">"积分"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠券</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    COUPON(<span class="string">"3"</span>,<span class="string">"优惠券"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 谢谢参与</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    THANK_YOU(<span class="string">"4"</span>,<span class="string">"谢谢参与"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    RewardTypeEnum(String code, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ActiveTypeEnum &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 酒店订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HOTEL_ORDER(<span class="string">"1"</span>,<span class="string">"酒店订单"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会籍订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LEVEL_ORDER(<span class="string">"2"</span>,<span class="string">"会籍订单"</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    ActiveTypeEnum(String code, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义活动、奖励发放策略接口</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奖励发送的策略接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发放奖励的类型,通过这个方法来标示不同的策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 奖励类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String type)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送奖励</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memberId 会员id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单活动逻辑判断的策略接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IActiveHandleStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回活动的类型</span></span><br><span class="line"><span class="comment">     * ActiveCategoryEnum 枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getCategory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回活动的详细类型</span></span><br><span class="line"><span class="comment">     * ActiveCategoryDetailEnum 枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getCategoryDetail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否匹配</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> category 活动类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String category)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单检查</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temporaryOrderDto 临时订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activeDto 活动dto</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">checkOrder</span><span class="params">(ActiveOrderDto temporaryOrderDto, ActiveDto activeDto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>关键的一步就是识别出公共不变的方法、逻辑</strong>，将公共不变方法、固定的逻辑抽取到抽象父类中。</li></ol><p>参照 <strong>标题：问题在哪里</strong> 提出的问题 ，最终优化的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奖励发送的策略抽象类，将 isTypeMatch 方法和实现 InitializingBean 提升到抽象类中，达到代码复用的目的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRewardSendStrategy</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">RewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(type, <span class="keyword">this</span>.type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RewardSendStrategyFactory.registerStrategy(<span class="keyword">this</span>.type(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 活动抽象类,抽取公共方法,</span></span><br><span class="line"><span class="comment"> * 把订单是否符合奖励的判断之后发送奖励的公共逻辑在此处实现,</span></span><br><span class="line"><span class="comment"> * 订单具体条件的判断延迟由子类去实现.</span></span><br><span class="line"><span class="comment"> * 策略和模板模式组合使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractActiveHandleStrategy</span> <span class="keyword">implements</span> <span class="title">IActiveHandleStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其他抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">otherMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"其他公用方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String categoryDetail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(categoryDetail, <span class="keyword">this</span>.getCategoryDetail());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部真正要调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temporaryOrderDto 订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(ActiveOrderDto temporaryOrderDto, ActiveDto activeDto)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用接口中需要子类实现的方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result = checkOrder(temporaryOrderDto, activeDto);</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            log.error(<span class="string">"订单 &#123;&#125; 不符合活动 &#123;&#125; 的奖励发放条件"</span>, temporaryOrderDto.getOrderNo(), activeDto.getId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendReward(temporaryOrderDto, temporaryOrderDto.getMemberId(), activeDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统一的发送奖励的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temporaryOrderDto 订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memberId          用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activeDto         活动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendReward</span><span class="params">(ActiveOrderDto temporaryOrderDto, <span class="keyword">long</span> memberId, ActiveDto activeDto)</span> </span>&#123;</span><br><span class="line">        AbstractIRewardSendStrategy impl = RewardSendStrategyFactory.getImpl(activeDto.getRewardType());</span><br><span class="line">        impl.sendReward(memberId, activeDto);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抽象类中是可以没有抽象方法的，但一个类中如果有抽象方法，那这个类就必须定义成抽象类。</p></blockquote><ol start="4"><li>为了更好的提供给第三方调用，创建策略工厂整合策略。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RewardSendStrategyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存策略集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, AbstractRewardSendStrategy&gt; STRATEGY_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加策略实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerStrategy</span><span class="params">(String type, AbstractRewardSendStrategy strategy)</span> </span>&#123;</span><br><span class="line">        STRATEGY_MAP.put(type, strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取策略实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractRewardSendStrategy <span class="title">getImpl</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> STRATEGY_MAP.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责所有活动处理的入口,根据 getImpl(String categoryDetail)类型来判断调用具体的活动策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveHandleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractActiveHandleStrategy&gt; activeHandleList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外的统一入口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> categoryDetail 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractActiveHandleStrategy <span class="title">getImpl</span><span class="params">(String categoryDetail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> activeHandleList.stream().filter(strategy -&gt; strategy.isTypeMatch(categoryDetail))</span><br><span class="line">                .findAny()</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"没有找到策略实现"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>具体的策略实现</li></ol><p>因为策略实现代码比较简单，我这个地方就给出一个优惠券发放和会籍订单活动的策略实现，其他的大家照猫画虎就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"couponRewardSendStrategyV1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponRewardSendStrategy</span> <span class="keyword">extends</span> <span class="title">AbstractRewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RewardTypeEnum.COUPON.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"给[&#123;&#125;]发送优惠券奖品"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会籍订单的处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelOrderActiveHandleStrategy</span> <span class="keyword">extends</span> <span class="title">AbstractActiveHandleStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"会籍订单的实现"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ActiveTypeEnum.LEVEL_ORDER.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategoryDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ActiveTypeEnum.LEVEL_ORDER.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkOrder</span><span class="params">(ActiveOrderDto temporaryOrderDto, ActiveDto activeDto)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"判断订单 &#123;&#125; 的属性是否符合活动 &#123;&#125; 的条件"</span>, temporaryOrderDto, activeDto);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> i = random.nextInt(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>写个单元测试，看看具体的效果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>, <span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RewardSendStrategyFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ActiveHandleFactory activeHandleFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ActiveDto activeDto = <span class="keyword">new</span> ActiveDto();</span><br><span class="line">        activeDto.setId(<span class="number">101L</span>);</span><br><span class="line">        activeDto.setCategory(ActiveTypeEnum.HOTEL_ORDER.getCode());</span><br><span class="line">        activeDto.setCategoryDetail(ActiveTypeEnum.HOTEL_ORDER.getCode());</span><br><span class="line">        activeDto.setRewardType(RewardTypeEnum.COUPON.getCode());</span><br><span class="line">        activeDto.setReward(<span class="string">"No213215632"</span> + RewardTypeEnum.COUPON.getDesc());</span><br><span class="line"></span><br><span class="line">        ActiveOrderDto activeOrderDto = <span class="keyword">new</span> ActiveOrderDto();</span><br><span class="line">        activeOrderDto.setMemberId(<span class="number">11L</span>);</span><br><span class="line">        activeOrderDto.setOrderType(<span class="string">"1"</span>);</span><br><span class="line">        activeOrderDto.setOrderNo(<span class="string">"202105111"</span>);</span><br><span class="line"></span><br><span class="line">        AbstractActiveHandleStrategy impl = activeHandleFactory.getImpl(activeDto.getCategoryDetail());</span><br><span class="line">        impl.handle(activeOrderDto, activeDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试的输出结果如下：</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210516164456.png" alt="单元测试结果"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这样我们的代码就优化完了，AbstractActiveHandleStrategy.handle() 方法中逻辑是固定不变的，这样就确定好了代码的逻辑骨架，后续有新的订单活动或者新的奖励类型，这个地方的代码都不需要改动，只需要增加对应接口的子类就行，符合开闭原则。大家看我代码写了很多，其实关键地方就在那个handle方法上。这样看起来模板设计模式是不是很简单，而且模板和策略两个模式也能很好的结合，最后的效果也不错，其实这两个只要你写稍微复杂一点的代码，都是有他们俩的使用场景的。另外由上文我们就可以看出，设计模式之间其实并不是割裂的，复杂的业务代码实现时，可能会符合多种设计模式。作为程序员我们就要对业务进行抽象，用更多更好并且合理的模式去实现。另外多说一句，大家在学习的时候一定要多多思考，多多动手，千万不要养成眼高手低的习惯，要知道纸上得来终觉浅，绝知此事要躬行的道理。设计模式系列的文章我会持续的更新，下一篇的主题有可能是管道模式，请大家敬请期待吧！哈哈！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;我在之前的文章&lt;a href=&quot;https://juejin.cn/post/6932340144645079053&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;孔乙己“茴”字四种写法引起我对策略模式实现的思考&lt;/a&gt;中留下了一个悬念，文章中的代码实现出现了较多的重复代码块，这样的问题对于一个对代码质量有较高要求的人是不可容忍的。为啥这么说呢？因为这样的不合格的代码，无论是你还是他人进行维护或者更新新的功能，都必将难以下手，终将成为令众人“敬仰”的祖传代码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://ydstudios.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://ydstudios.gitee.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板模式" scheme="https://ydstudios.gitee.io/tags/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>怎样做才能成为一个好的leader</title>
    <link href="https://ydstudios.gitee.io/post/bf81348a.html"/>
    <id>https://ydstudios.gitee.io/post/bf81348a.html</id>
    <published>2021-03-22T23:46:02.000Z</published>
    <updated>2021-03-22T16:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写这篇文章，是因为之前和一个朋友讨论“什么样的领导才是好领导”问题引起的。本人15年大学毕业，先后在三家公司任过职。好的、不好的leader也都遇见过，自己也曾短暂的担任过小leader。下面就由我根据自己短暂的职业生涯，来简单的总结一下，要想做好一个leader到底需要做哪些事情？</p><a id="more"></a><h3 id="重要的点"><a href="#重要的点" class="headerlink" title="重要的点"></a>重要的点</h3><ol><li><p>身体是革命的本钱，要坚持定期锻炼身体。要想管理好一个团队是要花费很大精力的，如果身体不好精力不佳，何谈工作。所以无论何时、无论处于何种职位，坚持定期锻炼身体都是必须的。</p></li><li><p>处理好家庭事务，不要后院起火。避免生活和工作之间彼此影响，导致自己两线作战影响工作。其实，不管是leader还是普通的员工，处理好家庭事务也是必须的。</p></li><li><p>要有担当，敢于决策。遇到问题你不能还像一个基层员工那样，简单的把问题抛给上级主管了，你必须要有自己的决策；如果确实决策不了需要请示更高的领导，你自己也需要有明确的主张和建议。注意，不要自己做完决策，后期出现问题的时候，就把锅甩给下属。</p></li><li><p>赏罚分明,过程要尽量做到公平公正公开。并且平时少惩罚多奖励，利用好自己手中的考核权。赏罚是一种手段，不是目的，运用好考核权可以让大家在做好本职工作的同时，能更进一步考虑本职工作以外的事情。</p></li><li><p>工作要有规矩。制定规矩时可以和大家一起讨论，这时大家可以畅所欲言，但是一旦制定后就必须严格执行，包括leader本人在内。如果后期发现规范有问题，可以团队成员一起讨论修改重新制定。leader本人一定要注意严格遵守，一旦被他人发现leader都没有遵守规范规矩，你不要以为没有什么，实际上你会丧失你在团队成员中的公信力。作为团队leader你在团队中没有公信力，你后续的工作是不好开展的！</p></li><li><p>位得其人,人尽其才,适才适所,人事相宜。团队中各成员能力难免参差不齐，作为leader你需要了解每个人的优点和缺点，然后给出最适合各个成员的工作安排。</p></li><li><p>团队成员要有定期互动，出现了问题要及时复盘总结，最好是形成方法论，避免下次犯同样的错误。建议每周开一次例会进行讨论汇报；定期做技术分享，技术团队一定要有技术氛围。</p></li><li><p>要懂得为自己团队争取应得的权利与利益。不要轻易的承接来自主管或其他部门的任务，承接任务时，一定要先评估目前团队的人力和能力，如果没有做好评估就承接下来，任务的结果很大可能就是无法按时完成，到时候可能就需要安排团队成员加班。项目完成的不够完美，你的leader可能就会不太满意；本来不用加班，却因为你自己的问题导致团队成员加班，成员对你的态度肯定也是满是牢骚。这个时候你就是风箱里的老鼠——两头受气 ，最终人家对你的评价可能就是：一将无能累死三军。承接额外任务的同时看看能不能为团队争取一下福利，福利少总比没有强吧！</p></li><li><p>懂得培养下属。leader要避免事必躬亲，要善于放权，这样可以既可以让团队成员积极参与项目，又可以当做是培养和锻炼团队成员的机会。</p></li><li><p>注意关心团队成员。平日多多注意团队成员的精神、情绪、工作强度等状况。适当了解团队成员的家庭、生活等情况，一来关心部下是应该的，二来防止成员因为上述问题导致工作失误，从而影响项目的进展。</p></li><li><p>要有容人之心，不要小肚鸡肠。你被提拔为团队leader，并不是因为某项能力突出，而是整体综合能力突出，有成为一个的leader的潜质。你要明白团队里可能会有人在某项技能上比你厉害，团队中对待同一个问题有不同的看法很正常，不要觉得团队成员提出和你不一样的观点，你就觉得他是对你有意见。咱们技术人做事，最好就是对事不对人。团队里有人在某项技能上比你好，你此时应该高兴，应该想着怎么利用好他，让他帮你完成工作，而不是整天想着找机会给他穿小鞋。</p></li><li><p>不要用贬低他人的方式来抬高自己。这种就不用说了吧！即使你不是团队leader，这种行为也不能有。之前遇到一个项目leader就是这样，说你这设计的不好，那做的不好。然后你问他我这做的不好，你说说看你有什么更好的办法么，他就呵呵一笑就没了。</p></li><li><p>对待自己的leader、同事或者下属态度可以不一样，但是不要表面一套背地里一套。不要在leader前说大家都是同事，对待同事不管是同级别还是下属，都要客客气气的。实际上你对同级看不起，对下属你吆五喝六。</p></li><li><p>不要贪恋不属于自己的功劳。事情是你和下属一起做的，你作为团队leader向上级汇报的时候，记得提一下下属的名字。要让下属觉得跟着你可以有福同享，在你手下干活有前途。</p></li><li><p>不要在其他团队面前吐槽团队成员，更不要在其他团队面前并且有自己团队成员在场的情况下吐槽团队成员。要批评你可以在自己团队内部批评，你作为团队leader你这样做，还有没有一点团队自豪感，还想让团队有凝聚力嘛，你这样的团队之前再有凝聚力，也被你这样的骚操作给整没了。大家不要觉得这样的场景现实情况下不存在，我跟大家说实际情况比这个还魔幻。记得当时场景是这样的，当时参加一次会议，人员还没有到齐，现场只有产品、我还有当时的项目leader三个人，不知因为啥项目leader开始吐槽我们团队里的某个人，说他能力不行啥啥的，我当时就震惊了，心想还有这种骚操作，在这种场合下吐槽自己下属不太合适吧！更魔幻的来了，产品来打圆场，说不是他的问题！就这样了那个项目leader还在那不停的说，我当时就更震惊了，这场景感觉角色反串了。一般都是其他团队人说自己团队不好，然后团队负责人据理力争，维护自己的团队。他这倒好反过来了，你想这种事情被团队成员知道了，团队成员会怎么想，就你这还领导啥团队啊！</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的leader大致雷同，不好的leader各有各的不好。好leader都是可遇不可求的。你要是遇到一个能在技术、业务和思想上都能指导你，并且愿意指导你的leader，没事你就偷着乐吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;写这篇文章，是因为之前和一个朋友讨论“什么样的领导才是好领导”问题引起的。本人15年大学毕业，先后在三家公司任过职。好的、不好的leader也都遇见过，自己也曾短暂的担任过小leader。下面就由我根据自己短暂的职业生涯，来简单的总结一下，要想做好一个leader到底需要做哪些事情？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="团队" scheme="https://ydstudios.gitee.io/tags/%E5%9B%A2%E9%98%9F/"/>
    
      <category term="领导" scheme="https://ydstudios.gitee.io/tags/%E9%A2%86%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>一个SQL错误的问题让我找到了公司框架中三个bug</title>
    <link href="https://ydstudios.gitee.io/post/8d7cd68c.html"/>
    <id>https://ydstudios.gitee.io/post/8d7cd68c.html</id>
    <published>2021-03-20T11:08:58.000Z</published>
    <updated>2021-05-29T08:15:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是对之前开发中遇到的问题的一个总结，文章其实早就写好，但是觉得自己写的不够深入，就让文章一直躺在草稿箱里。昨天突然想起来了，就将文章重新修改了一下，还是发出来吧！</p><a id="more"></a><h3 id="问题1：框架生成的SQL字段重复"><a href="#问题1：框架生成的SQL字段重复" class="headerlink" title="问题1：框架生成的SQL字段重复"></a>问题1：框架生成的SQL字段重复</h3><p>当时我在开发一个异常日志记录接口，其实业务流程很简单，就是前端提交错误日志到后台，后台接受到信息处理一番，然后插入数据库。因为这个接口的并发量比较高，为了不影响其他业务，并且同时提高响应的速度。于是采用 @Async 注解+ Spring线程池的方案来实现。线程池的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"jobExecutor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"jobExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"20"</span> <span class="attr">queue-capacity</span>=<span class="string">"500"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<a href="task:annotation-driven/">task:annotation-driven/</a>开启异步时，一定要记得配置executor属性，不然异步使用的线程池其实是 <code>org.springframework.core.task.SimpleAsyncTaskExecutor</code>，但这个 SimpleAsyncTaskExecutor 不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程。</p></blockquote><p>关键部分伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     ExceptionLogEntity exceptionLogEntity = <span class="keyword">new</span> ExceptionLogEntity();</span><br><span class="line">     exceptionLogEntity.setXX(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setXXX(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setIp(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setUrl(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setBusinessScene(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setExceptionType(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setExceptionDetailType(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setExceptionMessage(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setNoticeStatus(<span class="string">""</span>);</span><br><span class="line">     exceptionLogEntity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">     exceptionLogEntity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     ExceptionLogEntity insert = exceptionLogDao.insert(exceptionLogEntity);</span><br><span class="line">     log.info(<span class="string">"实体的主键id=[&#123;&#125;]"</span>, insert.getId());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码写完我简单的测试了一下，没啥问题后就告知前端可以对接了。可是奇怪的事情发生了，前端老铁告诉我接口有时会返回错误。我一听就感觉不对劲，心想这么简单的接口，我怎么可能有bug。于是我到日志平台上查询了一下日志，结果还真的是有问题。发现了一个SQL错误，具体错误如下(敏感信息已经处理)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`xx`</span>(<span class="string">`xx`</span>,<span class="string">`xx`</span>,<span class="string">`ip`</span>,<span class="string">`url`</span>,<span class="string">`business_scene`</span>,<span class="string">`exception_type`</span>,<span class="string">`exception_detail_type`</span>,<span class="string">`exception_message`</span>,<span class="string">`notice_status`</span>,<span class="string">`create_time`</span>,<span class="string">`update_time`</span>,<span class="string">`xx`</span>,<span class="string">`member_phone`</span>,<span class="string">`ip`</span>,<span class="string">`url`</span>,<span class="string">`business_scene`</span>,<span class="string">`exception_type`</span>,<span class="string">`exception_detail_type`</span>,<span class="string">`exception_message`</span>,<span class="string">`notice_status`</span>,<span class="string">`create_time`</span>,<span class="string">`update_time`</span>) <span class="keyword">VALUES</span>(<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">'2020-01-08 19</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at sun.reflect.GeneratedMethodAccessor115.invoke(Unknown Source)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at java.lang.reflect.Method.invoke(Method.java:498)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at coderead.mybatis.log.JdbcCommonCollects$PreparedStatementHandler.invoke(JdbcCommonCollects.java:118)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">... 21 more</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Column '</span>update_time<span class="string">' specified twice</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at com.mysql.jdbc.Util.handleNewInstance(Util.java:425)</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210320172109.jpeg" alt="问题真多"></p><h4 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h4><p>这个问题简单的来说就是SQL中的字段发生了重复，<code>Column &#39;update_time&#39; specified twice</code>。其实不止update_time字段发生了重复，是很多字段都发生了重复。因为这个接口除了并发高一点之外，和其他的接口没有什么特别之处！突然我脑子里灵光一闪，难道是这个接口并发较高，导致框架在生成INSERT类型的SQL发生了错误？？？要是这样的话，我直接创造一个这样的场景不就可以实现了嘛！然后我写下了下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ExceptionLogEntity exceptionLogEntity = <span class="keyword">new</span> ExceptionLogEntity();</span><br><span class="line">            exceptionLogEntity.setXX(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setXXX(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setIp(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setUrl(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setBusinessScene(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setExceptionType(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setExceptionDetailType(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setExceptionMessage(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setNoticeStatus(<span class="string">""</span>);</span><br><span class="line">            exceptionLogEntity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">            exceptionLogEntity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                exceptionLogDao.insert(exceptionLogEntity);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码写完直接重启项目，最后一触发上面的代码。果然，同样的错误又出现了。这里我先介绍下使用的ORM框架：</p><blockquote><p>此ORM框架是集团O2O研发中心研发的基础组件，提供同Mybatis一样的功能：只需定义接口，无需写实现类。此外，对单表操作还封装了一套常用的增删改查处理，连接口也无需再定义，对开发人员非常友好，大大降低了冗长的jdbc操作代码量，提升了开发效率。</p></blockquote><p>我问了问旁边的同事，在使用公司的ORM框架自带的INSERT方法时，有没有遇到SQL列重复的问题吗?嘿你还别说，大家异口同声说遇到过。那厉害了，看来这真的不是个别现象，真的是框架的bug。于是乎我花了一点时间来找找看到底是在哪个地方出现了问题，皇天不负有心人我还真的找到了，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DalColumn&gt; <span class="title">getDalColumnsWithoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.columnsWithoutId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.columnsWithoutId;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.columnsWithoutId = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.dalColumns.size() - <span class="number">1</span>);</span><br><span class="line">        Iterator var1 = <span class="keyword">this</span>.dalColumns.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">            DalColumn column = (DalColumn)var1.next();</span><br><span class="line">            <span class="keyword">if</span> (!column.isIdColumn()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.columnsWithoutId.add(column);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.columnsWithoutId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就出在<code>columnsWithoutId</code>上，它的类型是<code>List</code>，是所在类的一个属性默认为null，保存的是一个表除主键ID之外的所有字段。上面的代码在单线程情况下没有问题，但是在多线程的情况下就问题大了。<code>columnsWithoutId</code>在多线程情况下就是一个<code>线程共享变量</code>，假设在某个时机有多个线程恰好执行到<code>if</code>代码块，发现<code>columnsWithoutId</code>的值为null，则就会同时执行<code>else</code>代码块，那这时就会执行多次循环，自然<code>columnsWithoutId</code>中的字段就会出现了重复。</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>这个问题已经找到，那接下来就差一个解决方案了。</p><h5 id="官方修复"><a href="#官方修复" class="headerlink" title="官方修复"></a>官方修复</h5><p>我当时想既然这个框架是公司研发中心提供的基础组件，那就是说明在公司内部会有很多项目组使用，问题说不定早就被修复了。你还别说在公司的wiki上我还真的找到了，有位负责这个组件的大佬在wiki上分享了”单表插入偶发列重复问题定位与解决”的文章。(文章地址我就不发了，公司内部地址发出来你们也访问不了)文章里详细的描述了问题发生的场景（和我上面描述的差不多）、问题定位过程还有解决方案。摘选文章上的解决方案：</p><blockquote><p>明确了是线程安全的问题，解决方案就好确定了，解决线程安全有三种方案：<br>方案一：互斥同步——synchronized,ReentrantLock<br>方案二：非阻塞同步——CAS<br>方案三：无同步方案:——ThreadLocal<br>结合业务场景，综合分析，最终确认使用方案一，采用synchronized关键字，使用双重检查锁的方式解决此问题。</p></blockquote><p>大佬已经将bug修复并发布了新版本到Maven仓库，项目中有发生上述问题的，直接升级对应的组件版本即可。既然官方已经给出了解决方案，我直接升级项目中的组件版本号就行了。结果我一更换项目中的版本，我的项目就再也没有启动起来。研究发现，组件版本相差太多，很多依赖发生了冲突。我项目中使用的是<code>1.1.6-RELEASE</code>,问题官方在版本<code>2.1.0-RELEASE</code>中修复。这组件版本差距太大贸然升级肯定是有很大的风险了，于是我放弃了！</p><h5 id="另辟蹊径解决"><a href="#另辟蹊径解决" class="headerlink" title="另辟蹊径解决"></a>另辟蹊径解决</h5><p>既然你自带的插入方法有问题，我直接自定义一个插入方法不就得了。惹不起我还躲不起么！我最后又问了同事们最后都是怎么解决的，大家也都说是自定义SQL，而且都不再用框架自带的方法了，大家都很聪明呀！（其实这个还有后续，后面有一期开发过程中，需要用到批量插入的功能，我又偷懒用了框架自带的batch方法，又把我给坑了。从那之后，我再也没有用自带的方法了……）</p><h3 id="问题2：主键数据溢出"><a href="#问题2：主键数据溢出" class="headerlink" title="问题2：主键数据溢出"></a>问题2：主键数据溢出</h3><p>我再排查上面的问题的时候，在框架里面看到了下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Number <span class="title">execute4PrimaryKey</span><span class="params">(String sqlId, Map&lt;String, Object&gt; paramMap, KeyHolder keyHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">    String sql = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Object var8;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MappedStatement mappedStatement = <span class="keyword">this</span>.configuration.getMappedStatement(sqlId, <span class="keyword">true</span>);</span><br><span class="line">        mappedStmtThreadLocal.set(mappedStatement);</span><br><span class="line">        sql = mappedStatement.getBoundSql(paramMap);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (keyHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.execution.update(sql, <span class="keyword">new</span> MapSqlParameterSource(DalUtils.mapIfNull(paramMap)), keyHolder);</span><br><span class="line">            result = keyHolder.getKey() == <span class="keyword">null</span> ? <span class="number">0</span> : keyHolder.getKey().intValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.execution.update(sql, DalUtils.mapIfNull(paramMap));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer var9 = result;</span><br><span class="line">        <span class="keyword">return</span> var9;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var13) &#123;</span><br><span class="line">        <span class="keyword">this</span>.throwException(var13);</span><br><span class="line">        var8 = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mappedStmtThreadLocal.remove();</span><br><span class="line">        logger.debug(<span class="string">"&#123;&#125; method:&#123;&#125;, sql:&#123;&#125;, param:&#123;&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>.logPrefix, <span class="string">"execute"</span>, sql, paramMap&#125;);</span><br><span class="line">        <span class="keyword">this</span>.logProfileLongTimeRunningSql(startTimestamp, sql, paramMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Number)var8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家仔细看看，这上面的代码有个不容易发现的问题。问题是这样的，我们系统中表的主键类型定义的都是<code>bigint</code>,这个类型对应的是Java中的<code>Long</code>类型，说到这大家明白了么？对了，就是数据溢出的问题。</p><h4 id="复现问题-1"><a href="#复现问题-1" class="headerlink" title="复现问题"></a>复现问题</h4><p>我将表中的主键自增量设置为Java Int类型的最大值+1，也就是2147483648。然后数据库再新增一条记录，此时表中记录的主键是2147483648，但Java实体中的主键ID已经是个负数-2147483648了。</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210320111207.png" alt="数据溢出"></p><blockquote><p>使用Long类型时，要注意JavaScript接收后端Long类型数据精度丢失问题</p></blockquote><h4 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h4><p>这个问题还真不好另辟蹊径了，只能后面出现类似的问题，升级ORM框架的版本了。</p><h3 id="问题3：共享变量并发问题"><a href="#问题3：共享变量并发问题" class="headerlink" title="问题3：共享变量并发问题"></a>问题3：共享变量并发问题</h3><p>其实这个问题我应该在看那篇内部文章的时候就应该发现的，但我当时就是没有看出来！此时的我留下了没有技术的泪水。对于问题1，当时那位大佬最终采用<code>synchronized</code>进行加锁解决多线程情况下共享变量读写问题，具体代码如下（敏感信息打码）：</p><p>修改前的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DalColumn&gt; <span class="title">getDalColumnsWithoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.columnsWithoutId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.columnsWithoutId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.columnsWithoutId = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.dalColumns.size() - <span class="number">1</span>);</span><br><span class="line">            Iterator var1 = <span class="keyword">this</span>.dalColumns.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">                DalColumn column = (DalColumn)var1.next();</span><br><span class="line">                <span class="keyword">if</span> (!column.isIdColumn()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.columnsWithoutId.add(column);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.columnsWithoutId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>修改后的代码(引用文章中的代码截图)：</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210320111201.png" alt="共享变量共享问题代码"></p><h4 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h4><p>这个问题要复现的话，不太好复现，因为情况是比较极端的，但是在复杂的生产环境还是很可能出现的。</p><p>举例说明：</p><p>假设有A、B两个线程，A线程执行到for循环处，B线程恰好执行到最开始的if判断处，由于此时的cloumnsWithId已经被A线程赋值，肯定不为null，然后线程B就直接返回了，导致B线程调用者获得了一个空的或者保存部分字段的cloumnsWithId。这种情况最终导致的结果是INSERT SQL中的字段缺失。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>对于多线程下的共享变量，我们一定要坚持<code>读读可并行，读写要排队</code>的原则。当然能不加锁的话，也是不错的选择。</p><p>我发现这个问题之后，就找到了前文中说的大佬，跟他反馈了我的想法，并提出我的解决方案。</p><ol><li><p>直接在<code>getDalColumnsWithoutId</code>方法上添加 <code>synchronized</code>。</p></li><li><p>修改第一个if判断逻辑，然后使用<code>synchronized</code>锁代码块。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DalColumn&gt; <span class="title">getDalColumnsWithoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = CollectionUtils.size(<span class="keyword">this</span>.dalColumns);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.size(<span class="keyword">this</span>.columnsWithoutId) == size &amp;&amp; size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.columnsWithoutId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="keyword">if</span> (columnsWithoutId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            columnsWithoutId = <span class="keyword">new</span> ArrayList&lt;&gt;(size*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (DalColumn column :  <span class="keyword">this</span>.dalColumns)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!column.isIdColumn()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.columnsWithoutId.add(column);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.columnsWithoutId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时与大佬的沟通截图，来自大佬的肯定：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210320111152.png" alt="沟通反馈记录" style="zoom:35%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在遇到问题的时候不要着急，一定要学会大胆假设，然后小心求证。要勇敢的质疑权威，不要认为既然已经是框架了就没有bug。例如Spring从当初的1.0到现在版本号都超过5.0了，除了给Spring增加新的功能，其他的升级就是在修复Spring中的bug。做出自己的假设之后，就要进行场景复现，一个正常的bug是可以不断的被复现的。复现了问题那就是找到问题的症结所在，剩下的就是如何去解决啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文是对之前开发中遇到的问题的一个总结，文章其实早就写好，但是觉得自己写的不够深入，就让文章一直躺在草稿箱里。昨天突然想起来了，就将文章重新修改了一下，还是发出来吧！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="https://ydstudios.gitee.io/tags/java/"/>
    
      <category term="并发" scheme="https://ydstudios.gitee.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何保证RocketMQ消息不丢失</title>
    <link href="https://ydstudios.gitee.io/post/b6f085c7.html"/>
    <id>https://ydstudios.gitee.io/post/b6f085c7.html</id>
    <published>2021-03-12T10:31:13.000Z</published>
    <updated>2021-03-14T15:26:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着业务的发展，系统功能也越来也复杂。渐渐的我们会遇到这样的问题。例如，系统和多个外部系统交互对接耗时耗力、系统某个模块流程处理时间过长业务越来越接受不了、某个模块在某个时间点流量太大系统时刻有宕机的风险等等。对于这些问题要想解决，系统此时引入消息队列或许是一个不错的选择。我们都知道消息队列有三大技能：解耦、异步、削峰。看起来可以完美的解决上面提到的问题，但是你们的系统真的适合消息队列么？</p><a id="more"></a><p>系统在引入消息队列之后到底会带来哪些不好的影响，我们今天来说一说：</p><ul><li><p>系统可用性降低，增加运维难度</p><p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。以前A、B、C三个系统正常，服务就没有问题。现在A系统引入消息队列，B、C消费消息，现在消费队列宕机，业务就执行不下去了。如何保证MQ的高可用？</p></li><li><p>系统复杂度提高</p><p>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？如何保证顺序消息能被正确的消费？</p></li><li><p>一致性问题</p><p>A系统处理完业务，通过MQ给B、C系统发消息数据，如果B系统、C系统处理失败。这样的情况要怎么处理，如何保证消息数据处理的一致性？</p></li></ul><p>看到了吧引入一个消息队列，就会带来这么的问题！所以大家在使用消息队列的时候，千万要想清楚，自己的系统适不适合、有没有那个运维能力、业务能不能接受！本文这次只谈<strong>如何让消息队列不丢失消息</strong>，且以RocketMQ为例。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210313110021.jpeg" alt="傻了吧" style="zoom:50%;" /><p>一个消息到开始到结束会经历这么三个阶段：生产阶段、消息队列Broker存储阶段和消费阶段。一个消息在三个阶段中的任何一个阶段都有可能丢失，知道这个之后，我们只要保证这三个阶段不出现问题，消息自然就不会出现丢失了。接下来我们来细说一下如何保证这三个阶段不出现问题。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210312222344.png" alt="生产阶段、消息队列Broker存储阶段和消费阶段" style="zoom:50%;" /><h3 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h3><p>生产阶段的使命就是将消息发送到队列之中。生产者（Producer）通过网络请求将消息发送给消息队列，消息队列接受到之后返回响应给生产者。RocketMQ有两种常用的消息发送方式：同步发送、异步发送。</p><h4 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"unique_group_name"</span>, <span class="keyword">true</span>);</span><br><span class="line">      producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876;127.0.0.1:9870"</span>);</span><br><span class="line"></span><br><span class="line">      SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">      String content = <span class="string">"测试消息"</span> + format.format(<span class="keyword">new</span> Date());</span><br><span class="line">      Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, <span class="string">"TagA"</span>, UUID.randomUUID().toString(), content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          producer.start();</span><br><span class="line">          SendResult sendResult = producer.send(msg);</span><br><span class="line">          log.info(<span class="string">"MsgId= &#123;&#125;,结果= &#123;&#125; "</span>, sendResult.getMsgId(), sendResult.getSendStatus());</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | InterruptedException | MQBrokerException e) &#123;</span><br><span class="line">          log.error(<span class="string">"消息发送发生了错误[&#123;&#125;]"</span>, msg, e);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>同步发送时只要<code>send()</code>方法没有抛出异常，就可以认为消息发送成功，即消息队列Broker成功接受到了消息。</p><p>既然是同步发送肯定就比较耗费一些时间，如果你的业务比较注重RT那就可以使用异步发送的方式。</p><h4 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h4><p>异步发送消息的方式可以降低消息发送的RT，我比较喜欢这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"unique_group_name"</span>, <span class="keyword">true</span>);</span><br><span class="line">   producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876;127.0.0.1:9870"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 消息自定义的唯一标识</span></span><br><span class="line">   String key = UUID.randomUUID().toString();</span><br><span class="line">   String content = <span class="string">"消息发送测试"</span>;</span><br><span class="line">   Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, <span class="string">"TagA"</span>, key, content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       producer.start();</span><br><span class="line">       producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">               log.info(<span class="string">"根据消息[&#123;&#125;]的key[&#123;&#125;]更新消息[&#123;&#125;]的发送状态[&#123;&#125;]"</span>, msg.getProperty(MessageConst.PROPERTY_KEYS), key, sendResult.getMsgId(), sendResult.getSendStatus());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">               log.error(<span class="string">"发送出现错误[&#123;&#125;]"</span>, msg, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemotingException | InterruptedException e) &#123;</span><br><span class="line">       log.info(<span class="string">"消息发送发生异常[&#123;&#125;]"</span>, msg, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用异步发送方式时记得重写<code>SendCallback</code>类的两个方法，在<code>onSuccess()</code>方法中更新消息的发送状态为发送成功,只要不发生异常且回调了<code>onSuccess()</code>方法也可以认为成功发送到了Broker。</p><h4 id="SendStatus问题"><a href="#SendStatus问题" class="headerlink" title="SendStatus问题"></a>SendStatus问题</h4><p>发送消息时，将获得包含SendStatus的SendResult。以下是每个状态的说明列表：</p><ul><li><p>SEND_OK<br>SEND_OK并不意味着它是可靠的。要确保不会丢失任何消息，还应启用SYNC_MASTER或SYNC_FLUSH。</p></li><li><p>FLUSH_DISK_TIMEOUT<br>如果Broker设置MessageStoreConfig的FlushDiskType = SYNC_FLUSH（默认为ASYNC_FLUSH），并且Broker没有在MessageStoreConfig的syncFlushTimeout（默认为5秒）内完成刷新磁盘，您将获得此状态。</p></li><li><p>FLUSH_SLAVE_TIMEOUT<br>如果Broker的角色是SYNC_MASTER（默认为ASYNC_MASTER），并且从属Broker未在MessageStoreConfig的syncFlushTimeout（默认为5秒）内完成与主服务器的同步，则您将获得此状态。</p></li><li><p>SLAVE_NOT_AVAILABLE<br>如果Broker的角色是SYNC_MASTER（默认为ASYNC_MASTER），但没有配置slave Broker，您将获得此状态。</p></li></ul><p>对于SendStatus有多种情况的问题，因此无论使用同步还是异步的发送方式，都需要判断SendStatus是不是SEND_OK，如果不是则需要针对不同的情况进行分别处理。</p><ul><li><p>FLUSH_DISK_TIMEOUT，FLUSH_SLAVE_TIMEOUT<br>这两种情况说明消息落盘出现了异常，为了不丢失消息，我们可以稍等时间后重发消息。</p></li><li><p>SLAVE_NOT_AVAILABLE<br>这种情况说明集群中的Slave不可用，重新发送是无用的，需要人工介入处理。</p></li></ul><p>其实你查看RocketMQ的源码就会发现，不论是同步发送还是异步发送，都是可以针对不同的场景自定义重试次数的，而且很多方法还有内部重试机制。</p><blockquote><p><strong>Warn:</strong> this method has internal retry-mechanism, that is, internal implementation will retry<br>{@link #retryTimesWhenSendFailed} times before claiming failure. As a result, multiple messages may potentially<br>delivered to broker(s). It’s up to the application developers to resolve potential duplication issue.</p></blockquote><p>源码默认的处理方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maximum number of retry to perform internally before claiming sending failure in synchronous mode. &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This may potentially cause message duplication which is up to application developers to resolve.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendFailed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maximum number of retry to perform internally before claiming sending failure in asynchronous mode. &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This may potentially cause message duplication which is up to application developers to resolve.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendAsyncFailed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicate whether to retry another broker on sending failure internally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> retryAnotherBrokerWhenNotStoreOK = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>自定义重试机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">5</span>);</span><br><span class="line">producer.setRetryAnotherBrokerWhenNotStoreOK(<span class="keyword">true</span>);</span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这里就要提下消息投递语义（message delivery semantic），简单的来说就是消息传递过程中的传递保证。主要分为三种：</p><ul><li>at most once：最多一次。消息可能丢失也可能被处理，但最多只会被处理一次。</li><li>at least once：至少一次。消息不会丢失，但可能被处理多次,可能重复，不会丢失。</li><li>exactly once：精确传递一次。消息被处理且只会被处理一次,不丢失不重复就一次。</li></ul><p>有些异常情况的出现，可能是因为网络的偶尔波动导致，其实已经发送到了Broker，只不过是返回ACK给生产者的时候出现了超时，这个时候生产者重试就会导致消息重复投递。毕竟生产者为了保证消息一定成功投递到Broker中，就无法保证只进行一次精确投递。为了防止消息重复消费，那就需要消费者自身保证业务处理的幂等性。另外<strong>对于发送状态SendStatus 不是SEND_OK的消息要使用定时任务进行补偿发送</strong>。还要提到一点的就是，重试也是需要做好限制的，设定最大重试次数，也要保证重试的时间间隔，毕竟经验告诉我们，有些异常情况下短时间内的重试是没有意义的。具体的设计可以参考我之前文章中的本地消息表方案，<strong>本地事务+定时任务补偿</strong>保证消息一定投递成功。</p><h3 id="消息队列Broker存储阶段"><a href="#消息队列Broker存储阶段" class="headerlink" title="消息队列Broker存储阶段"></a>消息队列Broker存储阶段</h3><p>默认的情况下，消息队列为了快速响应，在接受到生产者的请求，将消息保存在内存成功之后，就会立刻返回ACK响应给生产者。</p><p>你以为人家的架构是这样的：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210312223315.png" alt="你以为人家的架构是这样的" style="zoom:50%;" /><h4 id="消息刷盘方式"><a href="#消息刷盘方式" class="headerlink" title="消息刷盘方式"></a>消息刷盘方式</h4><ul><li><p>同步刷盘<br>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p></li><li><p>异步刷盘<br>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p></li></ul><p>将默认的异步刷盘修改成同步刷盘</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">flushDiskType=SYNC_FLUSH</span></span><br></pre></td></tr></table></figure><p>异步刷盘方式在遇到消息队列宕机、机器异常断电或者内存硬盘损坏的情况，消息就无法成功持久化到硬盘中，那这个消息就永久丢失了。对于这种情况，我们就需要改变RocketMQ的刷盘机制，将默认的异步刷盘，修改成同步刷盘。即消息成功保存到硬盘上时才返回给生产者ACK响应。</p><p>其实人家的架构是这样的：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210312224045.png" alt="image-20210312223647464" style="zoom:50%;" alt="其实人家的架构是这样的"/><p>同步刷盘的缺点很明显，那就是降低了吞吐量，加大了消息发送的响应RT时间，但是为了不丢失宝贵的消息这一点损耗是值得的。</p><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p>上面讲的是单个消息队列Broker对于可靠保存消息的处理方式，但是生产环境肯定是采用的集群部署。目前RocketMQ支持单Master模式、多Master模式、多Master多Slave模式（异步）和多Master多Slave模式（同步）4种集群方式。</p><blockquote><p>我这里申明一下，生产环境下的消息队列一定是采用集群的方式进行部署，不会有单机部署的情况。自己在本地搞搞单机部署玩玩肯定是可以的，生产环境也这么搞，你肯定是在逗我！</p></blockquote><h5 id="单Master模式"><a href="#单Master模式" class="headerlink" title="单Master模式"></a>单Master模式</h5><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p><h5 id="多Master模式"><a href="#多Master模式" class="headerlink" title="多Master模式"></a>多Master模式</h5><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p><ul><li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li><li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li></ul><h5 id="多Master多Slave模式"><a href="#多Master多Slave模式" class="headerlink" title="多Master多Slave模式"></a>多Master多Slave模式</h5><h6 id="异步刷盘多Master多Slave模式"><a href="#异步刷盘多Master多Slave模式" class="headerlink" title="异步刷盘多Master多Slave模式"></a>异步刷盘多Master多Slave模式</h6><p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p><ul><li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li><li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li></ul><h6 id="同步多Master多Slave模式"><a href="#同步多Master多Slave模式" class="headerlink" title="同步多Master多Slave模式"></a>同步多Master多Slave模式</h6><p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p><ul><li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li><li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li></ul><p>即使消息成功保存到了Master的硬盘上，然后在Master将消息同步给Slave的时候，这个期间Master挂了，而且是那种硬盘修不好的那种，不要说这种情况不可能，支付宝的专用电缆都能被挖断，还有啥不可能的。哈哈哈，也是够倒霉的！</p><p>其实人家真正的架构是这样的:</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210312224101.png" style="zoom:50%;" alt="其实人家真正的架构是这样的"/><p>四种集群方式优缺点都列出来了，很明显为了保证消息一定不会在Broker这个阶段丢失，生产环境一定要使用第四种集群方式：同步复制多Master多Slave模式。具体配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## master 节点配置</span></span><br><span class="line"><span class="string">brokerRole=SYNC_MASTER</span></span><br><span class="line"><span class="string">flushDiskType=SYNC_FLUSH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## slave 节点配置</span></span><br><span class="line"><span class="string">brokerRole=SLAVE</span></span><br><span class="line"><span class="string">flushDiskType=ASYNC_FLUSH</span></span><br></pre></td></tr></table></figure><p>加上前面的同步刷盘的配置，这样生产者发送消息给Broker，Master使用同步刷盘方式将消息保存到硬盘上，保存成功之后使用同步复制的方式将消息复制到Slave上，slave保存成功之后，Broker才返回给生产者ACK。</p><h4 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h4><p>对于并发比较高的系统，如果下游的消费者宕机，则会导致大量的消息堆积在消息队列里，这样很容易会把服务器的硬盘撑爆，新的消息发送到消息队列，硬盘拒绝写入，这时消息很容易就会丢失。所以，部署消息队列的机器硬盘空间要比较充裕，且要有一定的监控，防止这种情况发生。</p><h3 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h3><p>终于到了最后一个阶段，但是大家也不能大意。消费者拉取消息进行本地业务处理，业务处理完成才能提交ACK <code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code>，切不可先提交ACK再进行业务处理。如果业务处理出现异常情况，可以先返回<code>ConsumeConcurrentlyStatus.RECONSUME_LATER</code>等待消息队列的下次重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"unique_group_name"</span>);</span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876;127.0.0.1:9870"</span>);</span><br><span class="line">consumer.setConsumeMessageBatchMaxSize(<span class="number">1</span>);</span><br><span class="line">consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">  MessageExt messageExt = msgs.get(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 进行业务处理</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理失败返回ConsumeConcurrentlyStatus.RECONSUME_LATER</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理成功返回ConsumeConcurrentlyStatus.CONSUME_SUCCESS</span></span><br><span class="line">  <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure><p>还有一点要注意的是，消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下：</p><table><thead><tr><th align="center">第几次重试</th><th align="center">与上次重试的间隔时间</th><th align="center">第几次重试</th><th align="center">与上次重试的间隔时间</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">10 秒</td><td align="center">9</td><td align="center">7 分钟</td></tr><tr><td align="center">2</td><td align="center">30 秒</td><td align="center">10</td><td align="center">8 分钟</td></tr><tr><td align="center">3</td><td align="center">1 分钟</td><td align="center">11</td><td align="center">9 分钟</td></tr><tr><td align="center">4</td><td align="center">2 分钟</td><td align="center">12</td><td align="center">10 分钟</td></tr><tr><td align="center">5</td><td align="center">3 分钟</td><td align="center">13</td><td align="center">20 分钟</td></tr><tr><td align="center">6</td><td align="center">4 分钟</td><td align="center">14</td><td align="center">30 分钟</td></tr><tr><td align="center">7</td><td align="center">5 分钟</td><td align="center">15</td><td align="center">1 小时</td></tr><tr><td align="center">8</td><td align="center">6 分钟</td><td align="center">16</td><td align="center">2 小时</td></tr></tbody></table><p>如果消息重试 16 次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。死信队列里的消息有效期与正常消息相同，均为3天。3天后会被自动删除。针对这种情况，为了不丢失消息我们需要处理死信队列里的消息。</p><p>有消息进入死信队列，意味着某些问题导致消费者无法正常消费消息，因此，通常需要人工介入对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息让消费者重新消费一次，或者直接让专门的消费者订阅死信队列进行消费。</p><blockquote><p>死信队列名称一般是  %DLQ% + ConsumerGroupName组成，还有个重试队列名称一般是 %RETRY% + ConsumerGroupName组成，这些都是RocketMQ自动创建的。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个消息从新生到终结经历了生产、存储、消费三个阶段，针对不同的阶段可能会出现丢失消息的地方，我们给出不同的解决方案。最终，RocketMQ丢失消息的概率被大大的降低了。我们将视角拔高一点，你就会发现，解决不同的消息队列不丢失消息，只有消息队列的配置稍有不同，其他地方都是类似的。好像我们已经形成了解决消息不丢失的方法论了，再遇到其他的消息队列我们就不慌了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;随着业务的发展，系统功能也越来也复杂。渐渐的我们会遇到这样的问题。例如，系统和多个外部系统交互对接耗时耗力、系统某个模块流程处理时间过长业务越来越接受不了、某个模块在某个时间点流量太大系统时刻有宕机的风险等等。对于这些问题要想解决，系统此时引入消息队列或许是一个不错的选择。我们都知道消息队列有三大技能：解耦、异步、削峰。看起来可以完美的解决上面提到的问题，但是你们的系统真的适合消息队列么？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="RocketMQ" scheme="https://ydstudios.gitee.io/tags/RocketMQ/"/>
    
      <category term="消息队列" scheme="https://ydstudios.gitee.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁实现方案到底有哪些</title>
    <link href="https://ydstudios.gitee.io/post/3c363844.html"/>
    <id>https://ydstudios.gitee.io/post/3c363844.html</id>
    <published>2021-02-28T10:19:27.000Z</published>
    <updated>2021-08-26T08:47:26.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面几篇文章从系统架构方式的演进，谈到了单体架构、分布式架构的优缺点，其中特意说到了分布式架构由于功能的拆分，导致系统出现了不能保证数据一致性的问题，即分布式事务问题，从而引出了几种分布式事务的解决方案。文章的篇幅大都在说分布式事务，其实分布式系统中还有一个重要角色–<strong>分布式锁</strong>，一直没有提及。今天这篇文章我们就将目光移到分布式锁的身上，来说说分布式锁的那些事吧！</p><a id="more"></a><h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>说分布式锁之前，我们先说一说什么是锁、锁有什么作用？一般来说当代码中会有多个线程任务访问同一共享资源时,就会出现冲突或者错误，目前解决这种问题都是采用序列化访问共享资源的解决方案,即将共享资源放在某一代码块中并加锁,某一时刻只能有一个线程访问该代码块。从而我们可以得出结论，锁是一种方案，一种解决多线程访问共享资源不出问题的解决方案。</p><h3 id="为什么需要分布式锁-distributed-lock"><a href="#为什么需要分布式锁-distributed-lock" class="headerlink" title="为什么需要分布式锁(distributed lock)"></a>为什么需要分布式锁(distributed lock)</h3><p>Java中提供了很多种类丰富的锁，每种锁因其特性的不同，可以在适当的场景下展现出非常高的效率，具体有哪些锁此处暂时也按下不表。Java中提供的锁，例如<code>synchronized</code>、<code>ReentrantLock</code>之类的锁，只能在单机JVM中使用，可以称之为<strong>单机锁</strong>。可在分布式系统环境下，一个功能可能会涉及到多个服务，不同的服务又部署在不同的服务器不同的JVM中，这样Java提供的单机锁就无能为力了。他们不能使用，可我们仍然需要有一个类似<code>synchronized</code>类的锁，能够获得到锁之后能够正确的访问共享资源。对比单机模式，能够在分布式环境下提供这种能力的锁我们称之为<strong>分布式锁</strong>。</p><blockquote><p>锁的种类很丰富，例如乐观锁、悲观锁；公平锁、非公平锁；可重入锁、不可重入锁；共享锁、排他锁；本文只考虑分布式情况下的<strong>排他锁</strong>。</p></blockquote><p>分布式系统专家Martin在他的文章中写了他对分布式锁的理解，以下便是节选（原文为英文此处翻译成了中文）<a href="#refer-anchor"><sup>1</sup></a>：</p><p>锁的目的是确保在可能尝试执行同一工作的多个节点中，只有一个节点实际执行了该工作（一次至少只有一个节点）。这项工作可能是将一些数据写入共享存储系统，执行一些计算，调用一些外部API，等等。在较高的层次上，您可能希望在分布式应用程序中使用锁的原因有两个：一是为了效率，二是为了正确性。为了区分这些情况，您可以询问如果锁定失败会发生什么：</p><ul><li><p>效率：使用锁可以避免不必要地重复两次相同的工作（例如，一些昂贵的计算）。如果锁定失败，并且两个节点最终执行相同的工作，结果是成本略有增加（您最终向AWS支付的费用比其他情况下多5美分）或带来轻微不便（例如，用户最终两次收到相同的电子邮件通知）。</p></li><li><p>正确性：使用锁可以防止并发进程互相攻击，从而破坏系统的状态。如果锁定失败，并且两个节点同时处理同一数据段，则会导致文件损坏、数据丢失、永久性不一致或其他严重问题。</p></li></ul><h3 id="分布式锁有什么要求"><a href="#分布式锁有什么要求" class="headerlink" title="分布式锁有什么要求"></a>分布式锁有什么要求</h3><p>前面我们说到了分布式锁的使用场景，从中我们可以得出一些分布式锁的核心诉求，我总结大概有以下三点：</p><ol><li><p>互斥性<br>在同一时间，锁只能被一个客户端的一个线程获得。</p></li><li><p>安全性<br>只有获得锁的线程才能释放锁，并且要有超时机制，客户端崩溃之后要能自动释放锁，不能出现死锁。</p></li><li><p>可用性<br>高性能的获得锁和释放锁，且不能有单点故障。</p></li></ol><h3 id="分布式锁的简单实现"><a href="#分布式锁的简单实现" class="headerlink" title="分布式锁的简单实现"></a>分布式锁的简单实现</h3><p>根据锁资源本身的安全性，我们可以将分布式锁分为两大类：</p><ul><li><p>基于异步复制的中间件，如MySQL、Redis等等</p></li><li><p>基于paxos协议的分布式一致性的中间件，如zookeeper、etcd等等</p></li></ul><h4 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h4><p>首先说下结论，<strong>不建议使用基于数据库实现分布式锁</strong>。</p><h5 id="数据库如何实现分布式锁"><a href="#数据库如何实现分布式锁" class="headerlink" title="数据库如何实现分布式锁"></a>数据库如何实现分布式锁</h5><p>使用MySQL的唯一索引加上行锁机制,由线程名threadName、类名className、方法名methodName三个字段创建唯一索引。</p><p>在要获得锁的时候向DB中写一条记录，这条记录主要包含主键、当前占用锁的线程唯一 threadId、类名className、方法名methodName、锁的有效截止时间deadline和创建时间createTime等，并且以类名和方法名创建唯一索引，唯一threadId作为解锁的凭证，防止误解锁。如果插入成功表示当前线程获取到了锁，如果插入失败那么证明锁被其他客户端的线程获取。释放分布式锁的时候，客户端比对threadId直接删除对应的记录即可。如果客户端崩溃了，不能自行删除对应的记录，则需要一个定时任务补偿，查询当前时间已经大于锁的有效截止时间deadline的记录，删除即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `distributed_lock` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `class_name` varchar(64) NOT NULL COMMENT '类名',</span><br><span class="line">  `method_name` varchar(64) NOT NULL COMMENT '方法名',</span><br><span class="line">  `thread_id` varchar(64) NOT NULL COMMENT '获得锁的线程唯一ID',</span><br><span class="line">  `deadline` datetime NOT NULL COMMENT '锁有效期截止时间',</span><br><span class="line">  `create_time` datetime NOT NULL COMMENT '创建时间',</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_lock_index` (`class_name`,`method_name`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><p>我们将MySQL实现的分布式锁进行步骤拆解，具体如下：</p><h6 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h6><p>客户端在表<code>distributed_lock</code> 插入记录，返回影响行数值为1，则代表该客户端获得了锁，反之没有获得锁。</p><h6 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h6><p>客户端在执行完自己的业务代码之后，删除<code>distributed_lock</code>表中自己插入的数据，注意删除的时候要比对 thread_id ，这样才能避免客户端端误解锁。</p><h6 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h6><p>客户端如果发生异常，导致没有释放自己持有的锁时，我们此时需要引入一个定时任务进行补偿。即查询当前时间已经大于锁的有效截止时间deadline的记录进行删除。</p><h5 id="数据库实现分布式锁优缺点"><a href="#数据库实现分布式锁优缺点" class="headerlink" title="数据库实现分布式锁优缺点"></a>数据库实现分布式锁优缺点</h5><ul><li>优点</li></ul><ol><li>使用MySQL实现简单，不用引入额外的中间件。MySQL的唯一索引加上行锁机制，可以保证在同一时刻只会有一个客户端的一个线程获得锁。</li></ol><ul><li>缺点</li></ul><ol><li><p>MySQL存在单点故障，并发量大的时候吞吐量急剧下降。如果要实现高可用的话，则需要搭建MySQL集群，如果采用异步复制的方式同步数据到slave，存在数据延迟或者数据丢失的风险，这样就会出现客户端已经在master数据库上获得到了锁，但数据未同步到slave时master宕机，集群高可用重新选举出新的master之后，客户端又可以获得同一把锁，这样的情况就不满足分布式锁的互斥性要求了。但是，如果MySQL集群采用半同步复制或者全同步复制到slave，则锁的性能、吞吐量又降低了很多。</p></li><li><p>锁失效机制实现的不够优雅，而且补偿任务删除数据会存在一定时间的延迟，延迟这段时间锁不可用。</p></li></ol><h4 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h4><p>Redis是开发中常用的中间件，后端的开发也基本上都使用过。Redis基本上都是内存操作，性能好、速度快。接下来我们来用Redis实现一个简版分布式锁。</p><h5 id="Redis如何实现分布式锁"><a href="#Redis如何实现分布式锁" class="headerlink" title="Redis如何实现分布式锁"></a>Redis如何实现分布式锁</h5><p>我们用Redis的set命令实现加锁，用lua脚本来释放锁，用key的过期机制来保障分布式锁不会死锁。</p><blockquote><p>可能有些头铁的老哥直接使用set加锁；使用expire命令设置key的有效期；使用del命令释放锁。别不相信，我还看过相关的文章，文章作者对不正确使用Redis实现分布式锁，导致出现商品出现超卖进行复盘。</p></blockquote><p>我们将Redis实现的分布式锁进行步骤拆解，具体如下：</p><h6 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h6><ol><li>实现加锁方式一</li></ol><p>单独使用set和expire命令来实现因为命令之间不是原子的关系，导致锁失效。所以我们首先想到用lua脚本来执行这两个命令，让他满足原子性，从而成功实现功能。具体的lua脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then</span><br><span class="line">    return redis.call('expire',KEYS[1],ARGV[2])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>KEYS[1] 代表 键名，ARGV[1] 代表键名对应的value，ARGV[2] 代表锁的时间</p></blockquote><ol start="2"><li>实现加锁方式二</li></ol><p>从 Redis 2.6.12 版本开始，Redis对set命令进行了一系列的升级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><p> SET 命令的行为可以通过一系列参数来修改：</p><ul><li><p>EX seconds：将键的过期时间设置为 seconds 秒。执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。</p></li><li><p>PX milliseconds：将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。</p></li><li><p>NX：只在键不存在时，才对键进行设置操作。执行 SET key value NX 的效果等同于执行 SETNX key value 。</p></li><li><p>XX：只在键已经存在时，才对键进行设置操作。</p></li></ul><p>对于返回值的升级，从 Redis 2.6.12 版本开始， SET 命令只在设置操作成功完成时才返回 OK；如果命令使用了 NX 或者 XX 选项；但是因为条件没达到而造成设置操作未执行；那么命令将返回空(nil)。</p><p>我们来验证一下，执行两次以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set bizLock randomValue EX 20  NX</span><br></pre></td></tr></table></figure><p>randomValue是由客户端生成的一个随机字符串（可以使用UUID生成），相当于是客户端持有锁的标志。<br>NX 表示只有当 bizLock 对应的key值不存在的时候才能SET成功，相当于只有第一个请求的客户端才能获得锁。<br>EX 20 表示这个锁有效期20秒。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210228154747.png" alt="验证set命令" style="zoom:50%;" /><p>确实如Redis的文档所说，SET 命令只在设置操作成功完成时才返回 OK；如果命令使用了 NX 或者 XX 选项；但是因为条件没达到而造成设置操作未执行；那么命令将返回空(nil)。这样一个命令就可以保证分布式锁的互斥性和安全性两个要求。</p><h6 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h6><p>前面说了有人直接使用<code>del</code>命令删除对应的key来实现解锁，这个是有问题的，很有可能误解锁。下面是一个Redis分布式锁服务的流程图：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210228145255.png" alt="分布式锁服务流程图" style="zoom: 50%;" />由于客户端A在成功获得分布式锁之后，自身发生GC导致出现STW(stop the world)现象或者是发生了网络问题，客户端的业务操作还没有完成，分布式锁的有效期已经到了，锁已经被释放，可是这个情况客户端A并不知晓。然后客户端B向分布式锁服务请求锁，获得锁成功之后，处理自己的业务逻辑。客户端B业务处理完成释放分布式锁，客户端A从GC停顿或者网络问题中恢复过来，继续自己的业务处理。这个过程存在两个问题：<ol><li><p>假设客户端A在步骤5和6中间恢复过来，处理完业务使用<code>del</code>命令释放分布式锁，很明显他释放的是客户端B的锁，这个不符合分布式锁的安全性要求。</p></li><li><p>假设客户端A按照图中的流程一样，这样就意味着在同一时刻分布式系统中有两把一样的锁，导致业务处理重复出现错误数据。</p></li></ol><p>问题1，那是因为判断是否拥有锁和解锁是两个步骤，不具有原子性。对于这个问题，我们可以使用lua脚本来解锁。Redis 2.6 版本通过内嵌支持 Lua 环境，会单线程原子性执行 Lua 脚本，保证 Lua 脚本在处理的过程中不会被任意其它请求打断。</p><p>lua解锁脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call("get",KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call("del",KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>问题2，客户端发生GC导致停顿过久获得的分布式锁失效，且造成系统中同一时间拥有两把分布式锁。对于这种问题，<strong>建议在最终提交业务逻辑之前，再检查一下自身是否还拥有锁，拥有的话提交不拥有的业务回滚</strong>。当然，这种方案只是尽可能的减少出错的可能性，并不能完全避免问题发生。（因为在你判断的那一刻可能锁还是你持有，但是判断结束这个锁就已经失效，被其他的线程获取，当然这种情况很极端，但是也不能说没有可能）<br>另外就是建议，<strong>保证业务处理接口的幂等性</strong>。例如在数据库层面添加唯一索引，使用数据库进行兜底。</p><h5 id="Redis实现分布式锁优缺点"><a href="#Redis实现分布式锁优缺点" class="headerlink" title="Redis实现分布式锁优缺点"></a>Redis实现分布式锁优缺点</h5><ul><li>优点</li></ul><ol><li>代码实现起来简单，加锁解锁效率高。</li><li>客户端崩溃或者网络延迟，Redis的key过期策略和内存淘汰机制保证锁一定会被释放，保证不会阻塞所有流程。</li><li>Redis的优异的性能，全内存操作，可以支持很高的并发。</li></ol><ul><li>缺点</li></ul><ol><li><p>异步复制的缺点导致不满足互斥性的要求。使用Redis实现分布式锁自然是不能使用单个Redis，这样必然有单点故障，起码要使用集群的Redis，例如主从架构的Redis集群。Redis是使用异步复制的方式同步数据到slave，存在数据延迟或者数据丢失的风险，这样就会出现客户端已经在master上获得到了锁，但数据未同步到slave时master宕机，集群高可用重新选举出新的master之后，客户端又可以获得同一把锁，打破分布式锁的互斥性要求。</p></li><li><p>Redis服务器时钟漂移问题。简单的说，就是Redis服务器上的时间比正常的时钟快，导致锁提前过期释放。但客户端仍然认为自己持有锁，打破分布式锁的互斥性要求。</p></li></ol><h5 id="RedLock算法实现分布式锁"><a href="#RedLock算法实现分布式锁" class="headerlink" title="RedLock算法实现分布式锁"></a>RedLock算法实现分布式锁</h5><p>假设我们有N个master节点，官方文档里将N设置成5，其实大等于3就行。加锁大概流程如下：</p><ol><li>获取当前服务器时间。</li><li>轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</li><li>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li><li>如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li><li>如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</li></ol><p>这个地方说说关于集群相关知识点，节点发生宕机，剩余多少节点集群仍然可以正确使用？<br>计算公式： 当前剩余节点数量 &gt; n/2</p><blockquote><p>注意公式里大于 &gt; 号，不带等于 = 号，这个主要是为了最大程度上防止选举投票时出现票数相同导致投票失败，从而提高投票效率。</p></blockquote><p>问题1: 多少个节点可以搭建成集群</p><ol><li><p>1个节点能否搭建集群 1-1 ?&gt;0.5 (1是最少宕机1个节点,条件不成立),1个节点不能搭建集群</p></li><li><p>2个节点能否搭建集群 2-1 ?&gt;1 (条件不成立),2个节点不能搭建集群</p></li><li><p>3个节点能否搭建集群 3-1 ?&gt;1.5 (条件成立),3个节点是搭建集群的最小单位</p></li><li><p>4个节点能否搭建集群 4-1 ?&gt;2 (条件成立),4个节点能搭建集群</p></li></ol><p>问题2: 为什么集群节点都是奇数,而不是偶数?</p><ol><li><p>3个节点允许宕机的最大的数量是几个节点? 3-2 &gt;1.5条件不成立，3-1 &gt;1.5条件成立，因此3个节点最多允许宕机1个节点.</p></li><li><p>4个节点允许宕机的最大的数量是几个节点? 4-2 &gt;2条件不成立，4-1 &gt;2条件成立，因此4个节点最多允许宕机1个节点。</p></li></ol><p>结论: 5个节点与6个节点搭建的集群最大都是容忍2个节点宕机,所以从成本的角度考虑,5个节点更节省资源。</p><h4 id="Zookeeper实现分布式锁"><a href="#Zookeeper实现分布式锁" class="headerlink" title="Zookeeper实现分布式锁"></a>Zookeeper实现分布式锁</h4><p>ZooKeeper是开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现。基于它可以实现诸如数据发布/订阅、命名服务、分布式协调/通知、分布式锁等功能。下面我们先来介绍一下zookeeper相关的知识点。</p><p>我们都知道Zookeeper有4类节点类型，分别是：</p><ul><li><p>持久化目录节点（PERSISTENT ）</p><p>客户端与zookeeper断开连接之后，zookeeper中该节点仍然存在。</p><p>创建节点语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /path data</span><br></pre></td></tr></table></figure><p>示例：创建一个test节点，数据是123</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /test 123</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）</p><p>Zookeeper给该节点名称进行顺序编号，客户端与zookeeper断开连接后，该节点依旧存在。</p><p>创建持久化顺序编号目录节点语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /path data</span><br></pre></td></tr></table></figure><p>示例：创建一个顺序编号目录test节点，数据是123</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 35] create -s /test 123</span><br><span class="line">Created /test0000000006</span><br><span class="line">[zk: localhost:2181(CONNECTED) 36]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>临时目录节点（EPHEMERAL ）</p><p>客户端与zookeeper断开连接之后，该节点则被删除。</p><p>创建临时目录节点目录节点语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /path data</span><br></pre></td></tr></table></figure><p>示例：创建一个临时目录test节点，数据是123</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 36] create -e /test 123</span><br><span class="line">Created /test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 37]</span><br></pre></td></tr></table></figure></li><li><p>临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL ）</p><p>Zookeeper给该节点名称进行顺序编号，客户端与zookeeper断开连接后，该节点则被删除。</p><p>创建临时顺序编号目录节点语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e -s /path data</span><br></pre></td></tr></table></figure><p>示例：创建一个临时顺序编号目录test节点，数据是123</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 38] create -s -e /test 123</span><br><span class="line">Created /test0000000008</span><br><span class="line">[zk: localhost:2181(CONNECTED) 39]</span><br></pre></td></tr></table></figure></li></ul><p>最终创建的节点数据如下图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 43] ls -R /</span><br><span class="line">/</span><br><span class="line">/test</span><br><span class="line">/test0000000006</span><br><span class="line">/test0000000008</span><br><span class="line">/zookeeper</span><br><span class="line">/zookeeper/config</span><br><span class="line">/zookeeper/quota</span><br><span class="line">[zk: localhost:2181(CONNECTED) 44]</span><br></pre></td></tr></table></figure><p>前面说到临时目录节点当客户端断开之后就会被删除，那么试着将客户端重启，剩余的数据如下图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls -R /</span><br><span class="line">/</span><br><span class="line">/test0000000006</span><br><span class="line">/zookeeper</span><br><span class="line">/zookeeper/config</span><br><span class="line">/zookeeper/quota</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5]</span><br></pre></td></tr></table></figure><p>果然，除了zookeeper自己的、持久化的节点之外，临时目录节点都已经被删除了。</p><blockquote><p>其实zookeeper版本更新之后，又增加了3种类型的节点，但这里没有介绍。</p></blockquote><p>这里在提一下Zookeeper的Watcher（事件监听器），他是ZooKeeper中的一个很重要的特性。ZooKeeper允许用户在指定节点上注册Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知客户端。这个特性在Zookeeper实现分布式锁的时候，可以用它实现高级一点的功能。这里用一张图来展示一下他的用途：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210825154241.png" alt="zookeeper的watcher" style="zoom:67%;" /><p>创建watcher的命令：<code>get /path watch</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> localhost:2181(CONNECTED) 2] get /test0000000006 watch</span><br><span class="line">'get path [watch]' has been deprecated. Please use 'get [-s] [-w] path' instead.</span><br><span class="line">213213131</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3]</span><br></pre></td></tr></table></figure><p>如果出现上述的提示，说明你的zookeeper版本比较新，上述的命令已经被废弃，替代的命令是 <code>get [-s] [-w] /path</code>,开启两个终端，一个终端创建watcher，一个终端修改对应节点内数据，就会触发watcher。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] get -w /test0000000006</span><br><span class="line">213213131</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4]</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/test0000000006</span><br></pre></td></tr></table></figure><p><strong>那这几种节点还有watcher和实现分布式锁有什么关系呢？那就请接着往下看吧！</strong></p><h5 id="Zookeeper如何实现分布式锁"><a href="#Zookeeper如何实现分布式锁" class="headerlink" title="Zookeeper如何实现分布式锁"></a>Zookeeper如何实现分布式锁</h5><p>说了这么多到底如何用Zookeeper实现分布式锁呢？因为Zookeeper节点名称都是唯一的，我们可以这个特性加上临时目录节点就可以实现了。</p><h5 id="简版"><a href="#简版" class="headerlink" title="简版"></a>简版</h5><p>假设名为lock的节点，节点中存放获得锁的客户端的信息，这样的节点存在就代表某个客户端获得了锁，反之就是没有获得锁。这个简版分布式锁的原理是不是感觉和Redis实现原理一样，其实就是一样的！</p><ul><li>代表锁的节点存在就说明已有客户端获得锁。</li><li>客户端断开连接，节点自动删除，即客户端释放锁，不依赖于过期时间。</li></ul><blockquote><p>在此申明一下Zookeeper实现分布式锁，也是需要搭建集群的，不能用单机，单机就会有单点故障，就不满足分布式锁高可用的要求了。</p></blockquote><h5 id="豪华版"><a href="#豪华版" class="headerlink" title="豪华版"></a>豪华版</h5><p>前面实现的锁其实功能都比较简陋，如果一个客户端没有获取到锁，就直接没有他啥事情了，假设资源比较紧张，客户端阻塞在那，过一段时间来试一下能不能获得锁，这种轮训是比较耗费资源的，最好是虽然没有获取到锁，但是一旦锁空闲了，能来通知一下客户端“现在锁空出来了，你赶紧过来拿呀”。要实现这种效果就可以用上面提到的Watcher（事件监听器）了。想获得锁的客户端都来创建lock节点，如果创建失败就认为没有获得锁，然后去监听lock节点，貌似完美的实现了通知的功能。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210825162524.png" alt="都来抢夺锁" style="zoom:67%;" /><blockquote><p>Redis 有一个键过期事件通知，也能实现类似的效果，但是他属于<strong>fire and forget</strong>，不保证可靠性的，所以可以忽略。之前见有人用这玩意延期相关的实现，这个方案可不行。</p></blockquote><p>但是如果这个节点有太多的客户端监听，就会有些问题。一个客户端的释放锁，删除节点，所有watch这个lock节点的客户端都来尝试一下自己能否创建节点，这岂不是要命了！这其中占用的内存和网络带宽，不知道服务器能不能顶得住！</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210825163225.jpeg" alt="能不能顶得住"></p><p>这个现象称之为“羊群效应”或者是“惊群效应”。那这种问题该如何解决呢？</p><p>要解决这种问题，我们就不能使用临时目录节点了，要使用临时顺序编号目录节点，且客户端不能监听一个节点，而是每个客户端创建的节点监听他之前的节点。假设锁空间是/lock，那么调整之后的分布式锁工作流程如下：</p><ol><li>客户端在/lock 下创建临时顺序编号目录节点，第一个客户端创建的节点是/lock/lock0000000000，则第二个节点就是/lock/lock0000000001，其他的以此类推。</li><li>某个客户端获取/lock下的子节点列表，判断自己创建的节点是否为/lock的子节点列表中顺序编号最小的子节点，如果是最小的子节点，则认为成功获得锁；反之监听自己前面那个子节点的删除事件。后期监听到事件，重复此步骤直至获得到锁。</li><li>客户端执行自己的业务代码。</li><li>客户端执行完业务代码，删除自己创建的子节点。</li></ol><p>我们将Zookeeper实现的分布式锁进行步骤拆解，具体如下：</p><h5 id="加锁-2"><a href="#加锁-2" class="headerlink" title="加锁"></a>加锁</h5><p>客户端在锁空间/lock下创建临时顺序编号目录节点，子节点创建成功，遍历锁空间/lock下所有的子节点，若自己是最小的节点，则认为客户端获得了锁，反之认为没有获得锁，并监听自己前面那个子节点的删除事件。</p><h5 id="解锁-2"><a href="#解锁-2" class="headerlink" title="解锁"></a>解锁</h5><p>客户端执行完自己的业务代码，直接删除客户端自己创建的节点即可。</p><h5 id="锁超时-1"><a href="#锁超时-1" class="headerlink" title="锁超时"></a>锁超时</h5><p>客户端如果发生异常，Zookeeper通过心跳机制认为客户端已经断开连接，会自动删除创建临时顺序编号目录节点。</p><h5 id="Zookeeper实现分布式锁优缺点"><a href="#Zookeeper实现分布式锁优缺点" class="headerlink" title="Zookeeper实现分布式锁优缺点"></a>Zookeeper实现分布式锁优缺点</h5><p>我们都知道 Zookeeper 是典型的CP系统，他是基于Zab协议实现的，不会有采用异步主从复制<br>出现数据不一致的问题，可靠性非常之高。</p><ul><li>优点</li></ul><ol><li>没有时钟跳跃的问题。解锁不依赖机器时钟，客户端断连，锁自动被释放。</li><li>实现简单。有良好的客户端Curator来实现。</li><li>可靠性强。Zookeeper 是典型的CP系统。</li></ol><ul><li>缺点</li></ul><ol><li><p>性能不够好。较多的客户端的申请、释放锁，zk集群的压力会比较大。</p></li><li><p>要维护一个Zookeeper集群，增大了运维难度。</p></li><li><p>网络故障或者GC停顿导致临时节点提前被删除。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210826164521.png" alt="image-20210826164521458" style="zoom:50%;" /><p>如果这个图不够形象，也可以看看前面Redis分布式锁服务的流程图，可能会更加形象。</p></li></ol><h4 id="如何抉择"><a href="#如何抉择" class="headerlink" title="如何抉择"></a>如何抉择</h4><p>本文重点关注的是分布式锁各种实现方案的基础理论，而且是最简单的实现理论，尤其是RedLock也只是说了他的简单加锁流程，都没有给出具体的代码，有兴趣的同学可以自己去实现一下。对于各种方案的分布式锁如何去抉择，这个要看我们系统状况和业务的要求。一般情况下的系统，都会使用到Redis，所以推荐优先使用Redis实现的分布式锁，或者直接使用Redisson，他提供了多种锁的实现，可以让你像使用JVM中的<code>synchronized</code>、<code>ReentrantLock</code>那样简单;如果系统中有用到zookeeper，那在一些重要的业务场景可以考虑使用zookeeper，毕竟它比Redis更可靠。当然有些时候，加锁也许不是最好的选择，有时换个思路，分而治之可能会有不一样的效果。</p><p>[1] <a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">分布式系统专家Martin的《How to do distributed locking》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前面几篇文章从系统架构方式的演进，谈到了单体架构、分布式架构的优缺点，其中特意说到了分布式架构由于功能的拆分，导致系统出现了不能保证数据一致性的问题，即分布式事务问题，从而引出了几种分布式事务的解决方案。文章的篇幅大都在说分布式事务，其实分布式系统中还有一个重要角色–&lt;strong&gt;分布式锁&lt;/strong&gt;，一直没有提及。今天这篇文章我们就将目光移到分布式锁的身上，来说说分布式锁的那些事吧！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="zookeeper" scheme="https://ydstudios.gitee.io/tags/zookeeper/"/>
    
      <category term="redis" scheme="https://ydstudios.gitee.io/tags/redis/"/>
    
      <category term="锁" scheme="https://ydstudios.gitee.io/tags/%E9%94%81/"/>
    
      <category term="分布式" scheme="https://ydstudios.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>孔乙己“茴”字四种写法引起我对策略模式实现的思考</title>
    <link href="https://ydstudios.gitee.io/post/d06ff354.html"/>
    <id>https://ydstudios.gitee.io/post/d06ff354.html</id>
    <published>2021-02-23T20:29:36.000Z</published>
    <updated>2021-02-23T12:59:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于策略模式的文章，其实网上实在是太多了，自己的又没有啥文采，肯定也是写不出来什么花！但是我突然想起了孔乙己，对没错就是那个知道“茴”字有四种写法的孔乙己。当时，语文老师说这个场景是为了表现孔乙己的一种迂腐封建的性格。可是我对孔乙己的“茴”字有四种写法，一直有着不同的看法。我倒是觉得从某种意思上知道四种写法反倒是好事，比如你老板安排你做一件事情，你有四种不同的方案可以解决，这难道不是一件好事情嘛！于是，我还是觉得这篇文章还是有写的必要，让大家看看“茴”字有不同的写法。</p><a id="more"></a><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210223205336.png" alt="茴字四种写法"></p><p>假设目前有个抽奖的业务场景，奖品共有现金、优惠券、积分和谢谢参与四类，后续很大可能增加新的奖品类型如赠送抽奖次数。用户抽中则实时发送给用户。一般的小伙伴如何实现这个奖品发放的逻辑，我来写一下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Byte rewardType, String reward)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (rewardType.equals(<span class="string">"积分"</span>)) &#123;</span><br><span class="line">           log.info(<span class="string">"发送积分奖励[&#123;&#125;]"</span>, reward);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rewardType.equals(<span class="string">"优惠券"</span>)) &#123;</span><br><span class="line">           log.info(<span class="string">"发送优惠券奖励[&#123;&#125;]"</span>, reward);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rewardType.equals(<span class="string">"现金"</span>)) &#123;</span><br><span class="line">           log.info(<span class="string">"发送现金奖励[&#123;&#125;]"</span>, reward);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rewardType.equals(<span class="string">"谢谢参与"</span>)) &#123;</span><br><span class="line">           log.info(<span class="string">"对不起，谢谢参与[&#123;&#125;]"</span>, reward);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>大家看一看这种代码，是不是感觉似曾相似，心里是不是在想“这不就是我写的么”！写过这种代码也没有什么不好意思的，毕竟大部分人都是普通人不是那种一个顶十个的大牛，笔者之前也是经常写这种代码，毕竟那个时候也不了解什么是好代码、如何写出好代码，此处必须提大牛Martin Fowler(马丁.福勒)，他的著作《重构》大家可以看看。在此，我想强调的是过去写不出优秀的代码不重要，重要的是现在你要知道什么是优秀的代码和如何写出优秀的代码，不然你多年工作经验的沉淀在哪里呢？</p><blockquote><p>任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。—— Martin Fowler(马丁.福勒)</p></blockquote><h4 id="问题在哪里"><a href="#问题在哪里" class="headerlink" title="问题在哪里"></a>问题在哪里</h4><p>现在我们来说说这段伪代码到底有哪些不好的地方：</p><ol><li>NPE的问题。 在没有对入参进行校验的情况下，直接使用 <code>rewardType.equals(&quot;积分&quot;)</code>进行判断，若rewardType值是null，这个地方就会出现空指针异常。</li><li>硬编码问题。奖励类型的魔法值后期多处拷贝，有可能出现拼写错误，也无法很好展示到底有多少奖励类型。</li><li>过多的if else会导致嵌套过深和逻辑表达式复杂。</li><li>违反开闭原则（OCP）和单一职责原则（SRP）。需求明确提出后续可能会增加“赠送抽奖次数”的奖品类型，按照目前代码的结构要增加发送新型的奖品，则势必需要修改<code>sendReward()</code>代码，增加一个新的分支，这样就修改了原来的代码，就会需要对此处的代码进行回归测试。</li></ol><h4 id="如何改进"><a href="#如何改进" class="headerlink" title="如何改进"></a>如何改进</h4><p>根据上面提到的问题我们给出针对性的优化意见。</p><ol><li><p>调换equals双方的位置 <code>&quot;积分&quot;.equals(rewardType)</code>或者使用<code>java.util.Objects.equals()</code>等等方法替代。</p></li><li><p>定义一个奖励类型枚举。</p></li><li><p>使用卫语句优化判断。</p></li></ol><p>使用上面三个优化意见我们来修改伪代码，最终伪代码呈现如下：</p><p>定义一个奖励类型枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RewardTypeEnum &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 现金奖励</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CASH(<span class="string">"1"</span>,<span class="string">"现金"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 积分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    POINT(<span class="string">"2"</span>,<span class="string">"积分"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠券</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    COUPON(<span class="string">"3"</span>,<span class="string">"优惠券"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 谢谢参与</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    THANK_YOU(<span class="string">"4"</span>,<span class="string">"谢谢参与"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    RewardTypeEnum(String code, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的发送奖励伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(String rewardType, String reward)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (RewardTypeEnum.POINT.getCode().equals(rewardType)) &#123;</span><br><span class="line">           log.info(<span class="string">"发送积分奖励[&#123;&#125;]"</span>, reward);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (RewardTypeEnum.COUPON.getCode().equals(rewardType)) &#123;</span><br><span class="line">           log.info(<span class="string">"发送优惠券奖励[&#123;&#125;]"</span>, reward);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (RewardTypeEnum.CASH.getCode().equals(rewardType)) &#123;</span><br><span class="line">           log.info(<span class="string">"发送现金奖励[&#123;&#125;]"</span>, reward);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (RewardTypeEnum.THANK_YOU.getCode().equals(rewardType)) &#123;</span><br><span class="line">           log.info(<span class="string">"对不起，谢谢参与[&#123;&#125;]"</span>, reward);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对于问题4的解决，我们先需要思考一下。奖励的种类目前有四种，后续很有可能增加奖励种类，不同的奖励发放给用户肯定是涉及了不同的模块，调用不同的发放接口，最终的数据肯定也是写到不同的数据表中，这种情况明显是不同奖励有着不同的发放策略，很明显大家都能想到符合<code>策略模式</code>，本文的主角终于出场了！</p><p>策略模式属于设计模式中行为模式的一种，它主要是将算法封装起来，并且可以相互的替换。在看一些关于设计模式的书时，策略模式首先会定义一个接口，然后具体的策略类去实现策略接口，最后再定义一个<code>Context</code>上下文类来持有一个具体的策略以供调用者使用。这里其实有个问题好多书籍或者博客并没有说明，如何更优雅的让上下文类来持有一个具体的策略，这里我先搭建一下代码的框架，这个问题后面再细说。</p><h4 id="定义策略接口"><a href="#定义策略接口" class="headerlink" title="定义策略接口"></a>定义策略接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RewardSendStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送奖励</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memberId 会员id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送优惠券的策略"><a href="#发送优惠券的策略" class="headerlink" title="发送优惠券的策略"></a>发送优惠券的策略</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponRewardSendStrategy</span> <span class="keyword">implements</span> <span class="title">RewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"给[&#123;&#125;]发送优惠券奖品[&#123;&#125;]"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送积分的策略"><a href="#发送积分的策略" class="headerlink" title="发送积分的策略"></a>发送积分的策略</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointRewardSendStrategy</span> <span class="keyword">implements</span> <span class="title">RewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"给[&#123;&#125;]发送积分奖品[&#123;&#125;]"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="谢谢参与的策略"><a href="#谢谢参与的策略" class="headerlink" title="谢谢参与的策略"></a>谢谢参与的策略</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThankYouRewardSendStrategy</span> <span class="keyword">implements</span> <span class="title">RewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"[&#123;&#125;]，对不起，谢谢参与"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送现金策略"><a href="#发送现金策略" class="headerlink" title="发送现金策略"></a>发送现金策略</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashRewardSendStrategy</span> <span class="keyword">implements</span> <span class="title">RewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"给[&#123;&#125;]发送现金奖品"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义Context上下文类"><a href="#定义Context上下文类" class="headerlink" title="定义Context上下文类"></a>定义Context上下文类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RewardSendStrategyContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Context持有具体策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RewardSendStrategy sendStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendStrategy</span><span class="params">(RewardSendStrategy sendStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendStrategy = sendStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        sendStrategy.sendReward(memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单元测试，试试如何使用"><a href="#单元测试，试试如何使用" class="headerlink" title="单元测试，试试如何使用"></a>单元测试，试试如何使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>, <span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RewardSendStrategyContext context = <span class="keyword">new</span> RewardSendStrategyContext();</span><br><span class="line">        context.setSendStrategy(<span class="keyword">new</span> CouponRewardSendStrategy());</span><br><span class="line">        context.excute(<span class="number">11L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试的执行结果不用怀疑,肯定打印出了 <code>给[11]发送优惠券奖品</code>，但是这种调用方式我感觉并没有解决掉if else多级逻辑判断，为什么这么说，因为这个地方我知道我调用的是发放优惠券的策略，但是在实际业务调用中，我并不知道要发送什么类型奖品，我还是要根据传入的奖品类型去判断使用不同的奖品发送策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String rewardType = RewardTypeEnum.THANK_YOU.getCode();</span><br><span class="line">        RewardSendStrategyContext strategyContext = <span class="keyword">new</span> RewardSendStrategyContext();</span><br><span class="line">        <span class="keyword">if</span> (RewardTypeEnum.POINT.getCode().equals(rewardType)) &#123;</span><br><span class="line">            strategyContext.setSendStrategy(<span class="keyword">new</span> PointRewardSendStrategy());</span><br><span class="line">            strategyContext.excute(<span class="number">11L</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (RewardTypeEnum.COUPON.getCode().equals(rewardType)) &#123;</span><br><span class="line">            strategyContext.setSendStrategy(<span class="keyword">new</span> CouponRewardSendStrategy());</span><br><span class="line">            strategyContext.excute(<span class="number">11L</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (RewardTypeEnum.CASH.getCode().equals(rewardType)) &#123;</span><br><span class="line">            strategyContext.setSendStrategy(<span class="keyword">new</span> CashRewardSendStrategy());</span><br><span class="line">            strategyContext.excute(<span class="number">11L</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (RewardTypeEnum.THANK_YOU.getCode().equals(rewardType)) &#123;</span><br><span class="line">            strategyContext.setSendStrategy(<span class="keyword">new</span> ThankYouRewardSendStrategy());</span><br><span class="line">            strategyContext.excute(<span class="number">11L</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>按照我们前面给的建议进行优化，代码貌似又回到了起点。上面的代码明显还是不符合开闭原则和单一原则，看来我们还是需要进一步的优化。</p><h4 id="使用Spring框架的特性改进"><a href="#使用Spring框架的特性改进" class="headerlink" title="使用Spring框架的特性改进"></a>使用Spring框架的特性改进</h4><p>前面我们已经把发送不同奖品的逻辑分散到了各个单独的类中，这些操作符合单一职责原则。但是没有统一入口，导致在调用策略的地方还是出现了大片的if判断，使得代码还是没有满足开闭原则。所以接下来我们要做的就是干掉这些if判断，提供一个易用的调用接口。</p><p>那怎么样我们才能减少或者直接消除上述代码中存在的 if 判断呢？回想之前的一篇文章<a href="https://juejin.cn/post/6923476874941169671" target="_blank" rel="noopener">船新版本的策略模式，你一定没有见过</a> ，在这个文章中我用注解标识每个策略方法，以注解的值为key，策略方法为value保存在Map中，然后通过Map的 <code>get()</code>获取具体的策略方法，省去了 if 判断。这个其实就是表驱动法，是一种很经典的编程技巧。那在这里就继续用这种方式来解决我们目前遇到的问题。当然此时我们不需要自定义注解，也不需要反射调用，不需要那么大费周章。Spring是一个很优秀的Java框架，一般做Java开发都是基于Spring框架的，Spring框架里有很多特性、技巧能帮助我们写出更优秀的代码。接下来我就展示一下如何使用Spring框架让我们的代码质量更上一个层次。</p><p>在此之前我需要修改一下之前的接口，我们在接口中再定义两个方法，其中一个方法是标识当前类的奖励类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发放奖励的类型,通过这个方法来标示不同的策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 奖励类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String type)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送奖励</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memberId 会员id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这种接口定义，我们在相应的策略类里实现相关方法，这里只给出策略类一个作为示范。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponRewardSendStrategy</span> <span class="keyword">implements</span> <span class="title">RewardSendStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RewardTypeEnum.COUPON.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(type, type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"给[&#123;&#125;]发送优惠券奖品"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，准备工作做的差不多了，接下来来显示Spring框架的威力吧！让它来帮组装我们需要的Map！</p><h5 id="方案一-Autowired注解"><a href="#方案一-Autowired注解" class="headerlink" title="方案一@Autowired注解"></a>方案一<code>@Autowired</code>注解</h5><p>这个注解大家肯定用过很多次了，我们常用它来注入其他的Bean，但是大家可能还有人不知道它有这种技能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;In <span class="keyword">case</span> of a &#123;<span class="meta">@link</span> java.util.Collection&#125; or &#123;<span class="meta">@link</span> java.util.Map&#125;</span><br><span class="line">* dependency type, the container will autowire all beans matching the</span><br><span class="line">* declared value type. In <span class="keyword">case</span> of a Map, the keys must be declared as</span><br><span class="line">* type String and will be resolved to the corresponding bean names.</span><br></pre></td></tr></table></figure><p>这个是@Autowired注解源码上的注释，大致意思我举例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这样定义属性的时候，Spring 会自动的将这个接口的实现类bean全都自动添加到这个 rewardSendStrategyList 中</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RewardSendStrategy&gt; rewardSendStrategyList;</span><br><span class="line"></span><br><span class="line"># 这样定义属性的时候，Spring 会自动的以实现类 beanName 作为 key，bean 作为 value 添加到这个 Map 中</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span>  Map&lt;String, RewardSendStrategy&gt; strategyMap;</span><br></pre></td></tr></table></figure><p>666，就差一点我就要给你打一百分了，借此特性我们可以很容易的实现我们的Map，之前的Context类我们稍加修改,再借助一下Lamda表达式，我们得到了如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RewardSendStrategyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RewardSendStrategy&gt; strategyList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取策略实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RewardSendStrategy <span class="title">getImpl</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategyList.stream()</span><br><span class="line">                .filter(strategy -&gt; strategy.isTypeMatch(type))</span><br><span class="line">                .findAny()</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到策略实现"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样一来我们调用就方便多了，而且很丝滑哦！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>, <span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RewardSendStrategyFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RewardSendStrategy strategy = factory.getImpl(RewardTypeEnum.POINT.getCode());</span><br><span class="line">        strategy.sendReward(<span class="number">11L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着单元测试输出的结果，我感觉终于找到了完美实现策略模式的方案了。哈哈，其实还有好几种，这种方式我觉得是最简便的，也是我最常用的。所以我写在最前面，后面两种让我娓娓道来。</p><h5 id="方案二使用Spring框架的ApplicationContextAware扩展点"><a href="#方案二使用Spring框架的ApplicationContextAware扩展点" class="headerlink" title="方案二使用Spring框架的ApplicationContextAware扩展点"></a>方案二使用Spring框架的ApplicationContextAware扩展点</h5><p>实现<code>org.springframework.context.ApplicationContextAware</code>接口，可以拿到<code>ApplicationContext</code>也就意味着可以拿到Spring容器中的所有Bean，既然拿到了所有的Bean，那我们就可以遍历其中的Bean，将是我们需要的放入到Map中。Context类进行修改，类名我也改成了<code>RewardSendStrategyFactory</code>,具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RewardSendStrategyFactory</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存所有策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, RewardSendStrategy&gt; STRATEGY_MAP = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Map&lt;String, RewardSendStrategy&gt; beans = applicationContext.getBeansOfType(RewardSendStrategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(beans)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        beans.values().forEach(bean -&gt; STRATEGY_MAP.put(bean.type(), bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取策略实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 奖励类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RewardSendStrategy <span class="title">getStrategyInstance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"策略实例[&#123;&#125;]"</span>, STRATEGY_MAP);</span><br><span class="line">        <span class="keyword">return</span> STRATEGY_MAP.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>,<span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String code = RewardTypeEnum.CASH.getCode();</span><br><span class="line">        RewardSendStrategy strategyInstance = RewardSendStrategyFactory2.getStrategyInstance(code);</span><br><span class="line"></span><br><span class="line">        strategyInstance.sendReward(<span class="number">12L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方案三使用Spring框架的InitializingBean扩展点"><a href="#方案三使用Spring框架的InitializingBean扩展点" class="headerlink" title="方案三使用Spring框架的InitializingBean扩展点"></a>方案三使用Spring框架的InitializingBean扩展点</h5><p>具体策略要实现<code>org.springframework.beans.factory.InitializingBean</code>接口。凡是将类交给Spring管理并且实现该接口，Spring在初始化bean的时候会自动执行<code>afterPropertiesSet()</code>方法，此时我们将这个Bean放入一个Map即可。这里我就只展示一个具体策略了，其他都是差不多的，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointRewardSendStrategy</span> <span class="keyword">implements</span> <span class="title">RewardSendStrategy</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RewardTypeEnum.POINT.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(type, type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendReward</span><span class="params">(Long memberId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"给[&#123;&#125;]发送积分奖品"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RewardSendStrategyFactory.registerStrategyInstance(type(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的小伙伴可能发现了一些问题，如果每个具体策略类都实现 <code>InitializingBean</code> 接口，那么重写的<code>afterPropertiesSet()</code>方法明显是重复代码块，当然这个问题也是可以解决的，这里先按下不表！（不然下篇水文我怎么写）</p><p>相应的Context上下文类代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RewardSendStrategyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存策略集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, RewardSendStrategy&gt; STRATEGY_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加策略实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerStrategyInstance</span><span class="params">(String type, RewardSendStrategy strategy)</span> </span>&#123;</span><br><span class="line">        STRATEGY_MAP.put(type, strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取策略实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RewardSendStrategy <span class="title">getStrategyInstance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"策略实例[&#123;&#125;]"</span>, STRATEGY_MAP);</span><br><span class="line">        <span class="keyword">return</span> STRATEGY_MAP.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式如单元测试所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String rewardType = RewardTypeEnum.POINT.getCode();</span><br><span class="line">      RewardSendStrategy strategy = RewardSendStrategyFactory.getStrategyInstance(rewardType);</span><br><span class="line">      strategy.sendReward(<span class="number">12L</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h5><p>方案其实还有很多，例如前文中也说到了基于注解的形式，Spring容器启动的时候扫描指定的注解。这个看自己的想法了，只要符合优质代码的标准，而且能实现功能又没有bug，那都是顶呱呱的方案。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一千个观众眼中有一千个哈姆雷特。每个人对待任何事物都有自己的看法，一千人就有可能有一千种想法。有些事情看上去是件坏事，可换个角度去解读，反而可能会得到一种不一样思想。</p><blockquote><p>善恶本有人相、我相、众生相,即是文化。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于策略模式的文章，其实网上实在是太多了，自己的又没有啥文采，肯定也是写不出来什么花！但是我突然想起了孔乙己，对没错就是那个知道“茴”字有四种写法的孔乙己。当时，语文老师说这个场景是为了表现孔乙己的一种迂腐封建的性格。可是我对孔乙己的“茴”字有四种写法，一直有着不同的看法。我倒是觉得从某种意思上知道四种写法反倒是好事，比如你老板安排你做一件事情，你有四种不同的方案可以解决，这难道不是一件好事情嘛！于是，我还是觉得这篇文章还是有写的必要，让大家看看“茴”字有不同的写法。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://ydstudios.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="思考" scheme="https://ydstudios.gitee.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="策略模式" scheme="https://ydstudios.gitee.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务解决方案到底有哪些</title>
    <link href="https://ydstudios.gitee.io/post/9d74cc19.html"/>
    <id>https://ydstudios.gitee.io/post/9d74cc19.html</id>
    <published>2021-02-16T19:58:33.000Z</published>
    <updated>2021-02-21T14:51:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>在系统是单体架构时，系统是和单个数据库进行交互，所以如果有多表操作的时候，可以使用数据库的事务实现数据的一致性，这种事务可以称之为<strong>本地事务</strong>。随着业务的发展，系统的压力越来越大，单体数据库的性能也达到了瓶颈，不可避免的进行数据库的拆分，还有系统模块的拆分，跨服务、跨数据库的事务场景就越来越多，这样解决分布式的事务的需求就出现了。</p><a id="more"></a><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210216202911.jpg" alt="这道题有谁会"></p><p>有需求就要解决啊！我们程序员就是用来解决问题，实现需求的。之前的文章已经说了，目前已经存在好多种解决分布式事务的方案了，今天我们来说说其中几种比较有代表性的方案。</p><h4 id="两阶段提交协议（2PC）"><a href="#两阶段提交协议（2PC）" class="headerlink" title="两阶段提交协议（2PC）"></a>两阶段提交协议（2PC）</h4><p>两阶段提交协议（2PC，two phase commit protcol),是基于数据库资源层面的。把分布式事务分为两个阶段，一个是准备阶段，另外一个是提交阶段准备阶段和提交阶段都是由事务管理器（也称作协调者）发起，还有一个角色就是参与者。两阶段提交协议的流程如下：</p><ul><li><p>准备阶段：协调者向参与者发起指令，参与者评估自己的资源，如果参与者评估指令能完成，则会写redo、undo日志，然后锁定资源、执行操作但是不提交。</p></li><li><p>提交阶段：如果每个参与者都明确的返回成功，也就是意味着资源锁定、执行操作成功，则协调者向各个参与者发起提交指令，参与者提交操作、释放锁定资源；如果有参与者在上述的两个步骤中有明确返回失败，也就是说资源锁定或者执行操作失败，则协调者向各个参与者发布中止指令，参与者执行undo日志，释放锁定的资源。</p></li></ul><p>在最开始的准备阶段就锁定资源，这是一个重量级的操作，可以保证强一致性。但是实现起来却有很多的缺点：</p><ul><li>阻塞，没有超时机制。如果在整个流程中，任何一个参与者或者协调者由于可能的网络延迟问题，导致协调者的指令不能发出或者参与者接受不到指令，整个流程也不能继续下去，且资源一直被锁定。</li><li>协调者有单点问题。协调者发出指令之后宕机，整个流程无法继续进行。</li><li>会有数据不一致的问题。协调者发出提交指令，部分参与者接受到了指令，执行了所有操作，但是有参与者宕机了，无法执行提交操作。</li></ul><p><strong>两阶段提交协议成功场景的示意图</strong></p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210221221017.png" alt="两阶段提交协议成功场景的示意图" style="zoom:45%;" /><h4 id="三阶段提交协议（3PC）"><a href="#三阶段提交协议（3PC）" class="headerlink" title="三阶段提交协议（3PC）"></a>三阶段提交协议（3PC）</h4><p>针对两阶段提交协议（2PC）的缺点进行改进提出三阶段提交协议（3PC，three phase commit protcol），也是基于数据库资源层面的。增加了一个询问的阶段，增加协调者、参与者超时机制，一旦发生超时则默认提交事务，其他的步骤就和2PC相同。</p><ul><li><p>询问阶段：协调者想参与者询问能否完成指令，参与者只需要回答是和否，无需做其他的操作。</p></li><li><p>准备阶段：协调者向参与者发起指令，参与者评估自己的资源，如果参与者评估指令能完成，则会写redo、undo日志，然后锁定资源、执行操作但是不提交。如果有参与者在询问阶段回答否，则协调者向参与者发送中止请求。</p></li><li><p>提交阶段：如果每个参与者都明确的返回成功，也就是意味着资源锁定、执行操作成功，则协调者向各个参与者发起提交指令，参与者提交操作、释放锁定资源；如果有参与者在上述的两个步骤中有明确返回失败，也就是说资源锁定或者执行操作失败，则协调者向各个参与者发布中止指令，参与者执行undo日志，释放锁定的资源。</p></li></ul><p>三阶段提交协议增加了询问阶段，这样可以确保尽可能早的发现参与者无法进行准备操作，但是不能完全避免这种情况，增加了超时机制可以减少资源的锁定时间。但是仍然会有数据不一致的问题。假设在提交阶段，协调者发出中止命令，由于发生网络分区等问题，部分参与者没有接受到命令则按照超时默认提交事务的规则，导致部分参与者回滚了事务，部分参与者提交了事务，数据一致性被破坏。（其实你就是超时默认中止操作还是会发生数据不一致的情况，真是太难啦😄）</p><p><strong>三阶段提交协议成功场景流程图</strong></p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210221221204.png" alt="三阶段提交协议成功场景流程图" style="zoom:45%;" /><h4 id="TCC（Try-Confirm-Cancel）"><a href="#TCC（Try-Confirm-Cancel）" class="headerlink" title="TCC（Try-Confirm-Cancel）"></a>TCC（Try-Confirm-Cancel）</h4><p>其实大家看了2PC和3PC的执行流程，就可以感觉到他们的实现，会出现资源阻塞、数据不一致的问题，性能效率也不高。在实际项目中也少有使用2PC和3PC实现分布式事务。后来又有大神提出TCC（Try-Confirm-Cancel）协议，协议是基于业务层面实现。这个协议将任务拆分成Try、Confirm、Cancel三个阶段,每个阶段都要保证各自操作幂等。</p><ul><li>Try（预处理阶段）：参与者完成所有业务检查（一致性），预留业务资源(准隔离性)，所有参与者预留都成功，try阶段才算成功。此阶段仅是一个初步操作，它和后续的Confirm 一起才能真正构成一个完整的业务逻辑。</li></ul><blockquote><p>这个预留就是说用户在下订单使用了50积分抵扣金额，我们给积分增加一种冻结的状态，直接把使用的50积分状态置为冻结状态，在订单未完成支付之前用户查看自己的总积分没有减少，但是可用来支付的积分少了50，这样就不会一直占用资源，更新完50积分的状态就是释放了资源。</p></blockquote><ul><li><p>Confirm（确认阶段）：确认执行业务操作，不做任何业务检查，只使用Try阶段预留的业务资源。通常情况下，采用TCC则认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。</p></li><li><p>Cancel（取消阶段）：取消Try阶段预留的业务资源。如果某个业务资源没有预留成功，则取消所有业务资源预留请求。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。 </p></li></ul><p><strong>TCC示意图</strong></p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210221224825.png" alt="TCC示意图" style="zoom:45%;" /><p>2PC(3PC)是追求的数据的强一致性，是一种强一致性事务，而TCC在Confirm、Cancel阶段允许重试，这就意味着数据在一段时间内一致性被破坏，TCC符合BASE理论则可称作一种柔性事务。</p><p>如果拿TCC事务的处理流程与2PC两阶段提交做比较，2PC通常都是在跨库的DB层面实现，而TCC在应用层处理，通过业务逻辑来实现。这种分布式事务的实现方式的优势可以让应用自己定义数据操作的粒度，使得降低资源锁冲突、提高系统吞吐量成为可能。TCC的不足之处则在于对应用的代码侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作，增大了开发的成本。</p><p>目前业界已经有很多开源的TCC协议的分布式事务框架，例如Hmily、ByteTCC、TCC-transaction。使用这些框架就可以很大程度上节约时间，将更多的时间和注意力放到到具体业务中。</p><h4 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h4><p>可靠消息方案通过消息生产、消息存储、消息投递三个阶段的可靠性，实现最终数据一致性，这种方案又有两种实现方式，一种是基于本地消息表实现，另外一种是基于事务消息实现。其实这种本地消息表和消息队列方案不冲突，因为消息队列的消息能够100%投递不丢失也可以用本地消息表实现。</p><h5 id="本地消息表方案"><a href="#本地消息表方案" class="headerlink" title="本地消息表方案"></a>本地消息表方案</h5><p>通过本地消息表实现分布式事务，我觉得是一种<strong>最简单、最简便</strong>的实现方式。它的<strong>核心思想就是讲分布式事务拆分成本地事务进行处理，用数据库的事务ACID特性保证数据一致性</strong>。还有再提一句这种实现思想是eBay里的大牛提出来的，前文说到的BASE理论也是同一家公司的人提出的，不得不赞叹eBay公司里大牛可真是多啊！</p><h6 id="简版本地消息表方案"><a href="#简版本地消息表方案" class="headerlink" title="简版本地消息表方案"></a>简版本地消息表方案</h6><p>在这里我解释我所说的本地消息表方案中，是可以没有消息队列中间件的，这个可能和网上很多的说法不一样。因为考虑实际的情况，两个系统之间交互如果不存在高并发、大流量，以后也不会出现太多的业务耦合，引入消息中间件就会太过了，不仅提升了系统的复杂度，也增加了额外的中间件维护成本，降低了系统的可用性。所以解决这种情况最简单的方式就是使用http通信、异常用定时任务补偿即可。</p><p>这里我先举例说明我上面说的最简单的方式，之前我们的系统要从飞猪上进行会员引流，其中有这样一个需求，如果一个用户是我们系统的会员同时也是飞猪的会员，若这个用户在我们系统的等级发生了改变，则通知飞猪此用户的等级发生变动，然后用户在飞猪APP上查看会员信息的时候，飞猪重新调用一下我们系统的会员信息查询接口。你说对于这种需求用消息队列实现是不是有点大材小用了，最终的开发方案如下：</p><p>业务本地消息表设计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`biz_local_message`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`biz_module`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务模块 1订单  2支付  4等等'</span>,</span><br><span class="line">  <span class="string">`biz_no`</span> <span class="built_in">char</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务单号，唯一标识'</span>,</span><br><span class="line">  <span class="string">`biz_type`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务类型'</span>,</span><br><span class="line">  <span class="string">`msg`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'消息内容'</span>,</span><br><span class="line">  <span class="string">`msg_desc`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'消息描述'</span>,</span><br><span class="line">  <span class="string">`backoff_second`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'180'</span> <span class="keyword">COMMENT</span> <span class="string">'退避秒数，默认3分钟，用来计算next_handle_time时间'</span>,</span><br><span class="line">  <span class="string">`handle_count`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'已经尝试处理次数'</span>,</span><br><span class="line">  <span class="string">`max_handle_count`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'5'</span> <span class="keyword">COMMENT</span> <span class="string">'最大尝试处理次数'</span>,</span><br><span class="line">  <span class="string">`next_handle_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'下一次处理时间'</span>,</span><br><span class="line">  <span class="string">`handle_status`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'记录处理状态 1待处理  2处理中  4处理成功  8处理失败'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`create_user`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'admin'</span> <span class="keyword">COMMENT</span> <span class="string">'创建人'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="string">`update_user`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'admin'</span> <span class="keyword">COMMENT</span> <span class="string">'更新人'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk_bizNoBizMoudleBizType`</span> (<span class="string">`biz_no`</span>,<span class="string">`biz_module`</span>,<span class="string">`biz_type`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_nextHandleTime`</span> (<span class="string">`next_handle_time`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'业务本地消息'</span></span><br></pre></td></tr></table></figure><ul><li>保证biz_local_message表数据跟业务流程在一个事务中，一起成功写入数据库。</li></ul><p>这里的业务模块biz_module就是会员，业务单号biz_no可以用uuid，消息内容就是要推送的消息json保存。开启一个异步线程进行消息推送，推送前将消息的状态handle_status从1待处理设置成2处理中、处理次数 handle_count 值加1、由backoff_second字段和当前时间计算出下次推送时间设置next_handle_time字段，SQL更新记录影响行数affectRow 返回1才继续处理，更新失败则直接return。</p><ul><li>定时任务补偿，处理出现推送异常的消息。定时任务的执行频率可以根据自己的业务需要自行设定,我这里当时设定的是每5分钟执行一次。</li></ul><p>总体上是先进行异常处理，然后再处理异步线程可能没有推送的消息。</p><p>第一步将 <code>where handle_status=2 AND handle_count = max_handle_count AND next_handle_time &lt;= now()</code> 的记录状态handle_status更新为8处理失败 、next_handle_time字段清空，然后进入人工处理流程。</p><p>第二步将 <code>where handle_status=2 AND handle_count &lt;  max_handle_count AND next_handle_time &lt;= now()</code> 则直接把这些记录的 handle_status 状态更新成 1待处理 、next_handle_time字段清空。</p><p>第三步将 <code>where handle_status= 1</code> 的记录分页处理。</p><ol><li><p>处理前将消息的状态从1待处理 更新成 2处理中、处理次数 handle_count 值加1、由backoff_second字段和当前时间计算出下次推送时间设置next_handle_time字段、更新update_time字段，SQL更新记录影响行数affectRow 返回1才继续处理，更新失败则处理下一条记录。</p></li><li><p>前一步更新成功则继续处理；请求返回成功将记录的的状态由2处理中更新成4处理成功、清空 next_handle_time 字段，更新 update_time字段 。如果请求返回失败则更新将满足 <code>handle_status=&#39;2&#39; AND handle_count &lt; max_handle_count</code> 的记录更新 handle_status=1 、update_time字段，记录达到最大处理次数的将记录handle_status更新成 8处理失败，清空 next_handle_time 字段，更新update_time字段，然后进入人工处理流程。</p></li></ol><blockquote><p>在被调用的服务发生异常或者网络问题，短时间内的频繁重试所得到的结果也大致都是失败，这样的重试不仅没有效果，反而还会增服务的负担。所以在计算下一次处理时间next_handle_time除了加上backoff_second退避秒数之后也可以加上随机数，或者更高大上一点使用退避算法来计算。</p></blockquote><p><strong>简版本地消息表方案流程图</strong></p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210219215301.png" alt="简版本地消息表方案流程图" style="zoom:45%;" /><h6 id="实际本地消息表方案"><a href="#实际本地消息表方案" class="headerlink" title="实际本地消息表方案"></a>实际本地消息表方案</h6><p>上面那种是简版的本地消息表方案，但是采用分布式架构的系统由于业务解耦、高并发大流量异步削峰等需要会引入消息队列，则消息就会直接发送到消息队列MQ中，不再通过http请求的方式进行通讯，所以方案的流程就会和上面的不一样，具体流程如下图：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210219215158.png" alt="实际本地消息表方案流程图" style="zoom:45%;" /><p>由于消息队列（我这里以RocketMQ为例，若使用的是其他的消息队列，请按照需要自行修改）的引入，业务本地消息表的设计稍稍改动了一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`biz_local_message`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`biz_module`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务模块 1订单  2支付  4等等'</span>,</span><br><span class="line">  <span class="string">`biz_no`</span> <span class="built_in">char</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务单号，唯一标识'</span>,</span><br><span class="line">  <span class="string">`biz_type`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务类型'</span>,</span><br><span class="line">  <span class="string">`topic_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主题名称'</span>,</span><br><span class="line">  <span class="string">`group_name`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分组名称'</span>,</span><br><span class="line">  <span class="string">`message_tag`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'消息tag'</span>,</span><br><span class="line">  <span class="string">`msg`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'消息内容'</span>,</span><br><span class="line">  <span class="string">`msg_desc`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'消息描述'</span>,</span><br><span class="line">  <span class="string">`backoff_second`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'180'</span> <span class="keyword">COMMENT</span> <span class="string">'退避秒数，默认3分钟，用来计算next_handle_time时间'</span>,</span><br><span class="line">  <span class="string">`handle_count`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'已经尝试处理次数'</span>,</span><br><span class="line">  <span class="string">`max_handle_count`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'5'</span> <span class="keyword">COMMENT</span> <span class="string">'最大尝试处理次数'</span>,</span><br><span class="line">  <span class="string">`next_handle_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'下一次处理时间'</span>,</span><br><span class="line">  <span class="string">`handle_status`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'记录处理状态 1待处理  2处理中  4处理成功  8处理失败'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`create_user`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'admin'</span> <span class="keyword">COMMENT</span> <span class="string">'创建人'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="string">`update_user`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'admin'</span> <span class="keyword">COMMENT</span> <span class="string">'更新人'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk_bizNoBizMoudleBizType`</span> (<span class="string">`biz_no`</span>,<span class="string">`biz_module`</span>,<span class="string">`biz_type`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_nextHandleTime`</span> (<span class="string">`next_handle_time`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'业务本地消息'</span></span><br></pre></td></tr></table></figure><p>如果你的消息内容msg内容比较大使用的是text类型，为了提高数据库的效率，或许你可以将这个消息内容msg字段拿出来单独存一张表；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`biz_local_message_content`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`local_message_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'消息主键'</span>,</span><br><span class="line">  <span class="string">`msg`</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'消息内容'</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'业务本地消息内容表'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>biz_local_message</code>表中处理成功的消息可以直接统一删除，或者挪到一个新的表中备份。</p></blockquote><p>这种和上面的方案相比就是把http通信的方式换成了把消息发送到消息队列中，然后下游系统从消息队列中消费消息，其他的流程差不多。</p><h5 id="基于RocketMQ事务消息方案"><a href="#基于RocketMQ事务消息方案" class="headerlink" title="基于RocketMQ事务消息方案"></a>基于RocketMQ事务消息方案</h5><p>数据库的本地事务无法解决业务逻辑和消息发送的一致性，因为消息发送是一个网络通信过程，发送消息可能出现发送失败或者超时情况。超时的情况也有可能消息已经发送成功了，也有可能发送失败，但消息发送方是无法确定的，所以这时消息发送方是提交事务还是回滚事务，都是会有可能出现数据不一致的地方。</p><p>要解决这个问题，可以采用上面的本地消息表方案，业务逻辑和消息记录在一个事务中一起提交，然后再发送消息。或者采用MQ事务消息（half消息）的办法，事务消息和普通消息的区别在于，事务消息发送到消息队列中后处于prepared状态，是对消费者不可见的，等到事务消息的状态更改为可消费状态后，下游系统的消费者才可以消费到消息。</p><p>事务消息方案的处理流程如下：</p><ol><li><p>事务发起者先发送一个事务消息到MQ中。</p></li><li><p>MQ系统接收到事务消息后，将事务消息持久化，此时事务消息的状态是“已准备”，并给消息发送者返回一个ACK响应。</p></li><li><p>事务消息发送者接收到了步骤2中MQ的ACK响应，则执行本地事务成功则提交事务，失败则回滚本地事务，然后给MQ系统返回一个响应，通知MQ本地事务执行的情况。如果事务消息发送者没有接收到步骤2中ACK响应，则无须或者取消执行本地事务。</p></li><li><p>MQ系统接收到事务消息发送者的反馈消息后，根据反馈的消息更改事务消息的状态。若反馈的消息是本地事务执行成功，则将事务消息的状态从“已准备”修改为“可消费”，并将消息下发给相应的消费者；若反馈的消息是本地事务执行失败，则直接删除该条事务消息。</p></li><li><p>步骤4中的反馈消息，有可能在发送给MQ的过程中丢失。所以MQ系统有定时任务进行补偿，扫描系统中那些状态仍然为“已准备”的事务消息，并向事务消息发送者询问消息的实际状态，并根据反馈的情况更新事务消息的状态。因此，事务消息发送者要实现一个查询事务消息状态的接口，以供MQ系统使用。</p></li><li><p>下游服务接收到MQ系统推送的消息之后，进行消费执行本地事务，如果执行成功，则给MQ系统返回ACK消息。反之，不返回ACK消息。MQ系统会进行重试投递，下游服务要注意实现接口幂等。</p></li></ol><p><strong>事务消息方案流程图</strong></p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210221165243.png" alt="事务消息方案流程图" style="zoom:45%;" /><p>以上面提到的下单场景为例，伪代码实现如下：<br><strong>发送事务消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">buildOrder</span><span class="params">(OrderDto orderDto)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    TransactionListener transactionListener = <span class="keyword">new</span> OrderTransactionListenerImpl();</span><br><span class="line">    TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">""</span>);</span><br><span class="line">    producer.setTransactionListener(transactionListener);</span><br><span class="line">    </span><br><span class="line">    TransactionListener transactionListener = <span class="keyword">new</span> OrderTransactionListenerImpl();</span><br><span class="line">    TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">""</span>);</span><br><span class="line">    producer.setTransactionListener(transactionListener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 生成唯一业务bizId，将bizId和其他相关信息组装到消息体中</span></span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    orderDto.setBizId(<span class="string">""</span>);</span><br><span class="line">    String orderString = JSON.toJSONString(orderDto);</span><br><span class="line">    message.setBody(orderString.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用消息客户端API，发送事务prepare消息</span></span><br><span class="line">    SendResult sendResult = producer.send(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 根据不同情况返回不同的结果</span></span><br><span class="line">    <span class="keyword">if</span> (SendStatus.SEND_OK.equals(sendResult.getSendStatus())) &#123;</span><br><span class="line">        <span class="comment">// 消息发送成功，可以返回前端告知用户订单处理中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反之失败，返回前端告知用户下单失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">""</span>,<span class="string">"下单失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行本地事务和RocketMQ检查接口实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于RocketMQ事务消息实现分布式事务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, Object o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从消息中取出业务唯一ID和相关信息</span></span><br><span class="line">        <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="comment">// 2. 执行本地事务,成功返回LocalTransactionState.COMMIT_MESSAGE,失败返回LocalTransactionState.ROLLBACK_MESSAGE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息队列定时补偿调用的接口,RocketMQ会调用多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageExt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从消息中取出业务唯一ID和相关信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 检查业务,若执行成功则返回LocalTransactionState.COMMIT_MESSAGE,失败返回LocalTransactionState.ROLLBACK_MESSAGE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，MQ事务消息和本地消息表两种方案其实是一样的，本质上就是MQ实现了那个日志记录的功能。还有这两种方案也是基于消息队列可靠性，对于如何提高消息队列的可靠性，恐怕还是可以写一篇长文。另外，基于事务消息的方案对MQ系统要求较高，目前并不是所有的MQ系统支持事务消息功能，貌似只有RocketMQ支持。如果你目前的系统使用的MQ系统不支持事务消息的功能，采用本地消息表方案实现分布式事务功能也算是一个不错的选择。</p><p>上述两种方式实现过程中可以发现，都是将分布式事务拆分成本地事务实现，流程中可能出现消息传递失败需要定时任务补偿，明显是符合BASE理论的，都不是强一致性的而都是柔性事务，实现数据的最终一致性。还有一点要提出来的就是，<strong>这些方案流程方向都是不可逆的，原则上上游系统事务成功提交，下游系统的事务则也一定要成功，业务不能回滚，如果要是出现消息消费失败，则只能进行不断的重试，直到成功为止。</strong>所以大家使用的时候要注意，如果要避免这种情况，可以加入前面提到<strong>预锁</strong>机制，例如，一个电商下单扣库存的业务场景，用户下单时不扣库存，等用户支付完成才扣库存，这种实现方案是有可能出现库存不足的问题，要解决这种情况，可以在用户下单的时候，直接使用RPC同步请求方式锁定库存进行预留，这样用户后面订单支付成功则将锁定的库存才真正的扣除，如果用户最终没有完成支付，则直接取消订单，是否锁定的库存即可。当然这种情况也有可能出现用户恶意下单，导致真正的用户无法购买的问题，还有库存锁定占用时间过长的问题等等，当然这些问题都是可以解决的，看业务的接受情况自行选择吧！</p><h4 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h4><p>世界上唯一不变的，就是变化本身。单体架构系统通过数据库事务的ACID特性很容易实现数据一致性，而且是强一致性。为了提高系统的高可用性、吞吐量，提出了分布式架构，结果导致出现了分布式事务问题。果然验证了那句话“软件行业是没有银弹的”！最终引出了CAP理论、BASE理论，各路大牛也给出了相应的解决方案。</p><p>在分布式架构的情况下，将之前的关系型数据库提供的事务称之为<strong>本地事务</strong>，解决分布式系统中存在事务方案进而称之为<strong>分布式事务</strong>（重新定义下概念）。2PC、3PC方案实现的事务能保证强一致性，我们称之为<strong>刚性事务</strong>；TCC和可靠消息方案实现的事务只能保证最终一致性，那么我们称之为<strong>柔性事务</strong>。</p><p>由于CAP理论太过于乐观导致对于构建分布式系统没有全面的指导作用，大牛们对CAP理论的缺点进行改进提出了BASE理论。相比之下BASE理论更符合实际的情况，更加的接地气。BASE理论的指导我们在发生消息丢失或者网络分区的问题情况下，分布式系统可以根据自身业务特点，采取是<strong>保大（Consistency）还是保小（Availability）</strong>😄😄，然后使得系统在一定时间内达到最终一致性。</p><p>刚性事务可以实现强一致性，但性能不高；柔性事务性能较高，但是只能实现弱一致性。所以大家在构建自己的分布式系统遇到分布式事务问题时，根据自己的需求场景和业务承受情况，自行选择吧！</p><p>[参考资料：《分布式服务架构 原理、设计与实践》 李艳鹏 杨彪 著 ]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在系统是单体架构时，系统是和单个数据库进行交互，所以如果有多表操作的时候，可以使用数据库的事务实现数据的一致性，这种事务可以称之为&lt;strong&gt;本地事务&lt;/strong&gt;。随着业务的发展，系统的压力越来越大，单体数据库的性能也达到了瓶颈，不可避免的进行数据库的拆分，还有系统模块的拆分，跨服务、跨数据库的事务场景就越来越多，这样解决分布式的事务的需求就出现了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="分布式事务" scheme="https://ydstudios.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="2pc" scheme="https://ydstudios.gitee.io/tags/2pc/"/>
    
      <category term="3pc" scheme="https://ydstudios.gitee.io/tags/3pc/"/>
    
      <category term="tcc" scheme="https://ydstudios.gitee.io/tags/tcc/"/>
    
      <category term="本地消息表" scheme="https://ydstudios.gitee.io/tags/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8/"/>
    
      <category term="rocketmq事务消息" scheme="https://ydstudios.gitee.io/tags/rocketmq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
    
      <category term="可靠消息最终一致性方案" scheme="https://ydstudios.gitee.io/tags/%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>解耦神器之观察者模式</title>
    <link href="https://ydstudios.gitee.io/post/5b3d1989.html"/>
    <id>https://ydstudios.gitee.io/post/5b3d1989.html</id>
    <published>2021-02-04T23:49:32.000Z</published>
    <updated>2021-02-06T09:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家是不是会经常听到有人说写代码要“高内聚、低耦合”，但是你要是问他什么是高内聚低耦合（waht）？为什么要高内聚、低耦合(why)？怎么做才能高内聚、低耦合(how)? 这些问题就不一定都能回答的了！</p><a id="more"></a><blockquote><p>百度百科：在软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则是高内聚低耦合。<br>从模块粒度来看，高内聚：尽可能类的每个成员方法只完成一件事（最大限度的聚合）； 低耦合：减少类内部，一个成员方法调用另一个成员方法。<br>从类角度来看， 高内聚低耦合：减少类内部，对其他类的调用；<br>从功能块来看，高内聚低耦合：减少模块之间的交互复杂度（接口数量，参数数据）即横向：类与类之间、模块与模块之间；纵向：层次之间；尽可能，内容内聚，数据耦合。</p></blockquote><p>我本人特别喜欢李连杰演的这一版霍元甲，他年少轻狂，好勇斗狠，勇争津门第一，中年家破人亡，流落他乡悟出了侠的真谛，成为真正的大侠霍元甲。当然我不太希望我的一生这么波荡起伏，因为我没有他那么厉害。但是我特别喜欢剧中的一句台词，就是“<strong>功夫是需要时间去磨练出来的，两三年的猫脚功夫，这一拳20年的功夫，你们挡得住么？</strong>。作为一位程序员，我们对业务的理解、系统的设计、代码实现这些能力也是需要磨练的，而且也要日复一日的练习，不然你怎么挡得住面试官20年的功夫。😄😄</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210206152451.png" alt="霍元甲" style="zoom:30%;" /><p>本文对于什么是高内聚低耦合（waht）？为什么要高内聚、低耦合(why)？按下不表，就先说说一种能够让你的代码高内聚低耦合的方法： <strong>观察者模式</strong>,这种设计模式我认为就和策略模式一样的常用，这两种设计模式不仅实现起来简单，而且效果还好！其中的观察者模式<strong>简直是降低模块耦合性提高我们代码逼格的神奇啊！</strong> 那接下来就先说说观察者模式组成角色：</p><h5 id="抽象主题-Subject"><a href="#抽象主题-Subject" class="headerlink" title="抽象主题(Subject)"></a>抽象主题(Subject)</h5><p>它把所有观察者对象的引用保存到一个容器里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p><h5 id="具体主题-ConcreteSubject"><a href="#具体主题-ConcreteSubject" class="headerlink" title="具体主题(ConcreteSubject)"></a>具体主题(ConcreteSubject)</h5><p>将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</p><h5 id="抽象抽象观察者-Observer"><a href="#抽象抽象观察者-Observer" class="headerlink" title="抽象抽象观察者(Observer)"></a>抽象抽象观察者(Observer)</h5><p>为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p><h5 id="具体观察者-ConcreteObserver"><a href="#具体观察者-ConcreteObserver" class="headerlink" title="具体观察者(ConcreteObserver)"></a>具体观察者(ConcreteObserver)</h5><p>实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p><h6 id="Java原生实现"><a href="#Java原生实现" class="headerlink" title="Java原生实现"></a>Java原生实现</h6><p>Java从JDK1.0开始就自带了 <code>java.util.Observer</code> 和 <code>java.util.Observable</code> ,相关接口、类来实现观察者模式，由此可见Java对于观察者模式的重视，也从另一方面说明观察者模式是多么重要。那么接下来我们开始用Java自带的来实现观察者模式的编码。</p><p>在这里我们以一个下单的场景来举例描述，用户创建完订单，要发送一个消息通知用户订单创建成功，还要发送一个消息给仓库，检查对应的订单商品。具体代码如下。</p><h4 id="1-继承java-util-Observable定义主题"><a href="#1-继承java-util-Observable定义主题" class="headerlink" title="1. 继承java.util.Observable定义主题"></a>1. 继承<code>java.util.Observable</code>定义主题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSubject</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单状态发生变化通知其他，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="comment">// 通知其他</span></span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="comment">// 这里是可以携带一些额外的参数</span></span><br><span class="line">        <span class="keyword">this</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现java-util-Observer接口定义观察者"><a href="#2-实现java-util-Observer接口定义观察者" class="headerlink" title="2. 实现java.util.Observer接口定义观察者"></a>2. 实现<code>java.util.Observer</code>接口定义观察者</h4><p><code>java.util.Observer</code> 是一个接口，接口中只有一个 <code>update</code> 方法。每当更改被观察对象时，都会调用此方法。 应用程序调用Observable对象的 <code>notifyObservers</code>方法，以将更改通知给所有对象的观察者。在这个例子中通知模块、仓库模块就是扮演观察者的角色，具体的代码实现如下：</p><ul><li>通知模块实现<code>java.util.Observer</code>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoticeObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        OrderSubject orderSubject = (OrderSubject) o;</span><br><span class="line">        log.info(<span class="string">"通知中心收到了订单的变化[&#123;&#125;],arg = [&#123;&#125;]"</span>, orderSubject.getStatus(),arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>仓库模块实现<code>java.util.Observer</code>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WareHouseObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OrderSubject orderSubject = (OrderSubject) observable;</span><br><span class="line">        log.info(<span class="string">"仓库观察者收到了订单的变化[&#123;&#125;],arg = [&#123;&#125;]"</span>, orderSubject.getStatus(), arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-代码编写完成，测试一把"><a href="#3-代码编写完成，测试一把" class="headerlink" title="3. 代码编写完成，测试一把"></a>3. 代码编写完成，测试一把</h4><p>具体测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        OrderSubject orderSubject = <span class="keyword">new</span> OrderSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知系统监听者</span></span><br><span class="line">        NoticeObserver noticeObserver = <span class="keyword">new</span> NoticeObserver();</span><br><span class="line">        orderSubject.addObserver(noticeObserver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仓库监听者</span></span><br><span class="line">        WareHouseObserver wareHouseObserver = <span class="keyword">new</span> WareHouseObserver();</span><br><span class="line">        orderSubject.addObserver(wareHouseObserver);</span><br><span class="line">         <span class="comment">// 订单创建</span></span><br><span class="line">        orderSubject.setStatus(<span class="string">"订单创建啦"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订单付款</span></span><br><span class="line">        orderSubject.setStatus(<span class="string">"订单付款啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单的状态发生了变化，对应的观察者就接受到了通知。JDK提供的实现很简单，但是缺陷也是很明显。</p><ul><li><p><code>Observable</code> 是一个类，不是一个接口，也不是一个抽象类，不继承该类无法使用权限类型为 protected 的<code>setChanged()</code>和 <code>clearChanged()</code>方法。</p></li><li><p>用<code>Vector&lt;Observer&gt;</code>保存观察者。<code>Vector</code>效率低下，JDK已经不建议使用了。</p></li><li><p>主题变化通知观察者的顺序无法自定义。通知的顺序是固定为按照设置观察者的时间倒叙通知，无法自定义。</p></li><li><p>整体代码执行是同步的，不能设置为异步。且观察者的执行出现异常，程序处理不到位会导致<strong>事务回滚</strong>。</p></li></ul><p>既然JDK中实现不够完美，我们就看看有没有其他的实现方式。Google的Guava工具包提供了EventBus可以实现、Spring框架中也提供了相应的支持，由于我们使用Spring框架比较多，今天我们就先来说说Spring框架中是如何实现对观察者模式的支持吧！</p><h6 id="Spring中的实现"><a href="#Spring中的实现" class="headerlink" title="Spring中的实现"></a>Spring中的实现</h6><p>Spring框架中提供了相当多的组件可以实现观察者模式，文章后面会一一向大家介绍。这里我引入一个新的业务场景，用户注册之后发送短信通知、积分还有优惠券。这种业务场景非常的常见，我展示一下小伙伴们一般是怎么样实现这样的功能的。因为篇幅有限，这里就展示一下伪代码吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> MemberDao memberDao;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> CouponService couponService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SmsService smsService;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成用户注册，成功之后发送优惠券、短信通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memberName 查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 分页信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">normalRegister</span><span class="params">(String memberName,String phone)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1、执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, phone);</span><br><span class="line">        <span class="comment">// 保存用户</span></span><br><span class="line">        Long memberId = memberDao.saveMember();</span><br><span class="line">        <span class="comment">// 2、发送优惠券</span></span><br><span class="line">        couponService.sendCoupon(memberId);</span><br><span class="line">        <span class="comment">// 3、发送短信</span></span><br><span class="line">        smsService.sendSms(phone);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大家对这部分代码怎么看？</strong></p><p>对于用户注册功能来说，保障用户成功注册，这是个业务的核心诉求，其他的都是锦上添花，所以这个地方不应该掺杂其他的业务。用户注册与发送短信、优惠券功能应该分隔开，这样也符合解耦的设计规则。不然后续业务增加需求，需要用户注册完成之后给用户发送积分，你是不是还要在这个 <code>normalRegister</code>方法中增加发送积分的逻辑，那这个岂不是又违背了开闭原则。</p><blockquote><p>一件事做容易，想做好不容易。写程序也是如此，能够把功能编码实现bug又少，其实是很耗费时间和精力的。我常跟同事们开玩笑说“写代码不要糊弄，该写的代码一定要写，不然你最后肯定会被代码糊弄”。</p></blockquote><p><strong>接下来我来介绍一下如何使用Spring的事件发布机制来实现业务解耦的</strong></p><p>由于后面的实现方法中用户注册事件类的代码都是类似的只是类名不同，那我就把用户注册事件类的代码写在前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以自定义些自己需要的属性</span></span><br><span class="line"><span class="comment">     * 用户的id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long memberId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String memberPhone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object source, Long memberId, String memberPhone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.memberId = memberId;</span><br><span class="line">        <span class="keyword">this</span>.memberPhone = memberPhone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="利用继承ApplicationEvent类、实现ApplicationListener接口或者-EventListener注解来实现"><a href="#利用继承ApplicationEvent类、实现ApplicationListener接口或者-EventListener注解来实现" class="headerlink" title="利用继承ApplicationEvent类、实现ApplicationListener接口或者  @EventListener注解来实现"></a>利用继承<code>ApplicationEvent</code>类、实现<code>ApplicationListener</code>接口或者  <code>@EventListener</code>注解来实现</h5><p><code>org.springframework.context.ApplicationListener</code>是Spring提供的一个泛型接口。由应用程序事件侦听器实现的接口,从Spring 3.0开始，<code>ApplicationListener</code>可以一般性地声明其感兴趣的事件类型。在Spring ApplicationContext中注册后，将相应地过滤事件，并且仅针对匹配事件对象调用侦听器。观察者可以实现<code>ApplicationListener</code>接口或者使用<code>@EventListener</code>注解，这个注解和<code>ApplicationListener</code>接口有着相同的功能，相比之下使用注解比使用接口更方便一点。</p><h4 id="短信Service实现ApplicationListener接口"><a href="#短信Service实现ApplicationListener接口" class="headerlink" title="短信Service实现ApplicationListener接口"></a>短信Service实现ApplicationListener接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"[EventListener][给用户(&#123;&#125;) 发送短信]"</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优惠券Service直接在addCoupon-方法上添加注解-EventListener"><a href="#优惠券Service直接在addCoupon-方法上添加注解-EventListener" class="headerlink" title="优惠券Service直接在addCoupon 方法上添加注解 @EventListener"></a>优惠券Service直接在<code>addCoupon</code> 方法上添加注解 <code>@EventListener</code></h4><p>注意<code>addCoupon</code> 方法的入参为 <code>UserRegisterEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponService</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"[addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>积分Service中的代码与上面的类似就不贴出来了</strong></p><h4 id="注册业务完成发布UserRegisterEvent事件"><a href="#注册业务完成发布UserRegisterEvent事件" class="headerlink" title="注册业务完成发布UserRegisterEvent事件"></a>注册业务完成发布<code>UserRegisterEvent</code>事件</h4><p>这个地方MemberService要实现<code>org.springframework.beans.factory.Aware.ApplicationEventPublisherAware</code>接口，才有能力使用 <code>ApplicationEventPublisher</code> 发布事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最简单的观察者实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 用户手机号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(String memberPhone)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, memberPhone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、用户数据保存到数据库</span></span><br><span class="line">        Long memberId = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、发布事件通知</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, memberId, memberPhone));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>, <span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        memberService.register(<span class="string">"13911111111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204230758.png" alt="发送短信在发送优惠券之前"></p><p>代码执行成功，打印出了给用户发送短信、优惠券日志，功能完美实现。但是稍微有点问题，我想调换一下两者的顺序，先执行发送优惠券，再发送短信。这个要求还是蛮常见，那怎么实现呢？</p><h5 id="使用SmartApplicationListener或者GenericApplicationListener接口实现指定观察者自定义顺序执行"><a href="#使用SmartApplicationListener或者GenericApplicationListener接口实现指定观察者自定义顺序执行" class="headerlink" title="使用SmartApplicationListener或者GenericApplicationListener接口实现指定观察者自定义顺序执行"></a>使用<code>SmartApplicationListener</code>或者<code>GenericApplicationListener</code>接口实现指定观察者自定义顺序执行</h5><p><code>org.springframework.context.event.SmartApplicationListener</code>是Spring3.0版本提供的接口，<code>org.springframework.context.event.GenericApplicationListener</code>则是Spring4.2版本提供的接口，如果在你的项目中使用不了，那就是说明你项目中使用的Spring版本过低，这个问题自己自行处理。<br>在查<code>SmartApplicationListener</code>源码时发现有以下注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Extended variant of the standard &#123;<span class="meta">@link</span> ApplicationListener&#125; <span class="class"><span class="keyword">interface</span>,</span></span><br><span class="line"><span class="class"><span class="title">exposing</span> <span class="title">further</span> <span class="title">metadata</span> <span class="title">such</span> <span class="title">as</span> <span class="title">the</span> <span class="title">supported</span> <span class="title">event</span> <span class="title">type</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">p</span>&gt;<span class="title">Users</span> <span class="title">are</span> &lt;<span class="title">bold</span>&gt;<span class="title">strongly</span> <span class="title">advised</span>&lt;/<span class="title">bold</span>&gt; <span class="title">to</span> <span class="title">use</span> <span class="title">the</span> </span>&#123;<span class="meta">@link</span> GenericApplicationListener&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">instead</span> <span class="title">as</span> <span class="title">it</span> <span class="title">provides</span> <span class="title">an</span> <span class="title">improved</span> <span class="title">detection</span> <span class="title">of</span> <span class="title">generics</span>-<span class="title">based</span></span></span><br><span class="line"><span class="class"><span class="title">event</span> <span class="title">types</span>.</span></span><br></pre></td></tr></table></figure><p>翻译之后大概的意思就是，<strong>SmartApplicationListener是标准<code>ApplicationListener</code>接口的扩展变体，公开了进一步的元数据，例如受支持的事件类型。但强烈建议改用<code>GenericApplicationListener</code>接口，因为它提供了对基于泛型的事件类型的改进检测</strong>，那我此处就只以GenericApplicationListener为例了。</p><p>优惠券服务Service同样实现接口 <code>GenericApplicationListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondVersionCouponService</span> <span class="keyword">implements</span> <span class="title">GenericApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确定此侦听器是否实际上支持给定的事件类型。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SecondVersionUserRegisterEvent<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">eventType</span>.<span class="title">getRawClass</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确定此侦听器是否实际上支持给定的源类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MemberService<span class="class">.<span class="keyword">class</span> </span>== sourceType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的业务逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        SecondVersionUserRegisterEvent userRegisterEvent = (SecondVersionUserRegisterEvent) event;</span><br><span class="line">        Long memberId = userRegisterEvent.getMemberId();</span><br><span class="line">        log.info(<span class="string">"[Second addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设定执行的顺序，数字越小优先级越高就越先被执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短信服务Service同样实现接口 <code>GenericApplicationListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondVersionSmsService</span> <span class="keyword">implements</span> <span class="title">GenericApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(ResolvableType eventType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SecondVersionUserRegisterEvent<span class="class">.<span class="keyword">class</span> </span>== eventType.getRawClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MemberService<span class="class">.<span class="keyword">class</span> </span>== sourceType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        SecondVersionUserRegisterEvent userRegisterEvent = (SecondVersionUserRegisterEvent) event;</span><br><span class="line">        String memberPhone = userRegisterEvent.getMemberPhone();</span><br><span class="line">        log.info(<span class="string">"[Second onApplicationEvent][给用户(&#123;&#125;) 发送短信]"</span>, memberPhone);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实使用<code>org.springframework.context.ApplicationListener</code> + <code>org.springframework.core.annotation.Order</code>注解也可以实现控制观察者的执行顺序，而且更简洁！</p></blockquote><h4 id="注册业务完成发布UserRegisterEvent事件-1"><a href="#注册业务完成发布UserRegisterEvent事件-1" class="headerlink" title="注册业务完成发布UserRegisterEvent事件"></a>注册业务完成发布<code>UserRegisterEvent</code>事件</h4><p>这个地方MemberService要实现<code>org.springframework.beans.factory.Aware.ApplicationEventPublisherAware</code>接口，才有能力使用 <code>ApplicationEventPublisher</code> 发布事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最简单的观察者实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 用户手机号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span> <span class="title">register</span>(<span class="title">String</span> <span class="title">phone</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[Second register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, phone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、 保存用户到数据库（假设这个是）</span></span><br><span class="line">        BizLocalMessageEntity entity = <span class="keyword">new</span> BizLocalMessageEntity();</span><br><span class="line">        ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">        entity.setBizModule((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        entity.setBizNo(<span class="string">""</span> + random.nextInt(<span class="number">100000</span>));</span><br><span class="line">        entity.setBizType((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        entity.setSendStatus((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        entity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        entity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">        Long memberId = entity.getId();</span><br><span class="line">        log.info(<span class="string">"插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, memberId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、发布事件通知</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> SecondVersionUserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>, <span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        memberService.register(<span class="string">"13911111111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204230024.png" alt="运行截图"></p><p>修改两个Service中order的数值可以轻松两个观察者的执行顺序，完美的解决了自定义观察者执行顺序的要求。细心的小伙伴会发现，假设在用户注册的方法中存在事务，观察者的执行出现异常，会导致整个事务回滚，明明用户的数据已经保存到数据库，现在却没有了！还是前面那句话，在这个业务场景，用户注册成功是核心诉求，发送短信、优惠券重要性都是比不上的。那要解决这种情况，就需要用户注册成功的事务提交之后，再发布注册成功事件，避免观察者执行结果的影响。</p><p><strong>短信服务Service有有异常抛出导致事务回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">       SecondVersionUserRegisterEvent userRegisterEvent = (SecondVersionUserRegisterEvent) event;</span><br><span class="line">       String memberPhone = userRegisterEvent.getMemberPhone();</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(memberPhone)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试事件中发生异常对原有业务的影响,短信发送失败！！！！"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       log.info(<span class="string">"[Second onApplicationEvent][给用户(&#123;&#125;) 发送短信]"</span>, memberPhone);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204225825.png" alt="短信观察者执行发生异常"></p><p>可能有的小伙伴想，观察者执行异常导致事务回滚，本质上来说这种方式实现的观察者模式，其实还是在一个线程中同步执行的。那我就在观察者中捕获所有的异常或者用户注册成功之后异步发布事件。</p><ul><li><strong>捕获所有异常</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            SecondVersionUserRegisterEvent userRegisterEvent = (SecondVersionUserRegisterEvent) event;</span><br><span class="line">            Long memberId = userRegisterEvent.getMemberId();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试事件中发生异常对原有业务的影响,短信发送失败！！！！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"[Second addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, memberId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"发放优惠劵发生异常"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>异步发布事件</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 3、异步发布事件通知,这样的有可能事务还没有提交，则异步线程读取不到数据库中的数据</span></span><br><span class="line">CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">&#125;);</span><br><span class="line">voidCompletableFuture.exceptionally(exception -&gt; &#123;</span><br><span class="line">    log.error(<span class="string">"发生了异常"</span>, exception);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一种方式可以解决事务回滚的问题，但是呢感觉会有点low！</p><p>第二种方式假如观察者中查询会员的信息，可能出现查不到，因为可能事务还没有提交。</p><h5 id="使用-TransactionalEventListener-实现事务提交之后才执行观察者"><a href="#使用-TransactionalEventListener-实现事务提交之后才执行观察者" class="headerlink" title="使用 @TransactionalEventListener 实现事务提交之后才执行观察者"></a>使用 <code>@TransactionalEventListener</code> 实现事务提交之后才执行观察者</h5><p>使用起来很简单，直接在对应的观察者方法上添加该注解即可。<code>@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeCouponService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span>(phase = TransactionPhase.AFTER_COMMIT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCoupon</span><span class="params">(ThreeUserRegisterEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"测试事件中发生异常对原有业务的影响"</span>);</span><br><span class="line">        Long memberId = event.getMemberId();</span><br><span class="line">        <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试事件中发生异常对原有业务的影响,优惠券发送失败！！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">" Version=3 [addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意一定要在 <code>register()</code> 方法上添加 <code>@Transactional</code> 注解</strong>，不然 <code>register()</code> 方法中有抛出异常之后，会有下面的错误提示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息: Closing org.springframework.context.support.GenericApplicationContext<span class="meta">@a</span>67c67e: </span><br><span class="line">startup date [Thu Feb <span class="number">04</span> <span class="number">18</span>:<span class="number">06</span>:<span class="number">53</span> CST <span class="number">2021</span>]; root of context hierarchy</span><br></pre></td></tr></table></figure><p><strong>@Transactional一定要加上</strong>不然方法体内有一次抛出会有上的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Result</span> <span class="title">register</span>(<span class="title">String</span> <span class="title">phone</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">    log.info(<span class="string">"[Second register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, phone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、 保存用户(假设这是)</span></span><br><span class="line">    <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">    Long memberId = entity.getId();</span><br><span class="line">    log.info(<span class="string">"插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, memberId);</span><br><span class="line">    <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"故意抛出异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="keyword">new</span> ThreeUserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，实现 <code>register()</code> 事务提交之后，再发布事件还有两种方式：</p><ul><li>使用事务模板TransactionTemplate</li></ul><ol><li>使用之前需要在配置文件中配置事务模板</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 transactionTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在代码中使用事务模板提交事务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[线程name=&#123;&#125;,register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, Thread.currentThread().getName(), phone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、 保存用户(假设这是)</span></span><br><span class="line">        Long memberId = transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            Long result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BizLocalMessageEntity entity = <span class="keyword">new</span> BizLocalMessageEntity();</span><br><span class="line">                ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">                entity.setBizModule((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                entity.setBizNo(<span class="string">""</span> + random.nextInt(<span class="number">200000</span>));</span><br><span class="line">                entity.setBizType((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                entity.setMsg(<span class="string">"消息内容"</span>);</span><br><span class="line">                entity.setMsgDesc(<span class="string">"消息备注"</span>);</span><br><span class="line">                entity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">                entity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">                result = entity.getId();</span><br><span class="line">                log.info(<span class="string">"Version5 插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, result);</span><br><span class="line">                <span class="keyword">if</span> (affectRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//throw new RuntimeException("测试主要业务失败，事件是否会发布执行");</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"业务失败发生异常"</span>, e);</span><br><span class="line">                <span class="comment">// 标记事务回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"事务执行情况 用户的id= [&#123;&#125;]"</span>, memberId);</span><br><span class="line">        <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、异步发布事件通知</span></span><br><span class="line">            log.info(<span class="string">"发布注册成功事件"</span>);</span><br><span class="line">            applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>使用TransactionSynchronizationManager</li></ul><p>这个可以直接使用无需配置，重写TransactionSynchronizationAdapter的afterCommit()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Result</span> <span class="title">register</span>(<span class="title">String</span> <span class="title">phone</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">    log.info(<span class="string">"[Version4 register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, phone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、 保存用户(假设这是)</span></span><br><span class="line">    BizLocalMessageEntity entity = <span class="keyword">new</span> BizLocalMessageEntity();</span><br><span class="line">    ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">    entity.setBizModule((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    entity.setBizNo(<span class="string">""</span> + random.nextInt(<span class="number">100000</span>));</span><br><span class="line">    entity.setBizType((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    entity.setMsg(<span class="string">""</span>);</span><br><span class="line">    entity.setMsgDesc(<span class="string">""</span>);</span><br><span class="line">    entity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">    entity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Long memberId = entity.getId();</span><br><span class="line">    <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">    log.info(<span class="string">"Version4 插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, memberId);</span><br><span class="line">    <span class="keyword">if</span> (affectRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//throw new RuntimeException("Version4 测试主要业务失败，事件是否会发布执行");</span></span><br><span class="line">    &#125;</span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.afterCommit();</span><br><span class="line">            <span class="comment">// 3、事务提交之后发布事件通知</span></span><br><span class="line">            applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把目前的代码执行一下看看情况怎么样</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204214744.png" style="zoom:50%;" alt="执行日志截图"/><p>从截图上看，我们目前已经通过好几种方式解决了观察者执行异常导致事务回滚的问题，但是也可以从截图中看出用户注册逻辑和对应的观察者都是在main线程中执行的，那我们可以让观察者异步执行吗？这样也可以加快代码的执行速度。这个问题当然也是可以解决的，接下来我们来解决这个问题：</p><ul><li>直接使用@Async注解</li></ul><p><strong>需要注意的是</strong>，使用这个注解一定要自定义线程池，不是它默认使用的是 <code>org.springframework.core.task.SimpleAsyncTaskExecutor</code> 。但这个 SimpleAsyncTaskExecutor 不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SixCouponService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Order</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCoupon</span><span class="params">(SixUserRegisterEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"测试事件中发生异常对原有业务的影响"</span>, <span class="string">""</span>);</span><br><span class="line">        Long memberId = event.getMemberId();</span><br><span class="line">        log.info(<span class="string">"线程name=&#123;&#125;,[addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, Thread.currentThread().getName(), memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动异步线程来发布事件</li></ul><p>意思就是事务提交之后，判断事务提交成功则新建一个线程然后发布注册成功事件。事务提交成功可以前面提到的事务模板transactionTemplate和事务管理器TransactionSynchronizationManager。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[线程name=&#123;&#125;,register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, Thread.currentThread().getName(), phone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、 保存用户(假设这是)</span></span><br><span class="line">        Long memberId = transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            Long result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BizLocalMessageEntity entity = <span class="keyword">new</span> BizLocalMessageEntity();</span><br><span class="line">                ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">                entity.setBizModule((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                entity.setBizNo(<span class="string">""</span> + random.nextInt(<span class="number">200000</span>));</span><br><span class="line">                entity.setBizType((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                entity.setMsg(<span class="string">"消息内容"</span>);</span><br><span class="line">                entity.setMsgDesc(<span class="string">"消息备注"</span>);</span><br><span class="line">                entity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">                entity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">                result = entity.getId();</span><br><span class="line">                log.info(<span class="string">"Version5 插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"业务失败发生异常"</span>, e);</span><br><span class="line">                <span class="comment">// 标记事务回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"事务执行情况 用户的id= [&#123;&#125;]"</span>, memberId);</span><br><span class="line">        <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、异步发布事件通知</span></span><br><span class="line">            log.info(<span class="string">"发布注册成功事件"</span>);</span><br><span class="line">            CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">                applicationEventPublisher.publishEvent(<span class="keyword">new</span> SixUserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码修改之后执行，运行截图如下：</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204222111.png" alt="运行截图"><br>我们可以发现代码分别main、taskExecutor-1和taskExecutor-2 三个线程执行的，完美的解决了上面提到的问题。</p><p>使用观察者模式之前的用户注册流程：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204230251.png" alt="优化后的注册流程" style="zoom:35%;" /><p>使用观察者模式之后的用户注册流程：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204230429.png" alt="优化后的注册流程" style="zoom:30%;" /><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>用户数据写入数据表成功，发布注册成功事件，通知相关的短信、优惠券、积分模块。用观察者模式实现之后，注册逻辑和其他的逻辑分离开，即使后续新加一个邮件通知或者去掉一个发送积分的操作,只是修改了对应的代码逻辑，不用回滚测试所有场景。这符合对修改关闭对扩展开放的规则，有效的降低了各个模块之间耦合度，使得代码的可维护性大大提高。有些同学可能会抱怨，自己的项目简单用不到这些看似高大上的设计模式，其实不然，你只是没有认真研究自己的项目，还有就是对自己的写的代码没有太高的要求。如果你看到了本文，而且看到此处，你回想一下你所做的项目，难道没有一个业务场景满足观察者模式条件么？你想想是不是！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家是不是会经常听到有人说写代码要“高内聚、低耦合”，但是你要是问他什么是高内聚低耦合（waht）？为什么要高内聚、低耦合(why)？怎么做才能高内聚、低耦合(how)? 这些问题就不一定都能回答的了！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="spring" scheme="https://ydstudios.gitee.io/tags/spring/"/>
    
      <category term="设计模式" scheme="https://ydstudios.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="https://ydstudios.gitee.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>船新版本的策略模式，你一定没有见过</title>
    <link href="https://ydstudios.gitee.io/post/cd1b2f51.html"/>
    <id>https://ydstudios.gitee.io/post/cd1b2f51.html</id>
    <published>2021-01-30T15:06:49.000Z</published>
    <updated>2021-02-14T04:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在之前的文章<a href="https://ydstudios.gitee.io/post/170b3d6a.html">设计模式学习之策略模式</a> 一文中介绍了策略模式的优点、缺点、实现方法和具体的使用场景。策略类有<code>策略类会增多,造成类膨胀</code>的缺点，这个缺点我还是比较在意的。因为在实际开发中发现，有时策略的实现没有多少代码，这样的定义成一个策略类反而真的有点浪费，确实造成了类膨胀。自从发现了这个问题，我一直在思考如何解决这种问题，经过思考解决问题的方法已经想出来了，但是一直没有去尝试做出来看看是否真的能解决策略模式 <code>类膨胀的问题</code>,终于在这周我忙里偷闲用代码实现了我的想法，我自认为利用 <code>Lambda表达式 + 反射 + 注解</code> 组合解决了<code>类膨胀的问题</code>，这种船新版本实现方案，容我细细道来！</p><a id="more"></a><blockquote><p>大扎好，我系渣渣辉，探挽懒月，介四里没有挽过的船新版本，挤需体验三番钟，里造会干我一样，爱象节款游戏。 —开心一哈 😄😄</p></blockquote><h5 id="代码结构图"><a href="#代码结构图" class="headerlink" title="代码结构图"></a>代码结构图</h5><p>这种实现方法，UML图没法展现其中关系，所以就不贴UML图了，直接上代码的结构图。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210130154828.png" alt="船新版本策略模式" style="zoom:50%;" /><h5 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h5><ul><li>为何会出现类膨胀</li></ul><p>策略模式类膨胀的缺点，就是策略类太多的缘故。如果策略类的实现代码不是很多，是否可以将策略不在类的级别上实现？于是想到了利用Lambda表达式的匿名类来实现策略接口，这样不就把实现从类降级到了方法级别了么，哈哈😄😄！！</p><ul><li>如何将这些策略方法统一起来，方便外部调用<br>策略方法都在一个类中，这样首先要标注一下方法，哪个是策略方法，哪个是普通方法。这个问题我们用注解来实现，因为在Java 语言中的类、方法、变量、参数和包等都可以用注解来标注。</li></ul><p>我想把策略方法存放在Map中，用策略的名字作为Map的key，策略方法作为Map的value。我们在这里用反射来将Lambda实现的匿名类存放到Map中。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ol><li><p>定义一个策略注解 Strategy，用来标注策略方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Strategy 注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Strategy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识不同的模块 product、order模块</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的策略类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>策略接口,这里的策略接口如果不是很复杂的话可以用jdk自带的<code>java.util.function.Function&lt;T, R&gt;</code>替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 策略的入参类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; 策略的返回值类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStrategyHandler</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AbstractStrategy实现使用Spring提供的扩展点ApplicationContextAware，在系统启动的时候将对应策略方法的存放在Map中，同时对外提供执行入口 execute</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStrategyContext</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IStrategyHandler&lt;T, R&gt;&gt; implMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String DELIMITER = <span class="string">"####"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得bean 的class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> &lt;K&gt; <span class="function">Class&lt;K&gt; <span class="title">getClazz</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回spring中的beanName</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getBeanName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy 策略类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> module   模块</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param    参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">(String strategy, String <span class="keyword">module</span>, T param)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String key = StringUtils.join(<span class="keyword">module</span>, DELIMITER, strategy);</span><br><span class="line">        IStrategyHandler&lt;T, R&gt; handler = implMap.get(key);</span><br><span class="line">        log.debug(<span class="string">"策略实现集合&#123;&#125;"</span>, implMap);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有相应的策略实现"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        R apply = handler.apply(param);</span><br><span class="line">        <span class="keyword">return</span> apply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        log.error(<span class="string">"AbstractStrategy 执行"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;Object&gt; clazz = getClazz();</span><br><span class="line">        Object bean = applicationContext.getBean(getBeanName(), clazz);</span><br><span class="line">        <span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Strategy strategyAnnotation = bean.getClass().getAnnotation(Strategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (strategyAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"类[&#123;&#125;]没有添加Strategy注解"</span>, clazz);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模块的名称</span></span><br><span class="line">        String <span class="keyword">module</span> = strategyAnnotation.<span class="keyword">module</span>();</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isEmpty(declaredMethods)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(clazz + <span class="string">"没有相关策略方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            Strategy annotation = declaredMethod.getAnnotation(Strategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 用module和 四个 #### 加上 value 组成map的key</span></span><br><span class="line">                String key = StringUtils.join(<span class="keyword">module</span>, DELIMITER, annotation.value());</span><br><span class="line">                IStrategyHandler&lt;T, R&gt; handler = (IStrategyHandler&lt;T, R&gt;) declaredMethod.invoke(bean);</span><br><span class="line">                implMap.put(key, handler);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                log.error(<span class="string">"模块[&#123;&#125;]策略处理发生了错误"</span>, <span class="keyword">module</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>订单、产品模块有这种策略模式场景</p></li></ol><p>订单模块的策略模式场景,IStrategyHandler的策略方法都在OrderStrategyImpl中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Strategy</span>(<span class="keyword">module</span> = <span class="string">"Order"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStrategyImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BizLocalMessageService bizLocalMessageService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Strategy</span>(value = <span class="string">"strategy1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IStrategyHandler&lt;BInDto, BOutDto&gt; <span class="title">strategy1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bInDto -&gt; &#123;</span><br><span class="line">            log.error(<span class="string">"订单模块相关策略 strategy1 executeStart"</span>);</span><br><span class="line">            String join = StringUtils.join(<span class="string">"strategy1:"</span>, bInDto.getParam1(), bInDto.getParam2());</span><br><span class="line">            BOutDto bOutDto = <span class="keyword">new</span> BOutDto();</span><br><span class="line">            bOutDto.setOrderNo(join);</span><br><span class="line">            bOutDto.setPrice(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">            SaveBizLocalMessageDto dto = <span class="keyword">new</span> SaveBizLocalMessageDto();</span><br><span class="line">            dto.setBizModule((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            ThreadLocalRandom localRandom = ThreadLocalRandom.current();</span><br><span class="line">            dto.setBizNo(localRandom.nextInt(<span class="number">16000</span>,<span class="number">115000</span>)+<span class="string">""</span>);</span><br><span class="line">            dto.setBizType((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            dto.setMsg(<span class="string">""</span>);</span><br><span class="line">            dto.setMsgDesc(<span class="string">""</span>);</span><br><span class="line">            dto.setHandledCount((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            dto.setMaxHandleCount((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            bizLocalMessageService.saveBizLocalMessage(dto);</span><br><span class="line">            log.error(<span class="string">"订单模块相关策略 strategy1 executeEnd"</span>);</span><br><span class="line">            <span class="keyword">return</span> bOutDto;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Strategy</span>(value = <span class="string">"strategy2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IStrategyHandler&lt;BInDto, BOutDto&gt; <span class="title">strategy2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> param -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">"订单模块相关策略 strategy2 executeStart"</span>);</span><br><span class="line"></span><br><span class="line">            String join = StringUtils.join(<span class="string">"strategy2:"</span>, param.getParam1(), param.getParam2());</span><br><span class="line">            BOutDto bOutDto = <span class="keyword">new</span> BOutDto();</span><br><span class="line">            bOutDto.setOrderNo(join);</span><br><span class="line">            bOutDto.setPrice(<span class="number">11121</span>);</span><br><span class="line"></span><br><span class="line">            SaveBizLocalMessageDto dto = <span class="keyword">new</span> SaveBizLocalMessageDto();</span><br><span class="line">            dto.setBizModule((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            ThreadLocalRandom localRandom = ThreadLocalRandom.current();</span><br><span class="line">            dto.setBizNo(localRandom.nextInt(<span class="number">6000</span>,<span class="number">15000</span>)+<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            dto.setBizType((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            dto.setMsg(<span class="string">""</span>);</span><br><span class="line">            dto.setMsgDesc(<span class="string">""</span>);</span><br><span class="line">            dto.setHandledCount((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            dto.setMaxHandleCount((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            bizLocalMessageService.saveBizLocalMessage(dto);</span><br><span class="line">            log.error(<span class="string">"订单模块相关策略 strategy2 executeEnd"</span>);</span><br><span class="line">            <span class="keyword">return</span> bOutDto;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产品模块的策略模式场景，IStrategyHandler的策略方法都在ProductStrategyImpl中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Strategy</span>(<span class="keyword">module</span> = <span class="string">"Product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductStrategyImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BizLocalMessageService bizLocalMessageService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Strategy</span>(value = <span class="string">"strategyA"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IStrategyHandler&lt;BInDto, BOutDto&gt; <span class="title">strategy1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bInDto -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">"产品模块相关策略 strategy1 executeStart"</span>);</span><br><span class="line"></span><br><span class="line">            String join = StringUtils.join(<span class="string">"strategyA:"</span>, bInDto.getParam1(), bInDto.getParam2());</span><br><span class="line">            BOutDto bOutDto = <span class="keyword">new</span> BOutDto();</span><br><span class="line">            bOutDto.setOrderNo(join);</span><br><span class="line">            bOutDto.setPrice(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">            SaveBizLocalMessageDto dto = <span class="keyword">new</span> SaveBizLocalMessageDto();</span><br><span class="line">            dto.setBizModule((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            ThreadLocalRandom localRandom = ThreadLocalRandom.current();</span><br><span class="line">            dto.setBizNo(localRandom.nextInt(<span class="number">1000</span>,<span class="number">5000</span>)+<span class="string">""</span>);</span><br><span class="line">            dto.setBizType((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            dto.setMsg(<span class="string">""</span>);</span><br><span class="line">            dto.setMsgDesc(<span class="string">""</span>);</span><br><span class="line">            dto.setHandledCount((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            dto.setMaxHandleCount((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            bizLocalMessageService.saveBizLocalMessage(dto);</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">"产品模块相关策略 strategy1 executeEnd"</span>);</span><br><span class="line">            <span class="keyword">return</span> bOutDto;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Strategy</span>(value = <span class="string">"strategyB"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IStrategyHandler&lt;BInDto, BOutDto&gt; <span class="title">strategy2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> param -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">"产品模块相关策略 strategy2 executeStart"</span>);</span><br><span class="line"></span><br><span class="line">            String join = StringUtils.join(<span class="string">"strategyB:"</span>, param.getParam1(), param.getParam2());</span><br><span class="line">            BOutDto bOutDto = <span class="keyword">new</span> BOutDto();</span><br><span class="line">            bOutDto.setOrderNo(join);</span><br><span class="line">            bOutDto.setPrice(<span class="number">11121</span>);</span><br><span class="line"></span><br><span class="line">            SaveBizLocalMessageDto dto = <span class="keyword">new</span> SaveBizLocalMessageDto();</span><br><span class="line">            dto.setBizModule((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            ThreadLocalRandom localRandom = ThreadLocalRandom.current();</span><br><span class="line">            dto.setBizNo(localRandom.nextInt(<span class="number">5000</span>,<span class="number">8000</span>)+<span class="string">""</span>);</span><br><span class="line">            dto.setBizType((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            dto.setMsg(<span class="string">""</span>);</span><br><span class="line">            dto.setMsgDesc(<span class="string">""</span>);</span><br><span class="line">            dto.setHandledCount((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            dto.setMaxHandleCount((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            bizLocalMessageService.saveBizLocalMessage(dto);</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">"产品模块相关策略 strategy2  executeEnd"</span>);</span><br><span class="line">            <span class="keyword">return</span> bOutDto;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>将存放策略方法的类和策略上下文关联起来</li></ol><p>订单模块相关</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStrategyContext</span> <span class="keyword">extends</span> <span class="title">AbstractStrategyContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Class&lt;OrderStrategyImpl&gt; <span class="title">getClazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> OrderStrategyImpl<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getBeanName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"orderStrategyImpl"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产品模块相关</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductStrategyContext</span> <span class="keyword">extends</span> <span class="title">AbstractStrategyContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Class&lt;ProductStrategyImpl&gt; <span class="title">getClazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ProductStrategyImpl<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getBeanName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"productStrategyImpl"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>代码实现完毕，我们来测试一下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>,<span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AbstractStrategy&lt;BInDto, BOutDto&gt; orderStrategyContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AbstractStrategy&lt;BInDto, BOutDto&gt; productStrategyContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BInDto bInDto = <span class="keyword">new</span> BInDto();</span><br><span class="line">        bInDto.setParam1(<span class="string">"产品金额"</span>);</span><br><span class="line">        bInDto.setParam2(<span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">        productStrategyContext.execute(<span class="string">"strategyA"</span>, <span class="string">"Product"</span>, bInDto);</span><br><span class="line">        productStrategyContext.execute(<span class="string">"strategyB"</span>, <span class="string">"Product"</span>, bInDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BInDto bInDto = <span class="keyword">new</span> BInDto();</span><br><span class="line">        bInDto.setParam1(<span class="string">"优惠券金额"</span>);</span><br><span class="line">        bInDto.setParam2(<span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">        orderStrategyContext.execute(<span class="string">"strategy1"</span>, <span class="string">"Order"</span>, bInDto);</span><br><span class="line">        orderStrategyContext.execute(<span class="string">"strategy2"</span>, <span class="string">"Order"</span>, bInDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产品模块的测试<br><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210130164441.png" alt="产品模块的测试" style="zoom:50%;" /></p><p>订单模块的测试</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210130164512.png" alt="订单模块的测试" style="zoom:50%;" /><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>策略接口不是很复杂的情况下 IStrategyHandler 接口可以复用，自己实现 StrategyContext 抽象类，然后再实现自己的策略方法就可以了，不知大家对于这种船新版本有什么看法！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在之前的文章&lt;a href=&quot;https://ydstudios.gitee.io/post/170b3d6a.html&quot;&gt;设计模式学习之策略模式&lt;/a&gt; 一文中介绍了策略模式的优点、缺点、实现方法和具体的使用场景。策略类有&lt;code&gt;策略类会增多,造成类膨胀&lt;/code&gt;的缺点，这个缺点我还是比较在意的。因为在实际开发中发现，有时策略的实现没有多少代码，这样的定义成一个策略类反而真的有点浪费，确实造成了类膨胀。自从发现了这个问题，我一直在思考如何解决这种问题，经过思考解决问题的方法已经想出来了，但是一直没有去尝试做出来看看是否真的能解决策略模式 &lt;code&gt;类膨胀的问题&lt;/code&gt;,终于在这周我忙里偷闲用代码实现了我的想法，我自认为利用 &lt;code&gt;Lambda表达式 + 反射 + 注解&lt;/code&gt; 组合解决了&lt;code&gt;类膨胀的问题&lt;/code&gt;，这种船新版本实现方案，容我细细道来！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://ydstudios.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://ydstudios.gitee.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="反射" scheme="https://ydstudios.gitee.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="lambda表达式" scheme="https://ydstudios.gitee.io/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="注解" scheme="https://ydstudios.gitee.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>UML类图</title>
    <link href="https://ydstudios.gitee.io/post/122fc4b2.html"/>
    <id>https://ydstudios.gitee.io/post/122fc4b2.html</id>
    <published>2021-01-23T14:17:36.000Z</published>
    <updated>2021-01-23T07:26:07.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h5><p>UML(Unified Modeling Language，统一建模语言)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。</p><a id="more"></a><h5 id="UML和设计模式"><a href="#UML和设计模式" class="headerlink" title="UML和设计模式"></a>UML和设计模式</h5><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<strong>个人觉得设计模式是前人大佬总结的一种思想，是一种脱离语言并且能够指导程序员更容易写出好的代码的编程习惯。</strong>对于一个没有太多经验的程序员，如何写出 <strong>简洁优雅，可复用性高，可扩展性强，高内聚低耦合</strong> 的代码至关重要。学习别人的设计模式就是为了在没有经验的情况下写出一手不错的代码，只看不写并不能深刻体验到设计模式的巧妙之处，而学会使用UML进行需求分析，是使用设计模式写好代码的前提。</p><h5 id="UML图分类"><a href="#UML图分类" class="headerlink" title="UML图分类"></a>UML图分类</h5><ul><li>用例图(Use Case Diagram)，描述系统功能；</li><li>类图(Class Diagram)，描述系统的静态结构；</li><li>对象图(Object Diagram)，描述系统在某个时刻的静态结构；</li><li>组件图(Component Diagram)，描述了实现系统的元素的组织；</li><li>配置图(Deployment Diagram)，描述了环境元素的配置，并把实现系统的元素映射到配置上；</li><li>状态图(State Diagram)，描述了系统元素的状态条件和响应；</li><li>时序图(Sequence Diagram)，按时间顺序描述系统元素间的交互；</li><li>协作图(Collaboration Diagram)，按照时间和空间顺序描述系统元素间的交互和它们之间的关系；</li><li>活动图(Activity Diagram)，描述了系统元素的活动；</li></ul><blockquote><p>其中类图是描述类与类之间的关系的，是UML图中最核心的。</p></blockquote><h5 id="UML作用"><a href="#UML作用" class="headerlink" title="UML作用"></a>UML作用</h5><ul><li><p>为软件系统建立可视化模型；</p></li><li><p>能够了解系统的结构和能力；</p></li><li><p>为软件系统建立构件；</p></li><li><p>为软件系统建立文档；</p></li></ul><blockquote><p>什么是模型？模型是对现实世界的形状或状态的抽象模拟和简化。<br>为什么要建模？最简单的理由：为了能够更好地理解正在开发的系统。</p></blockquote><h5 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h5><p>学习设计模式必定需要先读懂 UML 类图，下面就谈谈具体 UML 类图中的概念。类图是用于描述一组类、接口、协作以及它们之间的静态关系。在面向对象系统的建模中，类图是最为常用的图，它用来阐明系统的静态结构。事实上类是对一组具有相同属性、操作、关系和语义的对象的描述，其中对类的属性和操作进行描述时的一个最重要的细节就是它的可见性。</p><h6 id="类图的基本符号与含义"><a href="#类图的基本符号与含义" class="headerlink" title="类图的基本符号与含义"></a>类图的基本符号与含义</h6><p>1、 <strong>类(Class)</strong>：一般是用三层矩形框表示，第一层表示类的名称，第二层表示的是字段和属性，第三层则是类的方法。第一层中，如果是抽象类，需用斜体显示。</p><ul><li><p><strong>类的属性</strong>表达方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限 属性名：类型 [ = 默认值 ]</span><br></pre></td></tr></table></figure></li><li><p><strong>类的方法</strong>表达方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限  方法名称(参数列表) [ : 返回类型]</span><br></pre></td></tr></table></figure><blockquote><p>  注意：public 用    <code>+</code>  表示 ，protected 用   <code>#</code>  表示 ，private 用   <code>-</code>  表示 ，default 用   <code>~</code>  表示</p></blockquote></li></ul><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210123143148.png" alt="类图示"></p><p>2、<strong>接口(interface)</strong>：接口与类图类似，与类图的主要区别就是顶端有<code>&lt;&lt;interface&gt;&gt;</code>显示。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210123143316.png" style="zoom:50%;"  alt="接口示例图"/><p>3、类之间的关系<br>类与类一共有如下6种关系：泛化（Generalization）、实现（Realization）、组合（Composition）、聚合（Aggregation）、关联（Association）、依赖 （Dependence）。上述6种关系的强弱如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</span><br></pre></td></tr></table></figure><p><strong>类关系图示</strong></p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210123142628.png" alt="类关系图示" style="zoom:50%;" /><ul><li><p>泛化（Generalization）：表示的是类之间的继承关系，注意是子类指向父类。UML中用带空心三角箭头的实线表示泛化关系，箭头指向的是父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习"</span> + course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(Double grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现(Realization)：实现关系用一条带空心箭头的虚线表示。UML中用带空心三角箭头的虚线表示实现关系，箭头指向的是接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IWork</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">IWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组合(Composition)：是聚合的一种特殊形式，表示的是类之间更强的组合关系。他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。UML中用实心菱形头的实线来表示组合，菱形头指向整体。</p></li></ul><blockquote><p>例如公司由多个部门组成；公司不存在了，部门也将不存在了。</p></blockquote><ul><li>聚合（Aggregation）：用于表示实体对象之间的关系，表示整体由部分构成的语义。与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；聚合关系是关联关系的一种，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。UML中用空心菱形头的实线表示聚合关系，菱形头指向整体。</li></ul><blockquote><p>例如一个部门由多个员工组成，部门撤销了，人员不会消失，他们依然存在。</p></blockquote><ul><li>关联(Association)：表示的是类与类之间存在某种特定的对应关系。它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的；关联关系默认不强调方向，表示对象间相互知道。UML中用双向、单向带箭头的虚线表示关联关系，箭头两端为相互关联的两个类。</li></ul><p><strong>注</strong>：在最终代码中，关联对象通常是以成员变量的形式实现的;</p><blockquote><p>例如乘车人和车票之间就是一种关联关系。</p></blockquote><ul><li>依赖(Dependency)：表示的是类之间的调用关系。与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化；依赖关系也可能发生变化；显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。UML中用带箭头的虚线表示依赖关系，而箭头所指的则是被依赖的类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date publishDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getPublishDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> publishDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPublishDate</span><span class="params">(Date publishDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publishDate = publishDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习"</span> + course);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Student的类依赖Book类</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"阅读"</span> + book.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(Double grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：在最终代码中，依赖关系体现为<strong>类构造方法</strong>及<strong>类方法的传入参数</strong>，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210123144416.png" alt="类继承实现示例图" style="zoom:50%;" /><p><strong>关联、聚合、组合三种关系用代码表示的话，大多都是一个类是另一个类的成员变量。真正的关系只能配合语义，结合上下文才能够判断出来，而只给出一段代码让我们判断是关联、聚合还是组合关系，则是无法判断的。</strong></p><p>[1]<a href="https://zhuanlan.zhihu.com/p/24576502" target="_blank" rel="noopener">参考资料https://zhuanlan.zhihu.com/p/24576502</a><br>[2]<a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">参考资料https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;UML&quot;&gt;&lt;a href=&quot;#UML&quot; class=&quot;headerlink&quot; title=&quot;UML&quot;&gt;&lt;/a&gt;UML&lt;/h5&gt;&lt;p&gt;UML(Unified Modeling Language，统一建模语言)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="UML" scheme="https://ydstudios.gitee.io/tags/UML/"/>
    
      <category term="类图" scheme="https://ydstudios.gitee.io/tags/%E7%B1%BB%E5%9B%BE/"/>
    
      <category term="设计模式" scheme="https://ydstudios.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ的消费模式</title>
    <link href="https://ydstudios.gitee.io/post/122ee231.html"/>
    <id>https://ydstudios.gitee.io/post/122ee231.html</id>
    <published>2021-01-18T23:32:39.000Z</published>
    <updated>2021-01-18T15:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>RocketMQ 是基于发布订阅模型的消息中间件。所谓的发布订阅就是说，consumer 订阅了 broker 上的某个 topic，当 producer 发布消息到 broker 上的该 topic 时，consumer 就能收到该条消息。RocketMQ默认支持两种消费模式，分别是集群消费模式和广播消费模式，默认集群消费模式。</p><a id="more"></a><h5 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h5><p>MQ 约定使用相同 Consumer ID 的订阅者属于同一个集群，同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用），这些订阅者在逻辑上可以认为是一个消费节点。</p><blockquote><p>消费同一类消息的多个 consumer 实例组成一个消费者组，也可以称为一个 consumer 集群，这些 consumer 实例使用同一个 group name。需要注意一点，除了使用同一个 group name，订阅的 tag 也必须是一样的，只有符合这两个条件的 consumer 实例才能组成 consumer 集群。</p></blockquote><h5 id="集群消费模式"><a href="#集群消费模式" class="headerlink" title="集群消费模式"></a>集群消费模式</h5><p>当使用集群消费模式时，MQ 认为任意一条消息只需要被集群内的任意一个消费者处理即可。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210118233803.png" style="zoom:50%;" alt="集群消费模式" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"consumer1"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样也要设置NameServer地址  </span></span><br><span class="line">consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876;127.0.0.1:9876"</span>);  </span><br><span class="line"><span class="comment">// 默认就是集群消费模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.CLUSTERING); </span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置consumer所订阅的Topic和Tag，*代表全部的Tag  </span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br></pre></td></tr></table></figure><h6 id="适用场景-amp-注意事项"><a href="#适用场景-amp-注意事项" class="headerlink" title="适用场景&amp;注意事项"></a>适用场景&amp;注意事项</h6><ul><li>消费端集群化部署，每条消息只需要被处理一次。</li><li>由于消费进度在服务端维护，可靠性更高。</li><li>集群消费模式下，每一条消息都只会被分发到consumer集群内任意一个的consumer实例消费处理，如果需要被集群下所有的consumer实例消费处理，请使用广播模式。</li><li>集群消费模式下，不保证消息的每一次失败重投等逻辑都能路由到同一个consumer实例上，因此处理消息时不应该做任何确定性假设。</li></ul><h5 id="广播消费模式"><a href="#广播消费模式" class="headerlink" title="广播消费模式"></a>广播消费模式</h5><p>当使用广播消费模式时，MQ 会将每条消息推送给集群内所有消费者，保证消息至少被每个消费者消费一次。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210118233944.png" alt="广播消费模式" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"consumer1"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样也要设置NameServer地址  </span></span><br><span class="line">consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876;127.0.0.1:9876"</span>);  </span><br><span class="line"><span class="comment">// 设置为广播消费模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING); </span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置consumer所订阅的Topic和Tag，*代表全部的Tag  </span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br></pre></td></tr></table></figure><h6 id="适用场景-amp-注意事项-1"><a href="#适用场景-amp-注意事项-1" class="headerlink" title="适用场景&amp;注意事项"></a>适用场景&amp;注意事项</h6><ul><li>每条消息都需要被consumer集群内所有的consumer 实例消费一次，也就是说每条消息至少被每一个consumer 实例消费一次。</li><li>消费进度在客户端维护，出现重复的概率稍大于集群模式。</li><li>广播模式下，MQ 保证每条消息至少被每台客户端消费一次，但是并不会对消费失败的消息进行失败重投，因此业务方需要关注消费失败的情况。</li><li>广播模式下，第一次启动时默认从最新消息消费，客户端的消费进度是被持久化在客户端本地的隐藏文件中，因此不建议删除该隐藏文件，否则会丢失部分消息。</li><li>广播模式下，每条消息都会被大量的客户端重复处理，因此推荐尽可能使用集群模式。</li><li>广播模式下服务端不维护消费进度，所以服务端不提供堆积查询和报警功能。</li></ul><blockquote><p>目前仅 Java 客户端支持广播模式。</p></blockquote><p>虽然广播消费能保证集群内每个consumer实例都能消费消息，但是消费进度的维护、不具备消息重投的机制大大影响了实际的使用。因此，在实际使用中，更推荐使用集群消费，因为集群消费不仅拥有消费进度存储的可靠性，还具有消息重投的机制。而且，我们通过集群消费也可以达到广播消费的效果。</p><h5 id="使用集群模式模拟广播模式"><a href="#使用集群模式模拟广播模式" class="headerlink" title="使用集群模式模拟广播模式"></a>使用集群模式模拟广播模式</h5><p>有些场景希望一个消息需要多个消费者消费，并且也希望消费者消费失败，消息能够重新投递。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210118234035.png" alt="集群模式模拟广播消费" style="zoom:50%;" /><blockquote><p>订单支付完成通知下游系统，积分服务扣减订单使用的积分、优惠券服务将优惠券状态更新为已使用、库存服务扣减商品库存、仓库准备发货等等</p></blockquote><h6 id="适用场景-amp-注意事项-2"><a href="#适用场景-amp-注意事项-2" class="headerlink" title="适用场景&amp;注意事项"></a>适用场景&amp;注意事项</h6><ul><li>每条消息都需要被多个消费者处理，每个消费者的逻辑可以相同也可以不一样。</li><li>消费进度在服务端维护，可靠性高于广播模式。</li></ul><p>如果业务上确实需要使用广播消费，那么我们可以通过创建多个 consumer 实例，每个 consumer 实例属于不同的 consumer group，但是它们都订阅同一个 topic。</p><blockquote><p>举个例子，我们创建 4 个 consumer 实例，consumer1（属于consumerGroup1）、consumer2（属于consumerGroup 2）、consumer 3（属于consumerGroup3）和 consumer4（属于consumerGroup4），它们都订阅了 topicA ，那么当 producer 发送一条消息到 topic A 上时，由于3个consumer 属于不同的 consumer group，所以 3 个consumer都能收到消息，也就达到了广播消费的效果了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置不同的消费组名，实现集群模式模拟广播消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumerGroup 消费组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumerMessage</span><span class="params">(String consumerGroup)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(consumerGroup))&#123;</span><br><span class="line">            consumerGroup = <span class="string">"unique_group_name"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Instantiate with specified consumer group name.</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876;127.0.0.1:9870"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重要：设置消费者消息最大重试次数</span></span><br><span class="line">        <span class="comment">//consumer.setMaxReconsumeTimes(5);</span></span><br><span class="line">        <span class="comment">// Subscribe one more more topics to consume.</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register callback to execute on arrival of messages fetched from brokers.</span></span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (messages, context) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> reconsumeTimes = message.getReconsumeTimes();</span><br><span class="line">                String msgId = message.getMsgId();</span><br><span class="line"></span><br><span class="line">                SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">                String format = simpleDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">                String messageContext = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">                System.out.println(<span class="string">"消费时间："</span> + format + <span class="string">" ,消息消费次数="</span> + reconsumeTimes + <span class="string">", msgId="</span> + msgId + <span class="string">", 消息内容:"</span> + messageContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Launch the consumer instance.</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除此之外，每个 consumer 实例的消费逻辑可以一样也可以不一样，每个consumer group还可以根据需要增加 consumer 实例，比起广播消费来说更加灵活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RocketMQ 是基于发布订阅模型的消息中间件。所谓的发布订阅就是说，consumer 订阅了 broker 上的某个 topic，当 producer 发布消息到 broker 上的该 topic 时，consumer 就能收到该条消息。RocketMQ默认支持两种消费模式，分别是集群消费模式和广播消费模式，默认集群消费模式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="rocketmq" scheme="https://ydstudios.gitee.io/tags/rocketmq/"/>
    
      <category term="消费模式" scheme="https://ydstudios.gitee.io/tags/%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>系统的数据一致性到底是在说什么</title>
    <link href="https://ydstudios.gitee.io/post/e544327e.html"/>
    <id>https://ydstudios.gitee.io/post/e544327e.html</id>
    <published>2021-01-17T11:58:02.000Z</published>
    <updated>2021-02-21T14:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名程序员，你是不是经常在很多场景，例如看博客、聊天吹水等等时候听到这样一个词”系统数据一致性”，是不是有时候感觉到了迷糊，不知道这个”系统数据一致性”到底是在说什么？其实，你可能只是不明白这个词，但是你肯定在实际工作中发现、解决过这样的问题。</p><a id="more"></a><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210216175502.gif" alt="说的是啥"></p><h5 id="单体架构下系统数据一致性问题"><a href="#单体架构下系统数据一致性问题" class="headerlink" title="单体架构下系统数据一致性问题"></a>单体架构下系统数据一致性问题</h5><p>在传统的系统应用中，一般都是使用单体架构来构建系统的。即所有的功能模块都放在一起实现，打成一个WAR包部署在Tomcat中，数据一般存放在关系型数据库中，如MySQL数据库。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210117223211.png" style="zoom:50%;" alt="单体架构图" /><p>前面我说过即使这种单体架构的系统也是数据一致性的问题的，举一个电商下单的例子，用户提交完订单，系统，系统在订单表order表中写入订单金额、用户等相关数据，在订单明细order_item表中写入商品价格、购买的数量等数据，最后更新商品的库存sku信息。用户下单成功之后，系统操作了order、order_item、sku这三个数据表，对于这三个表的操作无论成功与失败，都应该是原子的，操作成功则都要成功，失败则都要一起失败。不然就会出现脏数据，数据一致性被破坏。</p><p>1、 如果操作order和order_item表成功，操作sku表失败，则会导致本应该扣减的库存没有扣减，则商品有可能出现超卖。</p><p>2、如果操作order和order_item表失败，操作sku表成功，则会导致本不应该扣减的库存扣减了，则商品有可能出现少卖。</p><p>3、如果操作order和sku表成功，order_item操作失败，则这个订单数据丢失，订单后续的操作肯定也是操作不了了。</p><p>上面只是简单的举了三种可能出现的情况，也可能会有其他的情况发生。那我们怎么避免这些情况的发生呢？其实这种问题稍微有的开发经验的同学都会想到解决方案，那就是使用数据库的事务，事务的原子性保证上述的步骤成功则一起成功，失败则一起失败。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">order</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_item;</span><br><span class="line"><span class="keyword">UPDATE</span> sku;</span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment"># ROLLBACK</span></span><br></pre></td></tr></table></figure><p><strong>在单体架构的系统下解决内部模块的数据一致性的问题，用数据库的ACID特性就能保证。</strong></p><p>单体架构的优点就是相对分布式来说开发简单，功能可以集中管理，模块之间通信没有损耗。但随着业务越来越复杂、需求越来越庞大，人们对系统响应时间、吞吐量和出现故障的时候的系统可用性的要求也越来越高！传统的单体架构系统在这种情况下暴露的缺点也越来越多，人们开始寻求转变。既然部署在一个服务器上的单体架构系统搞不定，那就多部署几台，即用多台单机节点组成集群，再用负载均衡向外提供服务。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210131220214.png" alt="集群部署" style="zoom:20%;" /><p>但是这样做还是解决不了单体架构存在的一些问题：</p><ul><li>只能使用同种语言开发，不能针对不同业务场景利用不同语言的优势开发对应的模块。</li><li>系统模块耦合性太强，系统中某一个模块出现问题，例如高并发、大数据场景或者出现bug，整个系统都会受到牵连。</li><li>某个模块发布，整个系统都要停机发布，系统所有模块都不能对外提供服务，这样无法快速响应市场需求。</li><li>集群负担大，如果想要集群，只能对整个系统进行集群，即使只有一个模块有压力。</li></ul><blockquote><p>集群(Cluster)： 系统单机部署对外服务能力出现瓶颈，则将系统进行多机部署，这些系统对外提供相同的服务，每个单机系统我们称之为节点，多个节点统一起来则可以称之为集群。</p></blockquote><h5 id="分布式架构下系统数据一致性问题"><a href="#分布式架构下系统数据一致性问题" class="headerlink" title="分布式架构下系统数据一致性问题"></a>分布式架构下系统数据一致性问题</h5><p>天下大事分久必合、合久必分！既然单体架构解决不了问题，那我们就尝试拆分系统，让专业的人做专业的事，那如何进行拆分呢？拆分一般分为水平拆分和垂直拆分。这里说的拆分并不单指数据库拆分，而是所有模块都进行拆分，每个模块都有自己的缓存、数据库等等。</p><ul><li>水平拆分指的是单一的节点无法满足性能的需求，需要进行数量上的扩展。每一个节点都具有相同的功能，每一个节点都负责一部分请求，节点们组成一个集群，对外进行提供服务。</li><li>垂直拆分指的是按照功能进行拆分，秉着”专业的人干专业的事”，把复杂的系统拆分成各个模块。模块之间通过RPC进行通信，可以做到高内聚、低耦合，每个模块独立部署和维护，可以快速迭代响应市场需求。<br>因此，分布式架构在这种背景下应运而生。</li></ul><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210131215841.png" alt="分布式架构" style="zoom:20%;" /><blockquote><p>分布式(Distributed)系统是由集中式系统逐渐演变而来。所谓的集中式系统，就是把系统中所用的功能都集中到一起，从而向外提供服务的单体应用。</p></blockquote><p>软件行业是没有银弹的，每一个被发明出来的新技术，都是一把双刃剑，都是在特定的领域解决了某些老问题，但是同时也会带来新的问题。那么微服务这种分布式架构解决了什么老问题？同时它又带来了哪些新问题呢？</p><h6 id="解决了老问题"><a href="#解决了老问题" class="headerlink" title="解决了老问题"></a>解决了老问题</h6><p>微服务这中分布式架构主要解决了单体架构存在的一些问题。</p><ul><li>各个服务可以使用不同的语言开发，可以利用不同语言的优势开发不同模块。</li><li>服务之间可以做到高内聚、低耦合。每个服务可以独立维护、部署，可以快速响应市场需求。</li><li>可以单独对某个有高并发、大流量的服务单独进行优化，不浪费资源。</li></ul><h6 id="带来了新问题"><a href="#带来了新问题" class="headerlink" title="带来了新问题"></a>带来了新问题</h6><ul><li>系统的监控难度加大。</li><li>数据的一致性成为问题。</li><li>系统的复杂度提高，系统的维护、设计成本增加，调试、纠错难度加大。</li></ul><p>新问题中的 <code>数据一致性问题</code>才是本文接下来的重点。 </p><h6 id="为啥会有这个数据一致性问题呢"><a href="#为啥会有这个数据一致性问题呢" class="headerlink" title="为啥会有这个数据一致性问题呢"></a>为啥会有这个数据一致性问题呢</h6><p>单体架构按照文中的说法，是一种不太时髦的架构方式，都能轻松解决数据一致性问题，新发明的分布式架构却又成了一个棘手的问题，这个到底是技术的进步还是技术在退步呢？哈哈😄😄(我的一点点吐槽)！！接下来我来解释一下为啥分布式系统会有这样的问题。<br>分布式系统每个功能大都部署在不同的服务器上，部署在不同国家和地区的服务器中，部署在不同的网络中，部署在不同国家和地区的网络中。这样一个需要大量的服务器共同协作，向外提供服务的系统，面临着诸多的挑战：</p><ol><li><p>良莠不齐的服务器和系统能力<br>分布式系统中的服务器，可能配置不一样，其上部署的系统可能也是由不同的程序语言、架构实现，因此处理请求的能力也就不一样。</p></li><li><p>不可靠的网络<br>如上文所说，系统中各个服务可能部署在不同国家和地区，各个服务通过网络进行通信，但是网络是不可靠的。网络经常会出现抖动、延时、分割、丢包等问题。<br>网络通信中最让人头痛的是因为网络抖动、延时等问题导致系统之间的通信出现超时：A服务向B服务发出请求，A服务没有在约定的时间内接受到B服务的响应，你不能确定B服务到底有没有处理完A服务的请求，这样的不确定性就需要我们进行重试处理，那么B服务就要解决请求幂等性问题。</p></li></ol><blockquote><p>服务器的机房发生火灾、断电等事故。<br>支付宝出现过服务器的电缆被挖断的问题。</p></blockquote><ol start="3"><li>普遍存在的单点故障<br>分布式系统为了保证故障发生的时候，系统仍然保证可用，每个模块都采用集群部署。单个节点的故障概率较低，但是节点数量达到一定规模时，系统中的节点出现故障的概率可能就变高了。</li></ol><p>分布式系统就是这样一些处在不同区域、有着不同能力和拥有单一功能的服务组成，他们通力合作才能向外提供服务，那如何保证他们的状态、信息一致并且协调有序就成了一个难题。</p><p>分布式系统就是要解决解决集中式的单体架构系统的各种缺陷，实现整个系统的 <code>高性能</code>、<code>高可用</code>、<code>可扩展</code>,但是要实现这三个目标并不容易，将系统进行拆分的过程中会出现上文中说到的问题，为了解决这些问题，诞生了很多关于分布式的基本理论，比如CAP、BASE等等。</p><blockquote><p>分布式架构有很多相关的理论和算法，这里我只说了CAP、BASE理论，其他诸如Paxos算法、Raft算法、ZAB协议等等，这些大家自己找资料看看吧！</p></blockquote><h6 id="我们先来说说CAP理论"><a href="#我们先来说说CAP理论" class="headerlink" title="我们先来说说CAP理论"></a>我们先来说说CAP理论</h6><p>这个CAP理论相信很多人都听说过，下面请允许我写下教科书般的理论内容：</p><blockquote><p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p></blockquote><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210221103440.png" alt="CAP理论的三个指标" style="zoom:40%;" /><ul><li>一致性（C）：在分布式系统中的所有数据副本，在同一时刻具有同样的值，也就是等同于所有节点访问同一份最新的数据副本。</li></ul><ol><li><p>假设系统中的某条记录是V0,客户端client向节点1发起一个写操作，将节点1中的值由V0修改成V1。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210221111239.png" alt="节点写入" style="zoom:40%;" /></li><li><p>客户端client接着从节点1读取这条记录，返回的值为V1，这样的情况就叫做满足一致性。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210221111811.png" alt="节点读取" style="zoom:40%;" /></li></ol><p>可是客户端client的读取操作，也可能被分配到节点2上，由于节点2上的数据仍然是V0，所以节点2返回的数据为V0。客户端client相同的读取操作，系统却返回两种不同的数据，这样的情况就不满足一致性了。为了消除这种情况，就要在客户端client向节点1写入V1成功之时，节点1把数据同步给节点2，将节点2中的数据也更新成V1，只有这样客户端client相同的读取操作可以得到相同的响应。</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210221112508.png" alt="节点数据同步" style="zoom:40%;" /><ul><li>可用性（A）：任何时候系统接收到读写请求，必须在正常时间内给出响应，可以返回不是最新版本的数据，但是不能超时timeout或者返回错误error。</li></ul><ul><li>分区容忍性（P）：系统中出现消息丢失或者网络分区的问题时，整个系统仍然能对外提供的服务。</li></ul><p>什么情况？这个CAP理论上来就给出三个概念或者说是指标，还说分布式系统只能满足上面两个指标。大家是不是经常听到CAP理论，但是却又不是很理解为什么CAP三个指标只能满足其中的两个，那么接下来我给大家解释一下：</p><p>就如前面的“分布式架构图”展示的一样，系统一个对外的服务涉及到多个节点通讯和交互，节点所处的网络发生分区故障的问题又无法避免，所以分布式系统中分区容错性必须要考虑，那么系统自然也不可能同时满足上面说的三个指标。</p><h6 id="分布式系统中CAP如何抉择"><a href="#分布式系统中CAP如何抉择" class="headerlink" title="分布式系统中CAP如何抉择"></a>分布式系统中CAP如何抉择</h6><p>在分布式系统内，各种因素导致分区是必然的会发生的，不考虑分区容忍性（P），一旦发生分区错误，整个分布式系统就完全无法使用了，这其实和最开始的单体应用一样有单点问题，这样的系统是和分布式架构理论是相违背的，同时也是不符合实际需要的。所以，对于分布式系统，我们只能能考虑当发生分区错误时，如何选择一致性（C）和可用性（A）。</p><p>根据一致性和可用性的选择不同，开源的分布式系统往往又被分为 CP 系统和 AP 系统。<br>当系统在发生分区故障后，客户端的任何请求都被阻塞或者超时，但是，系统的每个节点总是会返回一致的数据，则这样的系统就是 CP 系统，经典的比如 Zookeeper。<br>当系统发生分区故障后，客户端依然可以访问系统，但是获取的数据是不一致的，有的是新的数据，有的还是老数据，那么这样系统就是 AP 系统，经典的比如 Eureka。</p><p><strong>前面说分布式系统不考虑分区容忍性（P）为啥分区错误发生，系统就不能用了</strong>，这里我再解释一下：<br>不考虑分区容忍性（P），那就是选择CA。假设节点1发生了分区错误，由于可用性（A）的要求，即任何时候系统接收到读写请求，必须在正常时间内给出响应，可以返回不是最新版本的数据，但是不能超时timeout或者返回错误error。因为服务肯定的包含对数据的读取、写入、更新、删除，可是由于一致性（C）的要求，系统中所有的节点数据都要保持一致，所以写入节点1的数据无法同步到节点2，节点1得不到节点2同步数据成功的响应，则节点1可能就不能在合理的时间内,给客户端client返回正确的响应，有可能就是出现错误或者超时。那这样CA就相互矛盾，系统无法保证可用性（A）和一致性（C），系统自然是不能使用了，也就是说没有选择CA的分布式系统，而且这分区容忍性（P）必须要考虑！而且，<strong>不是一个系统选择了可用性（A）或者一致性（C），可以是其中的模块选择了可用性（A）或者一致性（C）。</strong></p><blockquote><p>Zookeeper常常有人用它作为dubbo的注册中心，Eureka作为Spring Cloud体系中的注册中心，其实对于注册中心角色来说，我觉得Eureka比Zookeeper更适合！还有一点这里我说一下，其实大部分情况下分布式系统是没有问题的，C和A两个指标都是同时满足的，只是在分区问题发生的情况下，才需要我们考虑到底是选择C还是A。</p></blockquote><p>前文说到解决单点故障的问题，我们引入了集群。在分布式系统中我们为了提高系统的可用性，也是不可避免的使用副本的机制，引入了副本则就需要同步数据到不同的副本，从而引发了副本一致性的问题。就如前面展示的“分布式架构图”中，会员、订单和产品服务都是独立部署且分别使用不同的数据库，每个服务内部又是使用数据库集群，数据在服务与服务之间、在某个服务的数据库集群中间等等的流转、同步，这些过程都是有网络、时间消耗的，一个数据从最开始的产生到它应该到的地方不会<strong>瞬时完成</strong>，而CAP理论是<strong>基于瞬时，在同一时刻任意节点都保持着最新的数据副本</strong>，它是忽略网络延迟、节点处理数据的速度的，这个在目前的技术下是不可能做到的，从这个角度来看，CAP理论实在是乐观主义了。</p><h6 id="CAP理论的缺点是什么"><a href="#CAP理论的缺点是什么" class="headerlink" title="CAP理论的缺点是什么"></a>CAP理论的缺点是什么</h6><p>CAP理论其实是有缺点的，前文也提到一些，具体的缺点如下：</p><ul><li><p>理论忽略网络延迟、节点处理数据的速度<br>CAP的理论的作者布鲁尔在定义一致性时，并没有将上述的问题考虑进去。即当事务提交之后，数据能够瞬间复制到所有节点。但实际情况下，数据从产生到复制到各个服务、各个节点，总是需要花费一定时间的。如果在相同机房可能是几毫秒，如果跨地域、跨机房，可能是几十毫秒甚至是一百多毫秒。这也就是说，CAP理论中的C在实践中是不可能完美实现的，在数据副本的同步的过程中，节点之间的数据在一个短时间内并不一致。</p></li><li><p>理论中的一致性是强一致性<br>CAP理论中的一致性的概念是，在分布式系统中的所有数据备份，在同一时刻是否同样的值，也就是等同于所有节点访问同一份最新的数据副本。在某些场景下这种强一致性要求并不是那么高。在一个日志搜集系统，在高并发、大数据的情况下，一条日志写入需要稍后一会才能在ELK中展示出来，这样是没有问题的。通过牺牲强一致性获得可用性，在一定时间之后最终数据达成一致性即可。</p></li><li><p>理论中的指标的选择和放弃并不是三选二的关系<br>CAP理论告诉我们三者只能取两个，需要放弃另外一个，这里的放弃是有一定误导作用的，因为“放弃”让很多人理解成什么也不做。实际上，CAP理论的“放弃”只是说在系统分区错误过程中，我们无法同时保证C和A，但并不意味着什么都不做。分区期间放弃C或者A，并不意味着永远放弃C和A，我们可以在分区期间进行一些操作，从而让分区故障解决后，系统能够重新达到CA的状态。最典型的就是主从数据库中主数据挂了，后面进行修复，使得重新达到CA状态。</p></li></ul><h6 id="CAP理论的改进版BASE理论"><a href="#CAP理论的改进版BASE理论" class="headerlink" title="CAP理论的改进版BASE理论"></a>CAP理论的改进版BASE理论</h6><p>由于CAP理论在定义时过于的乐观，导致他有些缺陷，于是又有大神改进了CAP理论，从而引申出理论改进版本：BASE理论。eBay的架构师Dan Pritchett根据他自身在大规模分布式系统的实践经验，提出了BASE理论。BASE理论是对CAP理论的延伸和补充，它满足CAP理论，通过牺牲强一致性获得可用性，在一定的时间窗口内，达到数据的最终一致性。</p><p>BASE理论模型包含如下三个元素：</p><ul><li>BA：Basically Available，基本可用。</li><li>S：Soft State,软状态，状态可以在一定时间内不同步。</li><li>E：Eventually Consistent，最终一致性，在一定的时间窗口内，最终数据达成一致即可。</li></ul><h6 id="Basically-Available-基本可用"><a href="#Basically-Available-基本可用" class="headerlink" title="Basically Available 基本可用"></a>Basically Available 基本可用</h6><p>BASE理论中的Basically Available 基本可用，就是系统在出现问题的时候，牺牲一部分的功能，来保障核心功能正常。这其实就是一种妥协，相当于壁虎断臂求生。<br>就像前几年的双十一淘宝，订单支付、退款直接崩掉了，后面就进行改进限流需要你多试几次才能付款、退款，再后来双十一那几天是不能申请退款的，直接就把你这个功能给关闭了，相当于服务熔断了。这就是牺牲非核心的功能，将所有的资源都用来保障核心的支付功能。</p><h6 id="Soft-State-软状态"><a href="#Soft-State-软状态" class="headerlink" title="Soft State,软状态"></a>Soft State,软状态</h6><p>允许系统在一定时间内的状态不同步，允许系统处于软状态，这个软状态其实就是中间状态。比如采用分布式架构的电商系统，用户下单完成并付款，是否支付成功，是支付系统完成的，订单系统不会等支付系统返回是否支付成功再把结果返回给客户的，而是先把订单状态设置为付款中，返回给客户，然后支付系统收到异步通知确定支付成功成功，再把状态设置为付款完成，再把付款完成信息推送给订单系统。这样，就可以提高系统的响应速度。即使这支付系统出现故障宕机了，系统重启之后可以通过定时任务补偿处理未完成的数据，然后根据数据所处的状态进行补偿处理，最终完成数据处理。付款中这个状态，就是软状态即中间状态。</p><h6 id="Eventually-Consistent，最终一致性"><a href="#Eventually-Consistent，最终一致性" class="headerlink" title="Eventually Consistent，最终一致性"></a>Eventually Consistent，最终一致性</h6><p>数据不会一直处在中间状态，就如上面的例子所说，处于中间状态的数据会有采用类似定时任务一样的补偿处理，将数据修复成正确的状态，最终数据达成一致。</p><h5 id="重说“带来了新问题”"><a href="#重说“带来了新问题”" class="headerlink" title="重说“带来了新问题”"></a>重说“带来了新问题”</h5><p>前文说到分布式架构解决了单体架构的一些问题，但是同时也带来了一些新的问题，这里我们着重说一下，本来不是大问题的“数据一致性”问题。前面举了一个电商系统中的经典案例：下订单与扣库存。单体架构的应用我们直接用数据库事务的ACID特性就可解决，但是采用分布式架构的系统就没有那么好解决了，我们先说一下在分布式架构下的系统是如何完成“下订单与扣库存”的，这里就不画图了直接用伪代码来展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOrder</span><span class="params">(OrderDto orderDto)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1.保存订单</span></span><br><span class="line">  orderService.saveOrder(orderDto);</span><br><span class="line">  <span class="comment">// 2.扣除产品库存</span></span><br><span class="line">  inventoryService.deductInventory(orderDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这步骤一保存订单是在订单系统中执行，步骤二扣除产品库存是在库存系统执行，这个下订单与扣库存两个步骤分别涉及到了两个系统，使用RPC的方式和两个系统进行交互。由于这两个步骤不是原子的，不能保持一致的话会导致很多的问题：</p><ul><li>比如先保存订单成功，然后扣除产品库存失败，那订单就要回滚处理；</li><li>如果先扣除产品库存成功，然后保存订单失败，那库存就要回滚；</li><li>或者说先保存订单然后扣除产品库存时请求超时，其实库存已经扣除成功等等问题。</li></ul><p>这些问题你不解决，就有可能导致产品多卖或者是产品出现少卖，不管出现哪个都会造成资损或者客诉，任何一种情况都不是我们想发生的。</p><p>由于库存系统和订单系统分别使用各自的数据库，那原先使用数据库事务的ACID特性保证数据的一致性就不能奏效了，分布式架构的系统就产生了数据一致性的问题，这种跨多个数据库的事务问题，其实就是分布式事务问题。<strong>要解决分布式架构的系统的数据一致性问题，其实就是解决分布式事务的问题。</strong></p><p>目前业界也出现了很多分布式事务的解决方案，例如两阶段提交2PC、三阶段提交3PC、TCC还有基于可靠消息等方案，他们用不同的方案实现分布式事务，解决数据一致性的问题，这里就不再详述。</p><blockquote><p>基于可靠消息解决分布式事务，解决数据一致性的问题，其中一种方案叫做本地消息表，这种方案名称大家可能不知道，但是你很有可能这样做过，这个后面的文章再细说。</p></blockquote><p>[参考资料：《分布式服务架构 原理、设计与实践》 李艳鹏 杨彪 著 ]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名程序员，你是不是经常在很多场景，例如看博客、聊天吹水等等时候听到这样一个词”系统数据一致性”，是不是有时候感觉到了迷糊，不知道这个”系统数据一致性”到底是在说什么？其实，你可能只是不明白这个词，但是你肯定在实际工作中发现、解决过这样的问题。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="分布式" scheme="https://ydstudios.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="一致性" scheme="https://ydstudios.gitee.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="CAP理论" scheme="https://ydstudios.gitee.io/tags/CAP%E7%90%86%E8%AE%BA/"/>
    
      <category term="BASE理论" scheme="https://ydstudios.gitee.io/tags/BASE%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>2020年的年终小结</title>
    <link href="https://ydstudios.gitee.io/post/b4e52eb3.html"/>
    <id>https://ydstudios.gitee.io/post/b4e52eb3.html</id>
    <published>2021-01-11T20:06:57.000Z</published>
    <updated>2021-01-17T03:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>2020年真的是一个神奇年度，这一年作为吃瓜群众的我，见到了太多牛鬼蛇神。</p><a id="more"></a><h5 id="周边环境的不平凡"><a href="#周边环境的不平凡" class="headerlink" title="周边环境的不平凡"></a>周边环境的不平凡</h5><p>新冠疫情席卷全球，中国政府的封闭管理效果显著，生产活动得到了有序恢复。6月16日在加勒万河谷地区中印发生摩擦事件，印军被威武的解放军暴揍后死亡20人。老美的经济波动，股市破纪录的四次熔断，川建国的美国总统之旅在11月结束。北京时间12月17日1时59分，嫦娥五号返回器在内蒙古四子王旗成功着陆，标志着我国首次地外天体采样返回任务圆满完成。</p><p><strong>国内疫情概览</strong><br><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210111215555.png" alt="国内疫情概览" style="zoom:50%;" /></p><p><strong>国外疫情概览</strong></p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210111215635.png" alt="国外疫情概览" style="zoom:50%;" /><h5 id="个人生活"><a href="#个人生活" class="headerlink" title="个人生活"></a>个人生活</h5><p>趁着国庆放假又去了一趟合肥，这一次吃上了丈母娘亲手做的红烧鱿鱼，味道真是不错！国庆的第四天和女朋友去了黄山市旅游，爬了莲花峰、去了大峡谷还吃了臭鳜鱼。黄山的风景真是不错，山峰陡峭、景色秀丽。因为想看看黄山的日出，所以我们在山上住了一晚。第二天早上我们急急忙忙的起床，穿上酒店里面厚厚大大棉衣，外面下着小雨、刮着冷风还有大雾，自然也就没有看到日出。听宾馆的服务人员说山上365天有360天都在下雨，你要是能看到日出，证明你的运气真是爆棚！<br><strong>莲花峰拍照留念</strong><br><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210113221351.png" alt="莲花峰拍照留念" style="zoom:50%;" /></p><h5 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h5><p>在2020年的最后几天有幸和几位大佬聊了聊，发现大佬就是大佬，不管是在技术上还是在思想上都远远超过我。大佬有句话关于系统设计的话，我甚是赞同，话的内容大致如下：</p><blockquote><p> 业务的诉求转化成产品的需求，产品的需求转化成技术的要求，最终转换成系统的能力。</p></blockquote><p>一句话就说出了系统设计的过程和目的，言简意赅呀！谈话中大佬还指出了我的一些问题，让我以后多多关注一下系统设计，要想法子去提高自己的核心竞争力。我事后也想了想，我在知识总结、系统设计和语言组织能力上都有不足，新的一年要注意这几个方面的锻炼。知识总结这方面，我决定后面多多总结，把知识串联起来，多输出一些博客。语言组织能力我想我平时多注意一下，然后适当的锻炼锻炼后面应该会渐渐变好。系统设计能力这方面的话，只能看看工作上有没有类似的机会了，这个光靠想应该不行，还是得实践见真知！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年真的是一个神奇年度，这一年作为吃瓜群众的我，见到了太多牛鬼蛇神。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="年终" scheme="https://ydstudios.gitee.io/tags/%E5%B9%B4%E7%BB%88/"/>
    
      <category term="感悟" scheme="https://ydstudios.gitee.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>巧用二进制表示不同的状态</title>
    <link href="https://ydstudios.gitee.io/post/b7145215.html"/>
    <id>https://ydstudios.gitee.io/post/b7145215.html</id>
    <published>2021-01-06T21:28:00.000Z</published>
    <updated>2021-01-07T15:21:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发的过程中会遇到这种场景，在系统的权限、选项设置，只有两种状态开启或者关闭。</p><a id="more"></a><p>具体我们以哔哩哔哩的隐私设置为例：<br><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210106221129.png" alt="隐私设置" style="zoom:50%;" /></p><p>这么几种开关你会怎么设计数据表？按照正常的操作针对一个开关添加字段进行表示。可是后续就会有下面的这样的情况：</p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210106223014.png"  alt="隐私设置"  style="zoom:50%;" /><p>哈哈，产品需求迭代增加了后续几种开关，你准备怎么做？还是继续增加字段进行保存么？增加字段进行保存也是可以的，但是感觉上会有那么一点点low！新的开关出现增加字段进行保存，既要修改表结构，又要改实体属性，还是比较麻烦的！所以，对于这种类似的需求，我们要有一个良好的设计来应对，那我们如何解决呢？</p><p>用过linux系统的同学会知道这样一个知识点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chomd 777 something</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可读r=4，可写w=2，可执行x=1，即 二进制的001代表可执行，010代表可写，100代表可读</span></span><br></pre></td></tr></table></figure><p>上面的linux命令代表把something的权限修改成所有者、用户组、其他用户都可以进行可读、可写、可执行。</p><table><thead><tr><th>数字</th><th>权限</th><th>rwx</th><th>二进制</th></tr></thead><tbody><tr><td>7</td><td>读 + 写 + 执行</td><td>rwx</td><td>111</td></tr><tr><td>6</td><td>读 + 写</td><td>rw-</td><td>110</td></tr><tr><td>5</td><td>读 + 执行</td><td>r-x</td><td>101</td></tr><tr><td>4</td><td>只读</td><td>r–</td><td>100</td></tr><tr><td>3</td><td>写 + 执行</td><td>-wx</td><td>011</td></tr><tr><td>2</td><td>只写</td><td>-w-</td><td>010</td></tr><tr><td>1</td><td>只执行</td><td>–x</td><td>001</td></tr><tr><td>0</td><td>无</td><td>—</td><td>000</td></tr></tbody></table><p>用的是二进制的001代表可执行，010代表可写，100代表可读，那么只需要3位二进制数即可表示这三种状态的混合搭配。借用这种思想，我们来解决上述的问题，我们用一个int类型字段就可以表示上述所有的状态开关。<strong>使用2的次幂值代表一种状态</strong>，比如我们用</p><ul><li><p>2的零次方 $2^{0}$ = 1 表示打开我的收藏</p></li><li><p>2的一次方 $2^{1}$ = 2 表示打开追番追剧</p></li><li><p>2的二次方 $2^{2}$ = 4 表示打开订阅标签</p></li><li><p>2的三次方 $2^{3}$ = 8 表示打开最近投币的视频</p></li><li><p>2的四次方 $2^{4}$ = 16 表示打开个人资料</p></li><li><p>2的五次方 $2^{5}$ = 32 表示打开最近玩过的游戏</p><blockquote><p>博客使用hexo搭建，采用默认的landscape主题不支持LaTeX 公式，所以上面的次方公式显示的有问题。 </p></blockquote></li></ul><table><thead><tr><th>二进制</th><th>数字（十进制）</th><th>含义</th></tr></thead><tbody><tr><td>000 000</td><td>0</td><td>全部关闭</td></tr><tr><td>000 001</td><td>1</td><td>开启我的收藏</td></tr><tr><td>000 011</td><td>3</td><td>开启我的收藏、追番追剧</td></tr><tr><td>000 111</td><td>7</td><td>开启我的收藏、追番追剧、订阅标签</td></tr><tr><td>111 111</td><td>63</td><td>全部开启</td></tr></tbody></table><p><strong>其实就是用bit位表示开启或者关闭，如果是1表示开启，0表示关闭。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">或运算：bit位上有1为1。例如：2 | 1 == 0000 0010 | 0000 0001 == 3</span><br><span class="line">与运算：bit位都为1才为1。 例如 5 &amp; 2 == 0000 0101 &amp; 0000 0010 == 0</span><br><span class="line">异或运算：0^0=0；  0^1=1；  1^0=1；   1^1=0；即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</span><br></pre></td></tr></table></figure><h6 id="那我们就来编码实现上述功能："><a href="#那我们就来编码实现上述功能：" class="headerlink" title="那我们就来编码实现上述功能："></a>那我们就来编码实现上述功能：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydstudio.flashsale.<span class="keyword">module</span>.business.bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘洋 Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MemberOption &#123;</span><br><span class="line"></span><br><span class="line">    FAVORITE(<span class="number">1</span>, <span class="string">"我的收藏"</span>, <span class="number">1</span>),</span><br><span class="line">    FOLLOW(<span class="number">2</span>, <span class="string">"追番追剧"</span>, <span class="number">2</span>),</span><br><span class="line">    SUBSCRIBE(<span class="number">3</span>, <span class="string">"订阅标签"</span>, <span class="number">4</span>),</span><br><span class="line">    VIDEO(<span class="number">4</span>, <span class="string">"最近投币视频"</span>, <span class="number">8</span>),</span><br><span class="line">    PROFILE(<span class="number">5</span>, <span class="string">"个人资料"</span>, <span class="number">16</span>),</span><br><span class="line">    GAME(<span class="number">6</span>, <span class="string">"最近玩的游戏"</span>, <span class="number">32</span>),;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有某个tag</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tags 拥有的tag集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTag</span><span class="params">(<span class="keyword">int</span> tags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (tags &amp; <span class="keyword">this</span>.tag) == <span class="keyword">this</span>.tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tags = <span class="number">37</span>;</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(MemberOption.FAVORITE.hasTag(tags));</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(MemberOption.SUBSCRIBE.hasTag(tags));</span><br><span class="line">        <span class="comment">// false</span></span><br><span class="line">        System.out.println(MemberOption.VIDEO.hasTag(tags));</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">        System.out.println(MemberOption.GAME.hasTag(tags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="开启我的收藏和最近玩的游戏，其他选项都关闭，则计算过程如下："><a href="#开启我的收藏和最近玩的游戏，其他选项都关闭，则计算过程如下：" class="headerlink" title="开启我的收藏和最近玩的游戏，其他选项都关闭，则计算过程如下："></a>开启我的收藏和最近玩的游戏，其他选项都关闭，则计算过程如下：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 我的收藏 tag = 1 最近玩的游戏 tag = 32</span><br><span class="line">tags = <span class="number">1</span> + <span class="number">32</span> = <span class="number">33</span> </span><br><span class="line">或者采用位或运算 tags = <span class="number">1</span> | <span class="number">32</span> = <span class="number">33</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 计算状态位</span></span><br><span class="line"><span class="comment">  * tags: 已有状态位</span></span><br><span class="line"><span class="comment">  * values: 需要添加的状态值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">addTag</span><span class="params">(<span class="keyword">int</span> tags, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> value : values) &#123;</span><br><span class="line">    tags |= value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="关闭最近玩的游戏，则计算过程如下："><a href="#关闭最近玩的游戏，则计算过程如下：" class="headerlink" title="关闭最近玩的游戏，则计算过程如下："></a>关闭最近玩的游戏，则计算过程如下：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">上面计算的tags = <span class="number">33</span> ，最近玩的游戏 tag = <span class="number">32</span></span><br><span class="line">关闭最近玩的游戏，</span><br><span class="line">tags = <span class="number">33</span> ^ <span class="number">32</span> = <span class="number">0010</span> <span class="number">0001</span> ^ <span class="number">0010</span> <span class="number">0000</span> = <span class="number">0000</span> <span class="number">0001</span> = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除状态位</span></span><br><span class="line"><span class="comment">   * tags: 已有状态位</span></span><br><span class="line"><span class="comment">   * tag: 需要移除的状态值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">delTag</span><span class="params">(<span class="keyword">int</span> tags, <span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tags和value与运算不等于tag，说明没有开启tag对应的选项，则直接返回tags</span></span><br><span class="line">  <span class="keyword">if</span> ((tags &amp; tag) != tag) <span class="keyword">return</span> tags;</span><br><span class="line">  <span class="keyword">return</span> tags ^ tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="判断是否开启最近玩的游戏，则计算过程如下："><a href="#判断是否开启最近玩的游戏，则计算过程如下：" class="headerlink" title="判断是否开启最近玩的游戏，则计算过程如下："></a>判断是否开启最近玩的游戏，则计算过程如下：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">上面计算的tags = <span class="number">33</span> ，最近玩的游戏 tag = <span class="number">32</span></span><br><span class="line"> <span class="number">33</span> &amp; <span class="number">32</span> = <span class="number">0010</span> <span class="number">0001</span> &amp; <span class="number">0010</span> <span class="number">0000</span> = <span class="number">0010</span> <span class="number">0000</span> = <span class="number">32</span> (<span class="number">0010</span> <span class="number">0000</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有某个tag</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tags 拥有的tag集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag 待判断的tag</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTag</span><span class="params">(<span class="keyword">int</span> tags, <span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (tags &amp; tag) == tag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="如何用SQL查询开启最近玩的游戏选项的用户"><a href="#如何用SQL查询开启最近玩的游戏选项的用户" class="headerlink" title="如何用SQL查询开启最近玩的游戏选项的用户"></a>如何用SQL查询开启最近玩的游戏选项的用户</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MySQL也是支持位运算的，其他的数据库应该也是支持的</span></span><br><span class="line"><span class="keyword">select</span> member_id <span class="keyword">from</span> table_name <span class="keyword">where</span> member_option &amp; <span class="comment">#&#123;option&#125; = #&#123;option&#125;</span></span><br></pre></td></tr></table></figure><p>就这样我们就可以用一个int型字段保存4*8 = 32个状态位（无符号的情况下）,看起来还是很不错，运算的效率高，只用一个字段可以保存较多的状态。缺点嘛也是有的，就是可读性差，不能很直观的看出到底有哪些状态。其实这种方法可以用一个字段表示多种状态，例如 订单一般有支付状态：待支付 1 、支付中 2 、支付成功4 、支付失败8和发货状态：待发货16、已发货32、在途64、已收货128，这样的话用一个orderStatus来表示这两种状态：支付成功4 + 待发货16 = 4 | 16 = 20，也是可以的但是如上面所说，优缺点都有，看你的实际情况进行选择了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在开发的过程中会遇到这种场景，在系统的权限、选项设置，只有两种状态开启或者关闭。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="二进制" scheme="https://ydstudios.gitee.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="位运算" scheme="https://ydstudios.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Lua脚本在秒杀场景下的使用</title>
    <link href="https://ydstudios.gitee.io/post/d958d490.html"/>
    <id>https://ydstudios.gitee.io/post/d958d490.html</id>
    <published>2020-12-24T22:40:10.000Z</published>
    <updated>2021-01-06T13:07:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在秒杀这种高并发、大流量的场景下，利用数据库进行库存扣减、数据查询这种想法就不要考虑了。你要是有这种想法，劝你早点放弃，P0事故一定在等着你。之前用Lua脚本实现秒杀场景下的库存扣减感觉很不错，配合Redis秒杀效果杠杠的！Redis 2.6 版本通过内嵌支持 Lua 环境，会单线程原子性执行 Lua 脚本，保证 Lua 脚本在处理的过程中不会被任意其它请求打断。</p><a id="more"></a><p>先说一下大概的情况，在上秒杀的商品的时候，就直接将产品的库存、用户每人的限购的数量等信息直接用Hash数据类型保存在Redis的键goods_商品ID中，不设置缓存有效时间。用户的购买记录用zset保存purchase_goods_商品id中，用商品的ID作为key，用户唯一标识为member,购买的数量为score。相关的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化一些秒杀产品</span></span><br><span class="line">hmset seckill:goods:1000 goodsId 1000 name 戴森吸尘器V10Motorhead入门款,性价比之选 stock 10 purchaseLimit 1   price 999.99 startSaleTime 1614137304000 endSaleTime 1614140904000  coverImage https://dss2.bdstatic.com/8_V1bjqh_Q23odCf/pacific/1955446237.png</span><br><span class="line"></span><br><span class="line">hmset seckill:goods:2000 goodsId 2000 name 戴森无叶风扇 stock 15 purchaseLimit 1  price 1999.99 startSaleTime 1640406504000 endSaleTime 1614140904000  coverImage https://dss2.bdstatic.com/8_V1bjqh_Q23odCf/pacific/1957729018.png</span><br><span class="line"></span><br><span class="line">hmset seckill:goods:3000 goodsId 3000 name 戴森智能照明灯 stock 32 purchaseLimit 1 price 299.99 startSaleTime 1640406504000 endSaleTime 1614140904000  coverImage https://dss2.bdstatic.com/8_V1bjqh_Q23odCf/pacific/1947896752.jpg</span><br><span class="line"></span><br><span class="line">hmset seckill:goods:4000 goodsId 4000 name 戴森AM10除菌加湿器 stock 15  purchaseLimit 1   price 1299.99 startSaleTime 1640752104000 endSaleTime 1610166504000 coverImage https://dss2.bdstatic.com/8_V1bjqh_Q23odCf/pacific/1947896752.jpg</span><br><span class="line"></span><br><span class="line">hmset seckill:goods:5000 goodsId 5000 name 苹果AirPodsMax  stock 13 purchaseLimit 1   price 2099.99 startSaleTime 1640752104000 endSaleTime 1610166504000 coverImage  https://dss2.bdstatic.com/8_V1bjqh_Q23odCf/pacific/1983533493.jpg</span><br></pre></td></tr></table></figure><p>具体的Lua脚本编写过程比较简单，稍微熟悉一下就能看懂了，具体内容如下（临时重写的没有优化，凑合着看吧）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--KEYS[1] 对应商品的购买记录:purchase_goods_1000</span></span><br><span class="line"><span class="comment">--KEYS[2] 商品的key:goods_1000</span></span><br><span class="line"><span class="comment">--ARGV[1] 购买人唯一标识memberId:2000</span></span><br><span class="line"><span class="comment">--ARGV[2] 购买数量number: 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> goodsExists=redis.call(<span class="string">'EXISTS'</span>, KEYS[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> goodsExists == <span class="number">0</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> <span class="comment">-- 产品不存在</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> goodsStockExists=redis.call(<span class="string">'hexists'</span>, KEYS[<span class="number">2</span>], <span class="string">'stock'</span>)</span><br><span class="line"><span class="keyword">if</span> goodsStockExists == <span class="number">0</span> </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="comment">-- 代表产品库存不存在</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">-2</span></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="comment">--用户限购数量</span></span><br><span class="line"><span class="keyword">local</span> purchaseLimitExists=redis.call(<span class="string">'hexists'</span>, KEYS[<span class="number">2</span>], <span class="string">'purchaseLimit'</span>)</span><br><span class="line"><span class="keyword">if</span> purchaseLimitExists == <span class="number">0</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"><span class="comment">-- 商品限购数量不存在</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--用户限购数量</span></span><br><span class="line"><span class="keyword">local</span> purchaseLimit=<span class="built_in">tonumber</span>(redis.call(<span class="string">'hget'</span>, KEYS[<span class="number">2</span>], <span class="string">'purchaseLimit'</span>))</span><br><span class="line"><span class="comment">--用户已经购买的数量</span></span><br><span class="line"><span class="keyword">local</span> purchasedNumber=redis.call(<span class="string">'ZSCORE'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">--购买数量不存在则默认为0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> purchasedNumber</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   purchasedNumber = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 用户现在要购买的数量</span></span><br><span class="line"><span class="keyword">local</span> nowPurchasedNumber = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 用户将要购买的总数量</span></span><br><span class="line"><span class="keyword">local</span> totalPurchaseNumber = nowPurchasedNumber+purchasedNumber</span><br><span class="line"><span class="keyword">if</span> purchaseLimit &lt; totalPurchaseNumber</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"><span class="comment">-- 用户购买数量超过了限购数量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-4</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> stock=<span class="built_in">tonumber</span>(redis.call(<span class="string">'hget'</span>, KEYS[<span class="number">2</span>], <span class="string">'stock'</span>))</span><br><span class="line"><span class="keyword">if</span> stock &lt;= <span class="number">0</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">  <span class="comment">-- 库存为0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> stock &lt; nowPurchasedNumber</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"> <span class="comment">-- 库存不足</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--扣减商品库存</span></span><br><span class="line">redis.call(<span class="string">'hincrby'</span>, KEYS[<span class="number">2</span>], <span class="string">'stock'</span>, -nowPurchasedNumber)</span><br><span class="line"><span class="comment">-- 更新用户的总购买数量</span></span><br><span class="line">redis.call(<span class="string">'zadd'</span>,KEYS[<span class="number">1</span>], totalPurchaseNumber, ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 用户购买成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>尽管Lua会提供字符串和数字的自动转换，但是更好还是转换一下。tonumber就是把字符串数字转换成数字的函数。</li><li>redis.call是用来执行redis函数的方法。</li><li>上述的脚本可以通过EVAL、EVALSHA或者redis-cli 参数的形式执行。但是上面的脚本已经格式化了，最好还是以后面的方式运行。</li><li>Lua的注释是以 – 开头作为单行注释</li></ol></blockquote><p>具体执行演示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sam-Mac:Downloads Sam$ rediscli --eval  /Users/sam/Downloads/seckill.lua  purchase_goods_3000 seckill:goods:1000 , 202 1</span><br><span class="line">(integer) 0</span><br><span class="line">Sam-Mac:Downloads Sam$</span><br></pre></td></tr></table></figure><ul><li><p>–eval参数是告诉rediscli(这个是自定义redis-cli命令的地址)读取并运行后面的Lua脚本。</p></li><li><p>/Users/sam/Downloads/seckill.lua 是脚本的位置，后面跟着是传给Lua脚本的参数。</p></li><li><p>逗号”,”前的purchase_goods_3000 seckill:goods:1000 是要操作的键，可以在脚本中用KEYS[1]、KEYS[2]获取，逗号”,”后面的202和1是参数，在脚本中能够使用ARGV[1]和ARGV[2]获得。</p></li></ul><blockquote><p>注意”,”逗号两边的空格不能省略，否则会出错</p></blockquote><p>在Redis中调用Lua脚本，也是可以调试的。Redis 从 v3.2.0 开始支持 Lua debugger，可以加断点、print 变量信息、展示正在执行的代码。可以在命令中添加–ldb进行调试，这个参数是开启 Lua dubegger 的意思，这个模式下Redis会 fork 一个进程进入隔离环境，不会影响Redis正常提供服务，但调试期间，原始 redis 执行命令、脚本的结果也不会体现到 fork 之后的隔离环境之中。因此呢，还有另外一种调试模式 –ldb-sync-mode，也就是前面提到的同步模式，这个模式下，会阻塞 redis 上所有的命令、脚本，直到脚本退出，完全模拟了正式环境使用时候的情况，使用的时候务必注意这点。</p><p>添加和删除断点很简单，只需使用<code>b 1 2 3 4</code>在第1,2,3,4行添加<code>b 0</code>断点。该命令将删除所有断点。可以使用as参数删除选定的断点，即我们要删除的断点所在的行，但前缀为减号。例如<code>b -3</code>，从第3行中删除断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sam-Mac:Downloads Sam$ rediscli --ldb --eval  /Users/sam/Downloads/seckill.lua  purchase_goods_3000 seckill:goods:1000 , 202 1</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201224234757.png" alt="调试Lua脚本"></p><p>上面就是今日文章的所以内容，这样看起来是不是觉得Lua脚本也是挺容易的吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在秒杀这种高并发、大流量的场景下，利用数据库进行库存扣减、数据查询这种想法就不要考虑了。你要是有这种想法，劝你早点放弃，P0事故一定在等着你。之前用Lua脚本实现秒杀场景下的库存扣减感觉很不错，配合Redis秒杀效果杠杠的！Redis 2.6 版本通过内嵌支持 Lua 环境，会单线程原子性执行 Lua 脚本，保证 Lua 脚本在处理的过程中不会被任意其它请求打断。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="https://ydstudios.gitee.io/tags/redis/"/>
    
      <category term="lua" scheme="https://ydstudios.gitee.io/tags/lua/"/>
    
      <category term="秒杀" scheme="https://ydstudios.gitee.io/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>利用MySQL的IGNORE关键字避免重复插入的骚操作你见过么</title>
    <link href="https://ydstudios.gitee.io/post/cef7abb0.html"/>
    <id>https://ydstudios.gitee.io/post/cef7abb0.html</id>
    <published>2020-12-16T21:57:39.000Z</published>
    <updated>2021-02-27T08:59:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在实际开发中总有这样的需求，表里的数据要保持唯一，所以我们开发中经常都是先查询这样的数据有没有，有的话跳过，没有的话再插入，然后在能表示数据记录唯一的列上加上唯一索引进行兜底。虽然有的同学基本上也是这么做的，但是又稍微的做了一点其他的骚操作😄😄😄。</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 😄😄😄 骚操作, 当有重复记录就会忽略错误返回影响行数0</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> tableName <span class="keyword">VALUES</span> ()</span><br></pre></td></tr></table></figure><p>有的同学是这么想的，在高并发的情况下，先查询再插入的话是有并发的问题的，我直接在重复插入的时候屏蔽错误，不用捕获或者抛出异常，直接用 insert 的返回影响行数来判断插入是否成功。这样的做法看上去感觉没啥问题，其实还是有很大的问题的。</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210227164552.gif" alt="我太聪明了"></p><h6 id="语义上的不正确"><a href="#语义上的不正确" class="headerlink" title="语义上的不正确"></a>语义上的不正确</h6><p>你在表中定义了唯一索引，插入重复的记录直接屏蔽了错误，这就造成异常被吞掉了，导致功能有数据重复的bug就无法通过异常日志来定位。</p><h6 id="破坏MySQL主从的数据一致性"><a href="#破坏MySQL主从的数据一致性" class="headerlink" title="破坏MySQL主从的数据一致性"></a>破坏MySQL主从的数据一致性</h6><p>在说这个IGNORE是如何造成 MySQL 主从数据不一致的原因之前，我们先说说 MySQL 中的一个作为开发很少听说的一个表级锁：<strong>AUTO-INC锁</strong>（即自增锁）。</p><p>在使用 MySQL 的过程中，我们可以为表的某一列添加 AUTO_INCREMENT属性，在插入记录时该列可以不指定，MySQL 会自动为该列赋予一个递增的值。MySQL 自动给AUTO_INCREMENT修饰的列进行递增赋值的实现方式主要有以下两个：</p><ul><li><p>采用 AUTO_INC锁，在执行插入语句时就加一个表级别的AUTO_INC锁，然后为每条待插入的记录分配递增值。在语句执行结束后，再把AUTO_INC锁释放。所以在一个事务持有AUTO_INC锁的过程中，其他插入语句都要阻塞，从而保证一个语句分配的递增值是连续的。</p></li><li><p>采用一个轻量级的锁，在为INSERT语句生成递增值时获取这个轻量级的锁，然后在生成本次插入语句需要用到的递增值后就把轻量级锁释放掉，不需要等到整个插入语句执行完才释放锁。</p></li></ul><p>如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比如 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(a) <span class="keyword">VALUES</span> (<span class="string">'1'</span>),(<span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><p>此时我们可以在执行前就确定要插入2条记录，那么一般采用轻量级锁的方式对 AUTO_INCREMENT修饰的列进行赋值，用这种方式可以避免锁定表，可以提高插入性能。</p><blockquote><p>Mysql 提供了一个名为 innodb_atuoinc_lock_mode 的系统变量，来控制 MySQL使用上述的两种方式中的哪一中来为 AUTO_INCREMENT修饰的列进行赋值。</p></blockquote><ul><li>当 innodb_atuoinc_lock_mode 的值为0时，一律采用AUTO_INC锁；</li><li>当 innodb_atuoinc_lock_mode 的值为1时，两种方式混合使用，插入记录确定时采用轻量级锁，不确定时使用AUTO_INC锁。</li><li>当 innodb_atuoinc_lock_mode 的值为2时，一律采用轻量级锁；<blockquote><p>当innodb_autoinc_lock_mode=0时，只有插入成功之后，AUTO_INCREMENT 值才会递增，插入失败不会递增。<br>当innodb_autoinc_lock_mode=1时，无论插入是否成功，AUTO_INCREMENT的值都会递增。<br>当innodb_atuoinc_lock_mode为2时，可能会造成不同事物中的插入语句为AUTO_INCREMENT修饰的列生的值是交叉的，这在主从复制的场景是不安全的。<sup>[1]</sup></p></blockquote></li></ul><p>我查看过我目前负责的系统，MySQL 采用的是主从模式，隔离级别设置的是读已提交(Read Committed)，binlog的格式设置为 ROW， innodb_atuoinc_lock_mode设置的是1，也就是说无论插入成功与否 AUTO_INCREMENT 的值都会递增。在本地搭建的主从模式的 mysql（安装本人博客中之前的文章搭建的 MySQL主从） 中的master库 新建一个如下的表：</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201218232257.png" alt="表结构和对应的自增值"></p><p>查看一下 slave3307数据库中对应的表结构和自增值：确定和 master 一致</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201218232602.png" alt="slave3307数据库中对应的表结构和自增值"></p><p>在 master库上执行 show master status 查看 master 的binglog 信息：</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201218232902.png" alt="master 的binglog 信息"></p><p>在 master 库上连续执行下图的三个 SQL，观察  master 与 salve 的情况。</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201218233357.png" alt="三个 SQL"></p><p>master 的表的AUTO_INCREMENT值已经发生了变化，如下图：</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201218233623.png" alt="表的自增值发生了变化"></p><p>master 的 binglog 如下图：</p><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201218233929.png" alt="master 的 binglog"></p><p>我们从上面两个图可以发现，使用ignore关键字，尽管待插入的记录因为唯一键冲突而没有插入成功，但AUTO_INCREMENT值却递增了，而且 binlog 中也没有 INSERT IGNORE 语句日志，这很明显导致数据库 slave 不会执行该语句，导致数据库 slave数据库中的表的主键和 master 数据库中的表主键不一致！</p><p>我们由此可以猜测一下 IGNORE 的实现机制：</p><p>1、尝试把新行插入到表中 ；</p><p>2、如果插入成功则返回正常的影响行数；如果唯一键冲突（错误）则忽略该错误，返回影响行数为0 ；</p><blockquote><p>InnoDB表insert语句主要分为三种类型：</p><ul><li><p>Simple insert(简单插入)<br>可以通过语句预先判断插入的行数。包括不包含子查询的单行、多行 <code>INSERT</code> 和 <code>REPLACE</code> 语句，还有语句<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</p></li><li><p>Bulk inserts(大量插入)<br>无法通过语句预先判断插入的行数。包括<code>INSERT ... SELECT</code>、<code>REPLACE ... SELECT &gt;</code>和<code>LOAD DATA</code>语句。InnoDB每处理一行才会为 AUTO_INCREMENT 列分配一个值。</p></li><li><p>Mixed-mode inserts(混合模式插入)<br>在简单插入语句当中，有的行有为自增列指定值，而有的行没有为自增列指定值。</p></li></ul></blockquote><p><strong>例如:混合模式插入</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># id列作为自增列</span></span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (<span class="keyword">id</span>,c1,c2) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="string">'a'</span>), (<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="string">'b'</span>), (<span class="number">10</span>,<span class="number">5</span>,<span class="string">'c'</span>), (<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="string">'d'</span>) ;</span><br></pre></td></tr></table></figure><p>在实际生产环境中业务上是需要当出现唯一键冲突时发生重复要抛出异常而不是吞掉异常，这个前面也有说到。此外，由上面的执行过程可知，我们期望插入的记录因为唯一键冲突而没有插入成功，但AUTO_INCREMENT字段值却递增了。因为插入语句并未执行成功，在binlog中并不会有执行记录，这意味着从库的AUTO_INCREMENT字段值不会递增，即主库和从库的AUTO_INCREMENT值出现了不一致。这带来的问题是，后续如果因为主库发生故障而发生主从切换，从库的AUTO_INCREMENT值落后于主库，就会导致一段时间内在原从库现主库插入的数据在原主库现从库上因为AUTO_INCREMENT主键冲突而导致插入失败，这个肯定是用<code>INSERT IGNORE</code>之前没有想到的，所以建议在实际开发中不要使用此种骚操作! 😄😄😄</p><ul><li>[1] <a href="https://ydstudios.gitee.io/post/cef7abb0.html">参考《MySQL是怎样运行的》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在实际开发中总有这样的需求，表里的数据要保持唯一，所以我们开发中经常都是先查询这样的数据有没有，有的话跳过，没有的话再插入，然后在能表示数据记录唯一的列上加上唯一索引进行兜底。虽然有的同学基本上也是这么做的，但是又稍微的做了一点其他的骚操作😄😄😄。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="https://ydstudios.gitee.io/tags/mysql/"/>
    
      <category term="ignore" scheme="https://ydstudios.gitee.io/tags/ignore/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习之模板和策略模式实战</title>
    <link href="https://ydstudios.gitee.io/post/c14af19a.html"/>
    <id>https://ydstudios.gitee.io/post/c14af19a.html</id>
    <published>2020-12-04T21:41:34.000Z</published>
    <updated>2020-12-07T14:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面文章由抽奖活动赠送不同的奖励从而引出了策略模式，定义一个策略接口，不同的奖励发放实现不同的策略。即使后续新增加奖励种类，只要重新实现一个策略即可，符合了设计模式中的<em>开闭原则-对扩展开放对修改关闭</em>。我在一次订单活动功能开发中使用到了策略模式，在开发的过程中发现，订单符合活动条件的判断、发放奖励给用户，可以提升到父类实现，具体的条件判断逻辑可以延迟到子类去实现，从而引出本篇文章的主题：模板模式。</p><a id="more"></a><h6 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h6><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行，这种类型的设计模式属于行为型模式。模板模式中涉及到在父类实现算法骨架，具体步骤在子类实现，所以必须要有抽象类（Java8中的接口的 default 方法貌似也可以实现）。</p><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><ul><li>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li><li>主要解决：一些方法通用，却在每一个子类都重新写了这一方法。</li><li>何时使用：有一些通用的方法。</li><li>如何解决：将这些通用算法抽象出来。</li><li>关键代码：在抽象类实现，其他步骤延迟到子类实现。</li></ul><h6 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h6><ul><li>JDK中 ReentrantLock中公平锁和非公平锁的实现 </li><li>Spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session  等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li></ul><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul><li>封装不变部分，扩展可变部分。 </li><li>提取公共代码，便于维护。 </li><li>行为由父类控制，子类实现。</li></ul><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li></ul><h6 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h6><ul><li>有多个子类共有的方法，且逻辑相同。 </li><li>重要的、复杂的方法，可以考虑作为模板方法。</li></ul><h6 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h6><blockquote><p> 为防止恶意操作，一般模板方法都加上 final 关键词。</p></blockquote><h6 id="本文示例UML图"><a href="#本文示例UML图" class="headerlink" title="本文示例UML图"></a>本文示例UML图</h6><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201204224522.png" alt="模板、策略模式 UML 图" style="zoom:40%;" /><h6 id="代码结构图"><a href="#代码结构图" class="headerlink" title="代码结构图"></a>代码结构图</h6><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20201207220104.png" alt="代码结构图"></p><h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><p>1、策略接口，定义了一个活动策略需要实现的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.common.Result;</span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.dto.ActiveOrderDto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 活动接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IActiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回活动的类型</span></span><br><span class="line"><span class="comment">     * ActiveCategoryEnum 枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getCategory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回活动的详细类型</span></span><br><span class="line"><span class="comment">     * ActiveCategoryDetailEnum 枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getCategoryDetail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单检查</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temporaryOrderDto 临时订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">checkOrder</span><span class="params">(ActiveOrderDto temporaryOrderDto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、活动抽象类包含订单规则是否符合的判断以及符合规则之后发送奖励的算法骨架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.common.Result;</span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.dto.ActiveOrderDto;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 活动抽象类,抽取公共方法,</span></span><br><span class="line"><span class="comment"> * 把订单是否符合奖励的判断之后发送奖励的公共逻辑在此处实现,</span></span><br><span class="line"><span class="comment"> * 订单具体条件的判断延迟由子类去实现.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 策略和模板模式组合使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractActiveHandle</span> <span class="keyword">implements</span> <span class="title">IActiveHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其他抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"其他公用方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部真正要调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temporaryOrderDto 订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">handle</span><span class="params">(ActiveOrderDto temporaryOrderDto)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用接口中需要子类实现的方法</span></span><br><span class="line">        Result result = checkOrder(temporaryOrderDto);</span><br><span class="line">        <span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"不符合奖励发放条件"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"不符合奖励发放条件"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendReward(temporaryOrderDto, temporaryOrderDto.getMemberId(), <span class="string">"积分"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统一的发送奖励的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temporaryOrderDto 订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memberId 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reward 奖励</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">sendReward</span><span class="params">(ActiveOrderDto temporaryOrderDto, <span class="keyword">long</span> memberId, String reward)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"给用户"</span> + memberId + <span class="string">"的订单"</span> + temporaryOrderDto + <span class="string">"发送奖励"</span> + reward;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、 活动策略的实现类</p><ul><li><p>会籍订单策略实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.common.Result;</span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.dto.ActiveOrderDto;</span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.service.AbstractActiveHandle;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 会籍订单的处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelOrderActiveHandle</span> <span class="keyword">extends</span> <span class="title">AbstractActiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"会籍订单的实现"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategoryDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">checkOrder</span><span class="params">(ActiveOrderDto temporaryOrderDto)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> i = random.nextInt(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"不符合会籍订单活动条件"</span>,<span class="string">"不符合会籍订单活动条件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>酒店订单活动策略实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.service.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.common.Result;</span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.dto.ActiveOrderDto;</span><br><span class="line"><span class="keyword">import</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.service.AbstractActiveHandle;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 酒店订单处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderActiveHandle</span> <span class="keyword">extends</span> <span class="title">AbstractActiveHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"酒店订单的实现"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCategoryDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">checkOrder</span><span class="params">(ActiveOrderDto temporaryOrderDto)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> i = random.nextInt(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="string">"不符合酒店订单活动条件"</span>,<span class="string">"不符合酒店订单活动条件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>4 、统一入口提供一个Context 给外部使用</p><p>调用方直接使用@Autowired 注入ActiveHandleContext即可使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydstudio.flashsale.<span class="keyword">module</span>.pattern.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责所有活动处理的入口,根据 getImpl(String categoryDetail)类型来判断调用具体的活动策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveHandleContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractActiveHandle&gt; activeHandleList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外的统一入口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> categoryDetail 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractActiveHandle <span class="title">getImpl</span><span class="params">(String categoryDetail)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"参数 categoryDetail =[&#123;&#125;] 获取实现 "</span>, categoryDetail);</span><br><span class="line">        <span class="keyword">for</span> (AbstractActiveHandle activeHandle : activeHandleList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (activeHandle.getCategoryDetail().equals(categoryDetail)) &#123;</span><br><span class="line">                <span class="keyword">return</span> activeHandle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"没有该实现"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类AbstractActiveHandle实现活动规则判断、发放奖励的算法骨架，子类实现具体的规则判断，这样就实现了代码的优化和公用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面文章由抽奖活动赠送不同的奖励从而引出了策略模式，定义一个策略接口，不同的奖励发放实现不同的策略。即使后续新增加奖励种类，只要重新实现一个策略即可，符合了设计模式中的&lt;em&gt;开闭原则-对扩展开放对修改关闭&lt;/em&gt;。我在一次订单活动功能开发中使用到了策略模式，在开发的过程中发现，订单符合活动条件的判断、发放奖励给用户，可以提升到父类实现，具体的条件判断逻辑可以延迟到子类去实现，从而引出本篇文章的主题：模板模式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="https://ydstudios.gitee.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://ydstudios.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://ydstudios.gitee.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板模式" scheme="https://ydstudios.gitee.io/tags/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
