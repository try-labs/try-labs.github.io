<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java学习系列文章第九篇：Java中泛型的学习 | Sam的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是泛型Java 泛型（generics）是 JDK5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。(PHP就不需要泛型，哈哈)">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习系列文章第九篇：Java中泛型的学习">
<meta property="og:url" content="https://ydstudios.gitee.io/post/d9ad2c86.html">
<meta property="og:site_name" content="Sam的个人博客">
<meta property="og:description" content="什么是泛型Java 泛型（generics）是 JDK5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。(PHP就不需要泛型，哈哈)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-08-04T23:03:24.000Z">
<meta property="article:modified_time" content="2019-12-09T15:03:26.000Z">
<meta property="article:author" content="Sam">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Sam的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Sam的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/links">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ydstudios.gitee.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java学习系列文章第九篇：Java中泛型的学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/d9ad2c86.html" class="article-date">
  <time datetime="2018-08-04T23:03:24.000Z" itemprop="datePublished">2018-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java学习系列文章第九篇：Java中泛型的学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>Java 泛型（generics）是 JDK5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<strong>泛型的本质是参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。(PHP就不需要泛型，哈哈)</p>
<a id="more"></a>
<p>下面我们看一道关于Java泛型的经典测试题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">System.out.println(list1.getClass() == list2.getClass());</span><br></pre></td></tr></table></figure>
<p>上面代码最终结果输出的是什么？不了解泛型的和很熟悉泛型的同学应该能够答出来，而对泛型有所了解，但是了解不深入的同学可能会答错。</p>
<p>正确答案是 true。</p>
<p>上面提到了泛型的本质是类型参数化，如何解释类型参数化呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">   Object value;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.value = value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的 Cache 是能够存取任何类型的值，但是我们在使用的时候会有点麻烦。我们要获取真正的类型，就要进行类型的强制转换了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cache cache = <span class="keyword">new</span> Cache();</span><br><span class="line">cache.setValue(<span class="number">134</span>);</span><br><span class="line"><span class="keyword">int</span> value = (<span class="keyword">int</span>) cache.getValue();</span><br><span class="line">cache.setValue(<span class="string">"hello"</span>);</span><br><span class="line">String value1 = (String) cache.getValue();</span><br></pre></td></tr></table></figure>
<p>这样的编程真的是太麻烦了，万一忘记了存放变量的类型，程序在运行的时候就会报类型转换错误。于是在JDK5 中引用的泛型给我们带来了另一番编程体验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   T value;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.value = value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是泛型，它将 value 这个属性的类型也参数化了，这就是所谓的参数化类型。再看它的使用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String&gt; cache1 = <span class="keyword">new</span> Cache&lt;String&gt;();</span><br><span class="line">cache1.setValue(<span class="string">"123"</span>);</span><br><span class="line">String value2 = cache1.getValue();</span><br><span class="line"></span><br><span class="line">Cache&lt;Integer&gt; cache2 = <span class="keyword">new</span> Cache&lt;Integer&gt;();</span><br><span class="line">cache2.setValue(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">int</span> value3 = cache2.getValue();</span><br></pre></td></tr></table></figure>
<p>最显而易见的好处就是它不再需要对取出来的结果进行强制转换了。但，还有另外一点不同。泛型除了可以将类型参数化外，而参数一旦确定好，如果类似不匹配，编译器就不通过。<br>综合上面信息，我们可以得到下面的结论:</p>
<ul>
<li>与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。</li>
<li>当具体的类型确定后，泛型又提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。所以说，它是一种类型安全检测机制，一定程度上提高了软件的安全性防止出现低级的失误。</li>
<li>泛型提高了程序代码的可读性，不必要等到运行的时候才去强制转换，在定义或者实例化阶段，因为 Cache<String> 这个类型显化的效果，程序员能够一目了然猜测出代码要操作的数据类型。</li>
</ul>
<h3 id="泛型的定义和使用"><a href="#泛型的定义和使用" class="headerlink" title="泛型的定义和使用"></a>泛型的定义和使用</h3><p>泛型按照使用情况可以分为 3 种。</p>
<ul>
<li>泛型类</li>
<li>泛型方法</li>
<li>泛型接口</li>
</ul>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>那如何定义泛型类呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   T field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尖括号 &lt;&gt; 中的 T 被称作是类型参数，用于指代任何类型。事实上，T 只是一种习惯性写法，如果你愿意。你可以这样写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">TMD</span>&gt; </span>&#123;</span><br><span class="line">   TMD field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如： </p>
<ul>
<li>T 代表一般的任何类。 </li>
<li>E 代表Element 的意思，或者是Exception 异常的意思</li>
<li>K 代表 Key 的意思</li>
<li>V 代表 Value 的意思，通常与 K 一起配合使用</li>
<li>S 代表 Subtype 的意思</li>
</ul>
<p>如果一个类被 <T> 的形式定义，那么它就被称为泛型类。那么对于泛型类怎么样使用呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;String&gt; test1 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">Test&lt;Integer&gt; test2 = <span class="keyword">new</span> Test&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>只要在对泛型类创建实例的时候，在尖括号中赋值相应的类型便是。T 就会被替换成对应的类型，如 String 或者是 Integer。你可以相像一下，当一个泛型类被创建时，内部自动扩展成下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">   String field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，泛型类不是只能接受一个类型参数，它还可以这样接受多个类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiType</span> &lt;<span class="title">E</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   E value1;</span><br><span class="line">   T value2;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getValue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getValue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。<T> 中的 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。</p>
<p>当然，声明的类型参数，其实也是可以当作返回值的类型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  &lt;T&gt; <span class="function">T <span class="title">testMethod1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型类与泛型方法的共存现象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">       System.out.println(t.getClass().getName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">testMethod1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Test1<T> 是泛型类，testMethod 是泛型类中的普通方法，而 testMethod1 是一个泛型方法。而泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的，<strong>泛型方法始终以自己定义的类型参数为准</strong>。</p>
<p>所以，针对上面的代码，我们可以这样编写测试代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test1&lt;String&gt; t = <span class="keyword">new</span> Test1();</span><br><span class="line">t.testMethod(<span class="string">"generic"</span>);</span><br><span class="line">Integer i = t.testMethod1(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>泛型类的实际类型参数是 String，而传递给泛型方法的类型参数是 Integer，两者不想干。</p>
<p>但是，为了避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。比如，Test<T> 代码可以更改为这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">       System.out.println(t.getClass().getName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span>  &lt;E&gt; <span class="function">E <span class="title">testMethod1</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通配符-？"><a href="#通配符-？" class="headerlink" title="通配符 ？"></a>通配符 ？</h3><p>除了用 <T> 表示泛型外，还有 <?> 这种形式。？ 被称为通配符。
可能有同学会想，已经有了 <T> 的形式了，为什么还要引进 <?> 这样的概念呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">Base base = sub;</span><br></pre></td></tr></table></figure>
<p>上面代码显示，Base 是 Sub 的父类，它们之间是继承关系，所以 Sub 的实例可以给一个 Base 引用赋值，那么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Sub&gt; lsub = <span class="keyword">new</span> ArrayList&lt;Sub&gt;();</span><br><span class="line">List&lt;Base&gt; lbase = lsub;</span><br></pre></td></tr></table></figure>
<p>最后一行代码成立吗？编译会通过吗？</p>
<p>答案是<strong>通过不了编译</strong>的。</p>
<p>编译器不会让它通过的。Sub 是 Base 的子类，不代表 List<Sub> 和 List<Base> 有继承关系。</p>
<p>但是，在现实编码中，确实有这样的需求，希望泛型能够处理某一范围内的数据类型，比如某个类和它的子类，对此 Java 引入了通配符这个概念。</p>
<p>所以，<strong>通配符的出现是为了指定泛型中的类型范围</strong>。</p>
<p>通配符有 3 种形式:</p>
<ul>
<li>&lt;?&gt; 被称作无限定的通配符</li>
<li>&lt;? extends T&gt; 被称作有上限的通配符</li>
<li>&lt;? super T&gt; 被称作有下限的通配符</li>
</ul>
<h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildCards</span><span class="params">(Collection&lt;?&gt; collection)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，方法内的参数是被无限定通配符修饰的 Collection 对象，它隐略地表达了一个意图或者可以说是限定，那就是 testWidlCards() 这个方法内部无需关注 Collection 中的真实类型，<strong>因为它是未知的</strong>。所以，你只能调用 Collection 中与类型无关的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWildCards</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildCards</span><span class="params">(Collection&lt;?&gt; collection)</span></span>&#123;</span><br><span class="line">        #报错</span><br><span class="line">        collection.add(<span class="number">123</span>);</span><br><span class="line">        #报错</span><br><span class="line">        collection.add(<span class="string">"hello"</span>);</span><br><span class="line">        #报错</span><br><span class="line">        collection.add(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">        collection.iterator().next();</span><br><span class="line">        collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，当 &lt;?&gt; 存在时，Collection 对象丧失了 add() 方法的功能，编译器不通过。<br>我们再看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; wildlist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">wildlist.add(<span class="number">123</span>);<span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<p>有人说，&lt;?&gt; 提供了只读的功能，也就是它删减了增加具体类型元素的能力，只保留与具体类型无关的功能。它不管装载在这个容器内的元素是什么类型，它只关心元素的数量、容器是否为空？我想这种需求还是很常见的吧。</p>
<p>有同学可能会想，&lt;?&gt; 既然作用这么渺小，那么为什么还要引用它呢？</p>
<p>个人认为，提高了代码的可读性，程序员看到这段代码时，就能够迅速对此建立极简洁的印象，能够快速推断源码作者的意图。</p>
<h3 id="lt-extends-T-gt"><a href="#lt-extends-T-gt" class="headerlink" title="&lt;? extends T&gt;"></a>&lt;? extends T&gt;</h3><p>&lt;?&gt; 代表着类型未知，但是我们的确需要对于类型的描述再精确一点，我们希望在一个范围内确定类别，比如类型 A 及 类型 A 的子类都可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSub</span><span class="params">(Collection&lt;? extends Base&gt; para)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，para 这个 Collection 接受 Base 及 Base 的子类的类型。但是，它仍然丧失了写操作的能力。也就是说:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">para.add(<span class="keyword">new</span> Sub());</span><br><span class="line">para.add(<span class="keyword">new</span> Base());</span><br></pre></td></tr></table></figure>
<p>仍然编译不通过。没有关系，我们不知道具体类型，但是我们至少清楚了类型的范围。</p>
<h3 id="lt-super-T-gt"><a href="#lt-super-T-gt" class="headerlink" title="&lt;? super T&gt;"></a>&lt;? super T&gt;</h3><p>这个和 &lt;? extends T&gt; 相对应，代表 T 及 T 的超类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuper</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Sub&gt; para)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>&lt;? super T&gt; 神奇的地方在于，它拥有一定程度的写操作的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuper</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Sub&gt; para)</span></span>&#123;</span><br><span class="line">   para.add(<span class="keyword">new</span> Sub());<span class="comment">//编译通过</span></span><br><span class="line">   para.add(<span class="keyword">new</span> Base());<span class="comment">//编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通配符与类型参数的区别"><a href="#通配符与类型参数的区别" class="headerlink" title="通配符与类型参数的区别"></a>通配符与类型参数的区别</h3><p>一般而言，通配符能干的事情都可以用类型参数替换。比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildCards</span><span class="params">(Collection&lt;?&gt; collection)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以被</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Collection&lt;T&gt; collection)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取代。值得注意的是，如果用泛型方法来取代通配符，那么上面代码中 collection 是能够进行写操作的。只不过要进行强制转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Collection&lt;T&gt; collection)</span></span>&#123;</span><br><span class="line">   collection.add((T)<span class="keyword">new</span> Integer(<span class="number">12</span>));</span><br><span class="line">   collection.add((T)<span class="string">"123"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，类型参数适用于参数之间的类别依赖关系，举例说明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> &lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   T value1;</span><br><span class="line">   E value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;D,S extends D&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(D d,S s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E 类型是 T 类型的子类，显然这种情况类型参数更适合。<br>有一种情况是，通配符和类型参数一起使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t,Collection&lt;? extends T&gt; collection)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个方法的返回类型依赖于参数的类型，那么通配符也无能为力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">test1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。</p>
<p>这是因为，泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做<strong>类型擦除</strong>。</p>
<p>通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。回顾文章开始时的那段代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">System.out.println(list1.getClass() == list2.getClass());</span><br></pre></td></tr></table></figure>
<p>打印的结果为 true 是因为 List<String> 和 List<Integer> 在 jvm 中的 Class 都是 List.class。</p>
<p>泛型信息被擦除了。</p>
<p>可能同学会问，那么类型 String 和 Integer 怎么办？</p>
<p>答案是泛型转译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   T object;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Erasure</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.object = object;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Erasure 是一个泛型类，我们查看它在运行时的状态信息可以通过反射。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Erasure&lt;String&gt; erasure = <span class="keyword">new</span> Erasure&lt;String&gt;(<span class="string">"hello"</span>);</span><br><span class="line">Class eclz = erasure.getClass();</span><br><span class="line">System.out.println(<span class="string">"erasure class is:"</span>+eclz.getName());</span><br><span class="line"></span><br><span class="line">#打印的结果是</span><br><span class="line">erasure class is:com.frank.test.Erasure</span><br></pre></td></tr></table></figure>
<p>Class 的类型仍然是 Erasure 并不是 Erasure<T> 这种形式，那我们再看看泛型类中 T 的类型在 jvm 中是什么具体类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field[] fs = eclz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> ( Field f:fs) &#123;</span><br><span class="line">   System.out.println(<span class="string">"Field name "</span>+f.getName()+<span class="string">" type:"</span>+f.getType().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#打印结果是</span><br><span class="line">Field name object type:java.lang.Object</span><br></pre></td></tr></table></figure>
<p>那我们可不可以说，泛型类被类型擦除后，相应的类型就被替换成 Object 类型呢？</p>
<p>这种说法，不完全正确。 我们更改一下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span>&gt;</span>&#123; </span><br><span class="line"></span><br><span class="line">   T object;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Erasure</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.object = object;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#现在再看测试结果：</span><br><span class="line">Field name object type:java.lang.String</span><br></pre></td></tr></table></figure>
<p>我们现在可以下结论了，在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <T> 则会被转译成普通的 Object 类型，如果指定了上限如 <T extends String> 则类型参数就被替换成类型上限。</p>
<p>所以，在反射中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   T object;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Erasure</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.object = object;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T object)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add() 这个方法对应的 Method 的签名应该是 Object.class。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Erasure&lt;String&gt; erasure = <span class="keyword">new</span> Erasure&lt;String&gt;(<span class="string">"hello"</span>);</span><br><span class="line">Class eclz = erasure.getClass();</span><br><span class="line">System.out.println(<span class="string">"erasure class is:"</span>+eclz.getName());</span><br><span class="line"></span><br><span class="line">Method[] methods = eclz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> ( Method m:methods )&#123;</span><br><span class="line">   System.out.println(<span class="string">" method:"</span>+m.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#打印结果是</span><br><span class="line">method:<span class="keyword">public</span> <span class="keyword">void</span> com.frank.test.Erasure.add(java.lang.Object)</span><br></pre></td></tr></table></figure>
<p>也就是说，如果你要在反射中找到 add 对应的 Method，你应该调用 getDeclaredMethod(“add”,Object.class) 否则程序会报错，提示没有这么一个方法，原因就是类型擦除的时候，T 被替换成 Object 类型了。</p>
<h3 id="泛型中值得注意的地方"><a href="#泛型中值得注意的地方" class="headerlink" title="泛型中值得注意的地方"></a>泛型中值得注意的地方</h3><h4 id="泛型类或者泛型方法中，不接受-8-种基本数据类型。"><a href="#泛型类或者泛型方法中，不接受-8-种基本数据类型。" class="headerlink" title="泛型类或者泛型方法中，不接受 8 种基本数据类型。"></a>泛型类或者泛型方法中，不接受 8 种基本数据类型。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种是错误的使用方式</span></span><br><span class="line">List&lt;<span class="keyword">int</span>&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;<span class="keyword">boolean</span>&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要使用它们对应的包装类</span></span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Boolean&gt; li1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<h4 id="对泛型方法的困惑"><a href="#对泛型方法的困惑" class="headerlink" title="对泛型方法的困惑"></a>对泛型方法的困惑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的同学可能对于连续的两个 T 感到困惑，其实 <T> 是为了说明类型参数，是声明,而后面的不带尖括号的 T 是方法的返回值类型。<br>你可以相像一下，如果 test() 这样被调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">// 那么实际上相当于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String t)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Java-不能创建具体类型的泛型数组"><a href="#Java-不能创建具体类型的泛型数组" class="headerlink" title="Java 不能创建具体类型的泛型数组"></a>Java 不能创建具体类型的泛型数组</h4><p>这句话可能难以理解，用代码来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] li2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;[];</span><br><span class="line">List&lt;Boolean&gt; li3 = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;[];</span><br></pre></td></tr></table></figure>
<p>这两行代码是无法在编译器中编译通过的。原因还是类型擦除带来的影响。</p>
<p>List<Integer> 和 List<Boolean> 在 jvm 中等同于List<Object> ，所有的类型信息都被擦除，程序也无法分辨一个数组中的元素类型具体是 List<Integer>类型还是 List<Boolean> 类型。但是，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] li3 = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span><br><span class="line">li3[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;?&gt; v = li3[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>借助于无限定通配符却可以，前面讲过 ？ 代表未知类型，所以它涉及的操作都基本上与类型无关，因此 jvm 不需要针对它对类型作判断，因此它能编译通过，但是，只提供了数组中的元素因为通配符原因，它只能读，不能写。比如，上面的 v 这个局部变量，它只能进行 get() 操作，不能进行 add() 操作，这个在前面通配符的内容小节中已经讲过。</p>
<h3 id="泛型，并不神奇"><a href="#泛型，并不神奇" class="headerlink" title="泛型，并不神奇"></a>泛型，并不神奇</h3><p>我们可以看到，泛型其实并没有什么神奇的地方，泛型代码能做的非泛型代码也能做。</p>
<p>而类型擦除，是泛型能够与之前的 java 版本代码兼容共存的原因。</p>
<p>可量也正因为类型擦除导致了一些隐患与局限。</p>
<p>但，我还是要建议大家使用泛型，如官方文档所说的，如果可以使用泛型的地方，尽量使用泛型。</p>
<p>毕竟它抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。</p>
<p>类型擦除不是泛型的全部，但是它却能很好地检测我们对于泛型这个概念的理解程度。<br><a href="blog.csdn.net/briblue/article/details/76736356">来源：blog.csdn.net/briblue/article/details/76736356</a></p>

      
    </div>
         
            <div>
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>Sam</a>
    </li>
    <li><span>发布时间: </span>2018-08-04 23:03:24</li>
    <li><span>最后更新: </span>2019-12-09 23:03:26</li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/post/d9ad2c86.html" target="_blank" title="Java学习系列文章第九篇：Java中泛型的学习">https://ydstudios.gitee.io/post/d9ad2c86.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网所有文章除特别声明外, 
      禁止未经授权转载，违者依法追究相关法律责任!
    </li>
  </ul>
<div>
         
    <footer class="article-footer">
      <a data-url="https://ydstudios.gitee.io/post/d9ad2c86.html" data-id="cl5zaho2a001cbsszc0ij5dgw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/post/45183e9d.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer >> </strong>
      <div class="article-nav-title">
        
          Nginx实现反向代理 Node.js
        
      </div>
    </a>
  
  
    <a href="/post/7226e685.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older << </strong>
      <div class="article-nav-title">Centos 6.x 安装git</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Sam<br>
      <!--Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>-->
      <p>备案号:<a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">苏ICP备17069935号-1</a></p>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/links" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="https://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>