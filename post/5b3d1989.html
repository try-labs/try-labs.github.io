<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>解耦神器之观察者模式 | Sam的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="大家是不是会经常听到有些程序员把“高内聚、低耦合”的词语挂在嘴边，但是什么是高内聚低耦合？为什么要高内聚、低耦合？怎么做才能高内聚、低耦合?">
<meta name="keywords" content="spring,设计模式,观察者模式">
<meta property="og:type" content="article">
<meta property="og:title" content="解耦神器之观察者模式">
<meta property="og:url" content="https:&#x2F;&#x2F;ydstudios.gitee.io&#x2F;post&#x2F;5b3d1989.html">
<meta property="og:site_name" content="Sam的个人博客">
<meta property="og:description" content="大家是不是会经常听到有些程序员把“高内聚、低耦合”的词语挂在嘴边，但是什么是高内聚低耦合？为什么要高内聚、低耦合？怎么做才能高内聚、低耦合?">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210204230758.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210204230024.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210204225825.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210204214744.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210204222111.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210204230251.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210204230429.png">
<meta property="og:updated_time" content="2021-02-04T15:19:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210204230758.png">
  
    <link rel="alternate" href="/atom.xml" title="Sam的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Sam的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/links">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ydstudios.gitee.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-解耦神器之观察者模式的副本" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/5b3d1989.html" class="article-date">
  <time datetime="2021-02-04T20:44:34.000Z" itemprop="datePublished">2021-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      解耦神器之观察者模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大家是不是会经常听到有些程序员把“高内聚、低耦合”的词语挂在嘴边，但是什么是高内聚低耦合？为什么要高内聚、低耦合？怎么做才能高内聚、低耦合?</p>
<a id="more"></a>

<h6 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h6><h5 id="抽象主题-Subject"><a href="#抽象主题-Subject" class="headerlink" title="抽象主题(Subject)"></a>抽象主题(Subject)</h5><p>它把所有观察者对象的引用保存到一个容器里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p>
<h5 id="具体主题-ConcreteSubject"><a href="#具体主题-ConcreteSubject" class="headerlink" title="具体主题(ConcreteSubject)"></a>具体主题(ConcreteSubject)</h5><p>将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</p>
<h5 id="抽象抽象观察者-Observer"><a href="#抽象抽象观察者-Observer" class="headerlink" title="抽象抽象观察者(Observer)"></a>抽象抽象观察者(Observer)</h5><p>为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p>
<h5 id="具体观察者-ConcreteObserver"><a href="#具体观察者-ConcreteObserver" class="headerlink" title="具体观察者(ConcreteObserver)"></a>具体观察者(ConcreteObserver)</h5><p>实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p>
<h6 id="Java原生实现"><a href="#Java原生实现" class="headerlink" title="Java原生实现"></a>Java原生实现</h6><p>Java从JDK1.0开始就自带了 <code>java.util.Observer</code> 和 <code>java.util.Observable</code> 相关接口、类来实现观察者模式，由此可见Java对于观察者模式的重视，也从另一方面说明观察者模式是多么重要。那么接下来我们开始用Java自带的来实现观察者模式的编码。</p>
<p>在这里我们以一个下单的场景来举例描述，用户创建完订单，要发送一个消息通知用户订单创建成功，还要发送一个消息给仓库，检查对应的订单商品。具体代码如下。</p>
<h4 id="1-继承java-util-Observable定义主题"><a href="#1-继承java-util-Observable定义主题" class="headerlink" title="1. 继承java.util.Observable定义主题"></a>1. 继承<code>java.util.Observable</code>定义主题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSubject</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单状态发生变化通知其他，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="comment">// 通知其他</span></span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="comment">// 这里是可以携带一些额外的参数</span></span><br><span class="line">        <span class="keyword">this</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-实现java-util-Observer接口定义观察者"><a href="#2-实现java-util-Observer接口定义观察者" class="headerlink" title="2. 实现java.util.Observer接口定义观察者"></a>2. 实现<code>java.util.Observer</code>接口定义观察者</h4><p><code>java.util.Observer</code> 是一个接口，接口中只有一个<code>update</code>方法。每当更改被观察对象时，都会调用此方法。 应用程序调用Observable对象的 <code>notifyObservers</code>方法，以将更改通知给所有对象的观察者。在这个例子中通知模块、仓库模块就是扮演观察者的角色，具体的代码实现如下：</p>
<ul>
<li>通知模块实现<code>java.util.Observer</code>接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoticeObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        OrderSubject orderSubject = (OrderSubject) o;</span><br><span class="line">        log.info(<span class="string">"通知中心收到了订单的变化[&#123;&#125;],arg = [&#123;&#125;]"</span>, orderSubject.getStatus(),arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>仓库模块实现<code>java.util.Observer</code>接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WareHouseObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OrderSubject orderSubject = (OrderSubject) observable;</span><br><span class="line">        log.info(<span class="string">"仓库观察者收到了订单的变化[&#123;&#125;],arg = [&#123;&#125;]"</span>, orderSubject.getStatus(), arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-代码编写完成，测试一把"><a href="#3-代码编写完成，测试一把" class="headerlink" title="3. 代码编写完成，测试一把"></a>3. 代码编写完成，测试一把</h4><p>具体测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        OrderSubject orderSubject = <span class="keyword">new</span> OrderSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知系统监听者</span></span><br><span class="line">        NoticeObserver noticeObserver = <span class="keyword">new</span> NoticeObserver();</span><br><span class="line">        orderSubject.addObserver(noticeObserver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仓库监听者</span></span><br><span class="line">        WareHouseObserver wareHouseObserver = <span class="keyword">new</span> WareHouseObserver();</span><br><span class="line">        orderSubject.addObserver(wareHouseObserver);</span><br><span class="line">         <span class="comment">// 订单创建</span></span><br><span class="line">        orderSubject.setStatus(<span class="string">"订单创建啦"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订单付款</span></span><br><span class="line">        orderSubject.setStatus(<span class="string">"订单付款啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订单的状态发生了变化，对应的观察者就接受到了通知。JDK提供的实现很简单，但是缺陷也是很明显。</p>
<ul>
<li><p><code>Observable</code> 是一个类，不是一个接口，也不是一个抽象类，不继承该类无法使用权限类型为 protected 的<code>setChanged()</code>和 <code>clearChanged()</code>方法。</p>
</li>
<li><p>用<code>Vector&lt;Observer&gt;</code>保存观察者。<code>Vector</code>效率低下，JDK已经不建议使用了。</p>
</li>
<li><p>主题变化通知观察者的顺序无法自定义。通知的顺序是固定为按照设置观察者的时间倒叙通知，无法自定义。</p>
</li>
<li><p>整体代码执行是同步的，不能设置为异步。且观察者的执行出现异常，程序处理不到位会导致<strong>事务回滚</strong>。</p>
</li>
</ul>
<p>既然JDK中实现不够完美，我们就看看有没有其他的实现方式。Google的Guava工具包提供了EventBus可以实现、Spring框架中也提供了相应的支持，由于我们使用Spring框架比较多，今天我们就先来说说Spring框架中是如何实现对观察者模式的支持吧！</p>
<h6 id="Spring中的实现"><a href="#Spring中的实现" class="headerlink" title="Spring中的实现"></a>Spring中的实现</h6><p>Spring框架中提供了相当多的组件可以实现观察者模式，文章后面会一一向大家介绍。这里我引入一个新的业务场景，用户注册之后发送短信通知、积分还有优惠券。这种业务场景非常的常见，我展示一下小伙伴们一般是怎么样实现这样的功能的。因为篇幅有限，这里就展示一下伪代码吧！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> MemberDao memberDao;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> CouponService couponService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SmsService smsService;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成用户注册，成功之后发送优惠券、短信通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memberName 查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 分页信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">normalRegister</span><span class="params">(String memberName,String phone)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, phone);</span><br><span class="line">        <span class="comment">// 保存用户</span></span><br><span class="line">        Long memberId = memberDao.saveMember();</span><br><span class="line">        <span class="comment">// 发送优惠券</span></span><br><span class="line">        couponService.sendCoupon(memberId);</span><br><span class="line">        <span class="comment">// 发送短信</span></span><br><span class="line">        smsService.sendSms(phone);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>大家对这部分代码怎么看？</strong></p>
<p>对于用户注册功能来说，保障用户成功注册，这是个业务的核心诉求，其他的都是锦上添花，所以这个地方不应该掺杂其他的业务。用户注册与发送短信、优惠券功能应该分隔开，这样也符合解耦的设计规则。不然后续业务增加需求，需要用户注册完成之后给用户发送积分，你是不是还要在这个 <code>normalRegister</code>方法中增加发送积分的逻辑，那这个岂不是又违背了开闭原则。</p>
<blockquote>
<p>一件事做容易，想做好不容易。写程序也是如此，能够把功能编码实现bug又少，其实是很耗费时间和精力的。我常跟同事们开玩笑说“写代码不要糊弄，该写的代码一定要写，不然你最后肯定会被代码糊弄”。</p>
</blockquote>
<p><strong>接下来我来介绍一下如何使用Spring的事件发布机制来实现业务解耦的</strong></p>
<p>由于后面的实现方法中用户注册事件类的代码都是类似的只是类名不同，那我就把用户注册事件类的代码写在前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以自定义些自己需要的属性</span></span><br><span class="line"><span class="comment">     * 用户的id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long memberId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String memberPhone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object source, Long memberId, String memberPhone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.memberId = memberId;</span><br><span class="line">        <span class="keyword">this</span>.memberPhone = memberPhone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="利用继承ApplicationEvent类、实现ApplicationListener接口或者-EventListener注解来实现"><a href="#利用继承ApplicationEvent类、实现ApplicationListener接口或者-EventListener注解来实现" class="headerlink" title="利用继承ApplicationEvent类、实现ApplicationListener接口或者  @EventListener注解来实现"></a>利用继承<code>ApplicationEvent</code>类、实现<code>ApplicationListener</code>接口或者  <code>@EventListener</code>注解来实现</h5><p><code>org.springframework.context.ApplicationListener</code>是Spring提供的一个泛型接口。由应用程序事件侦听器实现的接口,从Spring 3.0开始，<code>ApplicationListener</code>可以一般性地声明其感兴趣的事件类型。在Spring ApplicationContext中注册后，将相应地过滤事件，并且仅针对匹配事件对象调用侦听器。观察者可以实现<code>ApplicationListener</code>接口或者使用<code>@EventListener</code>注解，这个注解和<code>ApplicationListener</code>接口有着相同的功能，相比之下使用注解比使用接口更方便一点。</p>
<h4 id="短信Service实现ApplicationListener接口"><a href="#短信Service实现ApplicationListener接口" class="headerlink" title="短信Service实现ApplicationListener接口"></a>短信Service实现ApplicationListener接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"[EventListener][给用户(&#123;&#125;) 发送短信]"</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优惠券Service直接在addCoupon-方法上添加注解-EventListener"><a href="#优惠券Service直接在addCoupon-方法上添加注解-EventListener" class="headerlink" title="优惠券Service直接在addCoupon 方法上添加注解 @EventListener"></a>优惠券Service直接在<code>addCoupon</code> 方法上添加注解 <code>@EventListener</code></h4><p>注意<code>addCoupon</code> 方法的入参为 <code>UserRegisterEvent</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponService</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"[addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>积分Service中的代码与上面的类似就不贴出来了</strong></p>
<h4 id="注册业务完成发布UserRegisterEvent事件"><a href="#注册业务完成发布UserRegisterEvent事件" class="headerlink" title="注册业务完成发布UserRegisterEvent事件"></a>注册业务完成发布<code>UserRegisterEvent</code>事件</h4><p>这个地方MemberService要实现<code>org.springframework.beans.factory.Aware.ApplicationEventPublisherAware</code>接口，才有能力使用 <code>ApplicationEventPublisher</code> 发布事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最简单的观察者实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 用户手机号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(String memberPhone)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, memberPhone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、用户数据保存到数据库</span></span><br><span class="line">        Long memberId = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、发布事件通知</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, memberId, memberPhone));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>, <span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        memberService.register(<span class="string">"13911111111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204230758.png" alt="发送短信在发送优惠券之前"></p>
<p>代码执行成功，打印出了给用户发送短信、优惠券日志，功能完美实现。但是稍微有点问题，我想调换一下两者的顺序，先执行发送优惠券，再发送短信。这个要求还是蛮常见，那怎么实现呢？</p>
<h5 id="使用SmartApplicationListener或者GenericApplicationListener接口实现指定观察者自定义顺序执行"><a href="#使用SmartApplicationListener或者GenericApplicationListener接口实现指定观察者自定义顺序执行" class="headerlink" title="使用SmartApplicationListener或者GenericApplicationListener接口实现指定观察者自定义顺序执行"></a>使用<code>SmartApplicationListener</code>或者<code>GenericApplicationListener</code>接口实现指定观察者自定义顺序执行</h5><p><code>org.springframework.context.event.SmartApplicationListener</code>是Spring3.0版本提供的接口，<code>org.springframework.context.event.GenericApplicationListener</code>则是Spring4.2版本提供的接口，如果在你的项目中使用不了，那就是说明你项目中使用的Spring版本过低，这个问题自己自行处理。<br>在查<code>SmartApplicationListener</code>源码时发现有以下注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Extended variant of the standard &#123;<span class="meta">@link</span> ApplicationListener&#125; <span class="class"><span class="keyword">interface</span>,</span></span><br><span class="line"><span class="class"><span class="title">exposing</span> <span class="title">further</span> <span class="title">metadata</span> <span class="title">such</span> <span class="title">as</span> <span class="title">the</span> <span class="title">supported</span> <span class="title">event</span> <span class="title">type</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">p</span>&gt;<span class="title">Users</span> <span class="title">are</span> &lt;<span class="title">bold</span>&gt;<span class="title">strongly</span> <span class="title">advised</span>&lt;/<span class="title">bold</span>&gt; <span class="title">to</span> <span class="title">use</span> <span class="title">the</span> </span>&#123;<span class="meta">@link</span> GenericApplicationListener&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">instead</span> <span class="title">as</span> <span class="title">it</span> <span class="title">provides</span> <span class="title">an</span> <span class="title">improved</span> <span class="title">detection</span> <span class="title">of</span> <span class="title">generics</span>-<span class="title">based</span></span></span><br><span class="line"><span class="class"><span class="title">event</span> <span class="title">types</span>.</span></span><br></pre></td></tr></table></figure>

<p>翻译之后大概的意思就是，<strong>SmartApplicationListener是标准<code>ApplicationListener</code>接口的扩展变体，公开了进一步的元数据，例如受支持的事件类型。但强烈建议改用<code>GenericApplicationListener</code>接口，因为它提供了对基于泛型的事件类型的改进检测</strong>，那我此处就只以GenericApplicationListener为例了。</p>
<p>优惠券服务Service同样实现接口 <code>GenericApplicationListener</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondVersionCouponService</span> <span class="keyword">implements</span> <span class="title">GenericApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确定此侦听器是否实际上支持给定的事件类型。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SecondVersionUserRegisterEvent<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">eventType</span>.<span class="title">getRawClass</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确定此侦听器是否实际上支持给定的源类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MemberService<span class="class">.<span class="keyword">class</span> </span>== sourceType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的业务逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        SecondVersionUserRegisterEvent userRegisterEvent = (SecondVersionUserRegisterEvent) event;</span><br><span class="line">        Long memberId = userRegisterEvent.getMemberId();</span><br><span class="line">        log.info(<span class="string">"[Second addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设定执行的顺序，数字越小优先级越高就越先被执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>短信服务Service同样实现接口 <code>GenericApplicationListener</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondVersionSmsService</span> <span class="keyword">implements</span> <span class="title">GenericApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(ResolvableType eventType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SecondVersionUserRegisterEvent<span class="class">.<span class="keyword">class</span> </span>== eventType.getRawClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MemberService<span class="class">.<span class="keyword">class</span> </span>== sourceType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        SecondVersionUserRegisterEvent userRegisterEvent = (SecondVersionUserRegisterEvent) event;</span><br><span class="line">        String memberPhone = userRegisterEvent.getMemberPhone();</span><br><span class="line">        log.info(<span class="string">"[Second onApplicationEvent][给用户(&#123;&#125;) 发送短信]"</span>, memberPhone);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实使用<code>org.springframework.context.ApplicationListener</code> + <code>org.springframework.core.annotation.Order</code>注解也可以实现控制观察者的执行顺序，而且更简洁！</p>
</blockquote>
<h4 id="注册业务完成发布UserRegisterEvent事件-1"><a href="#注册业务完成发布UserRegisterEvent事件-1" class="headerlink" title="注册业务完成发布UserRegisterEvent事件"></a>注册业务完成发布<code>UserRegisterEvent</code>事件</h4><p>这个地方MemberService要实现<code>org.springframework.beans.factory.Aware.ApplicationEventPublisherAware</code>接口，才有能力使用 <code>ApplicationEventPublisher</code> 发布事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最简单的观察者实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 用户手机号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span> <span class="title">register</span>(<span class="title">String</span> <span class="title">phone</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[Second register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, phone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、 保存用户到数据库（假设这个是）</span></span><br><span class="line">        BizLocalMessageEntity entity = <span class="keyword">new</span> BizLocalMessageEntity();</span><br><span class="line">        ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">        entity.setBizModule((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        entity.setBizNo(<span class="string">""</span> + random.nextInt(<span class="number">100000</span>));</span><br><span class="line">        entity.setBizType((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        entity.setSendStatus((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        entity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        entity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">        Long memberId = entity.getId();</span><br><span class="line">        log.info(<span class="string">"插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, memberId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、发布事件通知</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> SecondVersionUserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring-dao.xml"</span>, <span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@RunWith</span>(value = SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        memberService.register(<span class="string">"13911111111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204230024.png" alt="运行截图"></p>
<p>修改两个Service中order的数值可以轻松两个观察者的执行顺序，完美的解决了自定义观察者执行顺序的要求。细心的小伙伴会发现，假设在用户注册的方法中存在事务，观察者的执行出现异常，会导致整个事务回滚，明明用户的数据已经保存到数据库，现在却没有了！还是前面那句话，在这个业务场景，用户注册成功是核心诉求，发送短信、优惠券重要性都是比不上的。那要解决这种情况，就需要用户注册成功的事务提交之后，再发布注册成功事件，避免观察者执行结果的影响。</p>
<p><strong>短信服务Service有有异常抛出导致事务回滚</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">       SecondVersionUserRegisterEvent userRegisterEvent = (SecondVersionUserRegisterEvent) event;</span><br><span class="line">       String memberPhone = userRegisterEvent.getMemberPhone();</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotBlank(memberPhone)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试事件中发生异常对原有业务的影响,短信发送失败！！！！"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       log.info(<span class="string">"[Second onApplicationEvent][给用户(&#123;&#125;) 发送短信]"</span>, memberPhone);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204225825.png" alt="短信观察者执行发生异常"></p>
<p>可能有的小伙伴想，观察者执行异常导致事务回滚，本质上来说这种方式实现的观察者模式，其实还是在一个线程中同步执行的。那我就在观察者中捕获所有的异常或者用户注册成功之后异步发布事件。</p>
<ul>
<li><strong>捕获所有异常</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            SecondVersionUserRegisterEvent userRegisterEvent = (SecondVersionUserRegisterEvent) event;</span><br><span class="line">            Long memberId = userRegisterEvent.getMemberId();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试事件中发生异常对原有业务的影响,短信发送失败！！！！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"[Second addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, memberId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"发放优惠劵发生异常"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>异步发布事件</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 3、异步发布事件通知,这样的有可能事务还没有提交，则异步线程读取不到数据库中的数据</span></span><br><span class="line">CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">&#125;);</span><br><span class="line">voidCompletableFuture.exceptionally(exception -&gt; &#123;</span><br><span class="line">    log.error(<span class="string">"发生了异常"</span>, exception);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一种方式可以解决事务回滚的问题，但是呢感觉会有点low！</p>
<p>第二种方式假如观察者中查询会员的信息，可能出现查不到，因为可能事务还没有提交。</p>
<h5 id="使用-TransactionalEventListener-实现事务提交之后才执行观察者"><a href="#使用-TransactionalEventListener-实现事务提交之后才执行观察者" class="headerlink" title="使用 @TransactionalEventListener 实现事务提交之后才执行观察者"></a>使用 <code>@TransactionalEventListener</code> 实现事务提交之后才执行观察者</h5><p>使用起来很简单，直接在对应的观察者方法上添加该注解即可。<code>@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeCouponService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span>(phase = TransactionPhase.AFTER_COMMIT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCoupon</span><span class="params">(ThreeUserRegisterEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"测试事件中发生异常对原有业务的影响"</span>);</span><br><span class="line">        Long memberId = event.getMemberId();</span><br><span class="line">        <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"测试事件中发生异常对原有业务的影响,优惠券发送失败！！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">" Version=3 [addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意一定要在 <code>register()</code> 方法上添加 <code>@Transactional</code> 注解</strong>，不然 <code>register()</code> 方法中有抛出异常之后，会有下面的错误提示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息: Closing org.springframework.context.support.GenericApplicationContext<span class="meta">@a</span>67c67e: </span><br><span class="line">startup date [Thu Feb <span class="number">04</span> <span class="number">18</span>:<span class="number">06</span>:<span class="number">53</span> CST <span class="number">2021</span>]; root of context hierarchy</span><br></pre></td></tr></table></figure>


<p><strong>@Transactional一定要加上</strong>不然方法体内有一次抛出会有上的错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Result</span> <span class="title">register</span>(<span class="title">String</span> <span class="title">phone</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">    log.info(<span class="string">"[Second register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, phone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、 保存用户(假设这是)</span></span><br><span class="line">    <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">    Long memberId = entity.getId();</span><br><span class="line">    log.info(<span class="string">"插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, memberId);</span><br><span class="line">    <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"故意抛出异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="keyword">new</span> ThreeUserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，实现 <code>register()</code> 事务提交之后，再发布事件还有两种方式：</p>
<ul>
<li>使用事务模板TransactionTemplate</li>
</ul>
<ol>
<li>使用之前需要在配置文件中配置事务模板</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 transactionTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在代码中使用事务模板提交事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[线程name=&#123;&#125;,register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, Thread.currentThread().getName(), phone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、 保存用户(假设这是)</span></span><br><span class="line">        Long memberId = transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            Long result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BizLocalMessageEntity entity = <span class="keyword">new</span> BizLocalMessageEntity();</span><br><span class="line">                ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">                entity.setBizModule((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                entity.setBizNo(<span class="string">""</span> + random.nextInt(<span class="number">200000</span>));</span><br><span class="line">                entity.setBizType((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                entity.setMsg(<span class="string">"消息内容"</span>);</span><br><span class="line">                entity.setMsgDesc(<span class="string">"消息备注"</span>);</span><br><span class="line">                entity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">                entity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">                result = entity.getId();</span><br><span class="line">                log.info(<span class="string">"Version5 插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, result);</span><br><span class="line">                <span class="keyword">if</span> (affectRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//throw new RuntimeException("测试主要业务失败，事件是否会发布执行");</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"业务失败发生异常"</span>, e);</span><br><span class="line">                <span class="comment">// 标记事务回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"事务执行情况 用户的id= [&#123;&#125;]"</span>, memberId);</span><br><span class="line">        <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、异步发布事件通知</span></span><br><span class="line">            log.info(<span class="string">"发布注册成功事件"</span>);</span><br><span class="line">            applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用TransactionSynchronizationManager</li>
</ul>
<p>这个可以直接使用无需配置，重写TransactionSynchronizationAdapter的afterCommit()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Result</span> <span class="title">register</span>(<span class="title">String</span> <span class="title">phone</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">    log.info(<span class="string">"[Version4 register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, phone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、 保存用户(假设这是)</span></span><br><span class="line">    BizLocalMessageEntity entity = <span class="keyword">new</span> BizLocalMessageEntity();</span><br><span class="line">    ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">    entity.setBizModule((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    entity.setBizNo(<span class="string">""</span> + random.nextInt(<span class="number">100000</span>));</span><br><span class="line">    entity.setBizType((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    entity.setMsg(<span class="string">""</span>);</span><br><span class="line">    entity.setMsgDesc(<span class="string">""</span>);</span><br><span class="line">    entity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">    entity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Long memberId = entity.getId();</span><br><span class="line">    <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">    log.info(<span class="string">"Version4 插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, memberId);</span><br><span class="line">    <span class="keyword">if</span> (affectRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//throw new RuntimeException("Version4 测试主要业务失败，事件是否会发布执行");</span></span><br><span class="line">    &#125;</span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.afterCommit();</span><br><span class="line">            <span class="comment">// 3、事务提交之后发布事件通知</span></span><br><span class="line">            applicationEventPublisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把目前的代码执行一下看看情况怎么样</p>
<img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204214744.png" style="zoom:50%;" alt="执行日志截图"/>


<p>从截图上看，我们目前已经通过好几种方式解决了观察者执行异常导致事务回滚的问题，但是也可以从截图中看出用户注册逻辑和对应的观察者都是在main线程中执行的，那我们可以让观察者异步执行吗？这样也可以加快代码的执行速度。这个问题当然也是可以解决的，接下来我们来解决这个问题：</p>
<ul>
<li>直接使用@Async注解</li>
</ul>
<p><strong>需要注意的是</strong>，使用这个注解一定要自定义线程池，不是它默认使用的是 <code>org.springframework.core.task.SimpleAsyncTaskExecutor</code> 。但这个 SimpleAsyncTaskExecutor 不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SixCouponService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@Order</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCoupon</span><span class="params">(SixUserRegisterEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"测试事件中发生异常对原有业务的影响"</span>, <span class="string">""</span>);</span><br><span class="line">        Long memberId = event.getMemberId();</span><br><span class="line">        log.info(<span class="string">"线程name=&#123;&#125;,[addCoupon][给用户(&#123;&#125;) 发放优惠劵]"</span>, Thread.currentThread().getName(), memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动异步线程来发布事件</li>
</ul>
<p>意思就是事务提交之后，判断事务提交成功则新建一个线程然后发布注册成功事件。事务提交成功可以前面提到的事务模板transactionTemplate和事务管理器TransactionSynchronizationManager。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 ... 执行注册逻辑</span></span><br><span class="line">        log.info(<span class="string">"[线程name=&#123;&#125;,register][执行用户(&#123;&#125;) 的注册逻辑]"</span>, Thread.currentThread().getName(), phone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、 保存用户(假设这是)</span></span><br><span class="line">        Long memberId = transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            Long result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BizLocalMessageEntity entity = <span class="keyword">new</span> BizLocalMessageEntity();</span><br><span class="line">                ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">                entity.setBizModule((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                entity.setBizNo(<span class="string">""</span> + random.nextInt(<span class="number">200000</span>));</span><br><span class="line">                entity.setBizType((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">                entity.setMsg(<span class="string">"消息内容"</span>);</span><br><span class="line">                entity.setMsgDesc(<span class="string">"消息备注"</span>);</span><br><span class="line">                entity.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">                entity.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> affectRow = bizLocalMessageMapper.insert(entity);</span><br><span class="line">                result = entity.getId();</span><br><span class="line">                log.info(<span class="string">"Version5 插入的affectRow= [&#123;&#125;],主键[&#123;&#125;]"</span>, affectRow, result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"业务失败发生异常"</span>, e);</span><br><span class="line">                <span class="comment">// 标记事务回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"事务执行情况 用户的id= [&#123;&#125;]"</span>, memberId);</span><br><span class="line">        <span class="keyword">if</span> (memberId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、异步发布事件通知</span></span><br><span class="line">            log.info(<span class="string">"发布注册成功事件"</span>);</span><br><span class="line">            CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">                applicationEventPublisher.publishEvent(<span class="keyword">new</span> SixUserRegisterEvent(<span class="keyword">this</span>, memberId, phone));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码修改之后执行，运行截图如下：</p>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204222111.png" alt="运行截图"><br>我们可以发现代码分别main、taskExecutor-1和taskExecutor-2 三个线程执行的，完美的解决了上面提到的问题。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204230251.png" alt="优化后的注册流程" style="zoom:50%;" />

<p>使用观察者模式之后的用户注册流程：</p>
<img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210204230429.png" alt="优化后的注册流程" style="zoom:50%;" />
      
    </div>
         
            <div>
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>Sam</a>
    </li>
    <li><span>发布时间: </span>2021-02-04 20:44:34</li>
    <li><span>最后更新: </span>2021-02-04 23:19:51</li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/post/5b3d1989.html" target="_blank" title="解耦神器之观察者模式">https://ydstudios.gitee.io/post/5b3d1989.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a>
      许可协议，转载请保留原文链接及作者!
    </li>
  </ul>
<div>
         
    <footer class="article-footer">
      <a data-url="https://ydstudios.gitee.io/post/5b3d1989.html" data-id="ckkr19epr006qkay1gvszd91w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">观察者模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/post/cd1b2f51.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older << </strong>
      <div class="article-nav-title">船新版本的策略模式，你一定没有见过</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Sam<br>
      <!--Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>-->
      <p>备案号:<a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">苏ICP备17069935号-1</a></p>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/links" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="https://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>