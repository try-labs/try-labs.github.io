<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>分布式锁实现方案到底有哪些 | Sam的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言前面几篇文章从系统架构方式的演进，谈到了单体架构、分布式架构的优缺点，其中特意说到了分布式架构由于功能的拆分，导致系统出现了不能保证数据一致性的问题，即分布式事务问题，从而引出了几种分布式事务的解决方案。文章的篇幅大都在说分布式事务，其实分布式系统中还有一个重要角色–分布式锁，一直没有提及。今天这篇文章我们就将光环移到分布式锁的身上，来说说分布式锁的那些事吧！">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式锁实现方案到底有哪些">
<meta property="og:url" content="https:&#x2F;&#x2F;ydstudios.gitee.io&#x2F;post&#x2F;3c363844.html">
<meta property="og:site_name" content="Sam的个人博客">
<meta property="og:description" content="前言前面几篇文章从系统架构方式的演进，谈到了单体架构、分布式架构的优缺点，其中特意说到了分布式架构由于功能的拆分，导致系统出现了不能保证数据一致性的问题，即分布式事务问题，从而引出了几种分布式事务的解决方案。文章的篇幅大都在说分布式事务，其实分布式系统中还有一个重要角色–分布式锁，一直没有提及。今天这篇文章我们就将光环移到分布式锁的身上，来说说分布式锁的那些事吧！">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210228105900.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210228154747.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210228145255.png">
<meta property="og:updated_time" content="2021-03-13T07:09:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;ydstudios&#x2F;blogImage&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210228105900.png">
  
    <link rel="alternate" href="/atom.xml" title="Sam的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Sam的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/links">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ydstudios.gitee.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-分布式锁实现方案到底有哪些" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/3c363844.html" class="article-date">
  <time datetime="2021-02-28T10:19:27.000Z" itemprop="datePublished">2021-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      分布式锁实现方案到底有哪些
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面几篇文章从系统架构方式的演进，谈到了单体架构、分布式架构的优缺点，其中特意说到了分布式架构由于功能的拆分，导致系统出现了不能保证数据一致性的问题，即分布式事务问题，从而引出了几种分布式事务的解决方案。文章的篇幅大都在说分布式事务，其实分布式系统中还有一个重要角色–分布式锁，一直没有提及。今天这篇文章我们就将光环移到分布式锁的身上，来说说分布式锁的那些事吧！</p>
<a id="more"></a>

<h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>说分布式锁之前，我们先说一说什么是锁、锁有什么作用？一般来说当代码中会有多个线程任务访问同一共享资源时,就会出现冲突或者错误，目前解决这种问题都是采用序列化访问共享资源的解决方案,即将共享资源放在某一代码块中并加锁,某一时刻只能有一个线程访问该代码块。从而我们可以得出结论，锁是一种方案，一种解决多线程访问共享资源不出问题的解决方案。</p>
<h3 id="为什么需要分布式锁-distributed-lock"><a href="#为什么需要分布式锁-distributed-lock" class="headerlink" title="为什么需要分布式锁(distributed lock)"></a>为什么需要分布式锁(distributed lock)</h3><p>Java中提供了很多种类丰富的锁，每种锁因其特性的不同，可以在适当的场景下展现出非常高的效率，具体有哪些锁此处暂时也按下不表。Java中提供的锁，例如<code>synchronized</code>、<code>ReentrantLock</code>之类的锁，只能在单机JVM中使用，可以称之为<strong>单机锁</strong>。可在分布式系统环境下，一个功能可能会涉及到多个服务，不同的服务又部署在不同的服务器不同的JVM中，这样Java提供的单机锁就无能为力了。可是在分布式环境下，我们仍然需要有一个类似<code>synchronized</code>的锁，获得到锁的服务可以正确的访问共享资源。在分布式环境下能提供这样服务的我们称之为<strong>分布式锁</strong>。</p>
<blockquote>
<p>锁的种类很丰富，例如乐观锁、悲观锁；公平锁、非公平锁；可重入锁、不可重入锁；共享锁、排他锁；本文只考虑分布式情况下的<strong>排他锁</strong>。</p>
</blockquote>
<p>分布式系统专家Martin在他的文章中写了他对分布式锁的理解，以下便是节选（原文为英文此处翻译成了中文）：</p>
<p>锁的目的是确保在可能尝试执行同一工作的多个节点中，只有一个节点实际执行了该工作（一次至少只有一个节点）。这项工作可能是将一些数据写入共享存储系统，执行一些计算，调用一些外部API，等等。在较高的层次上，您可能希望在分布式应用程序中使用锁的原因有两个：一是为了效率，二是为了正确性。为了区分这些情况，您可以询问如果锁定失败会发生什么：</p>
<ul>
<li><p>效率：使用锁可以避免不必要地重复两次相同的工作（例如，一些昂贵的计算）。如果锁定失败，并且两个节点最终执行相同的工作，结果是成本略有增加（您最终向AWS支付的费用比其他情况下多5美分）或带来轻微不便（例如，用户最终两次收到相同的电子邮件通知）。</p>
</li>
<li><p>正确性：使用锁可以防止并发进程互相攻击，从而破坏系统的状态。如果锁定失败，并且两个节点同时处理同一数据段，则会导致文件损坏、数据丢失、永久性不一致、患者服用的药物剂量错误或其他严重问题。</p>
</li>
</ul>
<p>两者都是想要锁定的有效情况，但是您需要非常清楚要处理的是哪一种。</p>
<h3 id="分布式锁有什么要求"><a href="#分布式锁有什么要求" class="headerlink" title="分布式锁有什么要求"></a>分布式锁有什么要求</h3><p>前面我们说到了分布式锁的使用场景，从中我们可以得出一些分布式锁的基础要求，我总结大概有以下三点：</p>
<ol>
<li><p>互斥性<br>在同一时间，锁只能被一个客户端的一个线程获得。</p>
</li>
<li><p>安全性<br>只有获得锁的线程才能释放锁，并且要有超时机制，客户端崩溃之后要能自动释放锁，不能出现死锁。</p>
</li>
<li><p>可用性<br>高性能的获得锁和释放锁，且不能有单点故障。</p>
</li>
</ol>
<h3 id="分布式锁的简单实现"><a href="#分布式锁的简单实现" class="headerlink" title="分布式锁的简单实现"></a>分布式锁的简单实现</h3><p>根据锁资源本身的安全性，我们可以将分布式锁分为两大类：</p>
<ul>
<li><p>基于异步复制的中间件，如MySQL、Redis等等</p>
</li>
<li><p>基于paxos协议的分布式一致性的中间件，如zookeeper、etcd等等</p>
</li>
</ul>
<h4 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h4><p>首先说下结论，<strong>不建议使用基于数据库实现分布式锁</strong>。</p>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>使用MySQL的唯一索引加上行锁机制,由线程名threadName、类名className、方法名methodName三个字段创建唯一索引。</p>
<p>在要获得锁的时候向DB中写一条记录，这条记录主要包含主键、当前占用锁的线程名threadName、类名className、方法名methodName、锁的有效截止时间deadline和创建时间createTime等，如果插入成功表示当前线程获取到了锁，如果插入失败那么证明锁被其他客户端的线程获取。释放分布式锁的时候，客户端直接删除对应的记录即可。如果客户端崩溃了，不能自行删除对应的记录，则需要一个定时任务补偿，查询当前时间已经大于锁的有效截止时间deadline的记录，删除即可。</p>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210228105900.png" alt="分布式锁表结构"></p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>优点</li>
</ul>
<ol>
<li>使用MySQL实现简单，MySQL的唯一索引加上行锁机制，可以保证在同一时刻只会有一个客户端的一个线程获得锁。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li><p>MySQL存在单点故障，并发量大的时候吞吐量急剧下降。如果要实现高可用的话，则需要搭建MySQL集群，如果采用异步复制的方式同步数据到slave，存在数据延迟或者数据丢失的风险，这样就会出现客户端已经在master数据库上获得到了锁，但数据未同步到slave时master宕机，集群高可用重新选举出新的master之后，客户端又可以获得同一把锁，这样的情况就不满足分布式锁的互斥性要求了。但是，如果MySQL集群采用半同步复制或者全同步复制到slave，则锁的性能、吞吐量又降低了很多。</p>
</li>
<li><p>锁失效机制实现的不够优雅，而且补偿任务删除数据会存在一定时间的延迟，延迟这段时间锁不可用。</p>
</li>
</ol>
<h4 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h4><p>Redis是开发中常用的中间件，后端的开发也基本上都使用过。Redis基本上都是内存操作，性能好、速度快。接下来我们来用Redis实现一个简版分布式锁。</p>
<h5 id="Redis如何实现分布式锁"><a href="#Redis如何实现分布式锁" class="headerlink" title="Redis如何实现分布式锁"></a>Redis如何实现分布式锁</h5><p>我们用Redis的set命令实现加锁，用lua脚本来释放锁，用key的过期机制来保障分布式锁不会死锁。</p>
<blockquote>
<p>可能有些头铁的老哥使用set加锁；使用expire命令设置key的有效期；使用del命令释放锁。别不相信，我还看过相关的文章，文章作者对不正确使用Redis实现分布式锁，导致出现商品出现超卖进行复盘。</p>
</blockquote>
<h6 id="实现加锁"><a href="#实现加锁" class="headerlink" title="实现加锁"></a>实现加锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure>
<p>从 Redis 2.6.12 版本开始，Redis对set命令进行了一系列的升级。 SET 命令的行为可以通过一系列参数来修改：</p>
<ul>
<li><p>EX seconds：将键的过期时间设置为 seconds 秒。执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。</p>
</li>
<li><p>PX milliseconds：将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。</p>
</li>
<li><p>NX：只在键不存在时，才对键进行设置操作。执行 SET key value NX 的效果等同于执行 SETNX key value 。</p>
</li>
<li><p>XX：只在键已经存在时，才对键进行设置操作。</p>
</li>
</ul>
<p>对于返回值的升级，从 Redis 2.6.12 版本开始， SET 命令只在设置操作成功完成时才返回 OK；如果命令使用了 NX 或者 XX 选项；但是因为条件没达到而造成设置操作未执行；那么命令将返回空(nil)。</p>
<p>我们来验证一下，执行两次以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set bizLock randomValue EX 20  NX</span><br></pre></td></tr></table></figure>
<p>randomValue是由客户端生成的一个随机字符串（可以使用UUID生成），相当于是客户端持有锁的标志。<br>NX 表示只有当 bizLock 对应的key值不存在的时候才能SET成功，相当于只有第一个请求的客户端才能获得锁。<br>EX 20 表示这个锁有效期20秒。</p>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210228154747.png" alt="验证set命令"></p>
<p>确实如Redis的文档所说，SET 命令只在设置操作成功完成时才返回 OK；如果命令使用了 NX 或者 XX 选项；但是因为条件没达到而造成设置操作未执行；那么命令将返回空(nil)。这样一个命令就可以保证分布式锁的互斥性和安全性两个要求。</p>
<h6 id="实现解锁"><a href="#实现解锁" class="headerlink" title="实现解锁"></a>实现解锁</h6><p>前面说了有人直接使用<code>del</code>命令删除对应的key来实现解锁，这个是有问题的，很有可能误解锁。下面是一个分布式锁服务的流程图：</p>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210228145255.png" alt="分布式锁服务流程图"><br>由于客户端A在成功获得分布式锁之后，自身发生GC导致出现STW(stop the world)现象或者是发生了网络问题，客户端的业务操作还没有完成，分布式锁的有效期已经到了，锁已经被释放，可是这个情况客户端A并不知晓。然后客户端B向分布式锁服务请求锁，获得锁成功之后，处理自己的业务逻辑。客户端B业务处理完成释放分布式锁，客户端A从GC停顿或者网络问题中恢复过来，继续自己的业务处理。这个过程存在两个问题：</p>
<ol>
<li><p>假设客户端A在步骤5和6中间恢复过来，处理完业务使用<code>del</code>命令释放分布式锁，很明显他释放的是客户端B的锁，这个不符合分布式锁的安全性要求。</p>
</li>
<li><p>假设客户端A按照图中的流程一样，这样就意味着在同一时刻分布式系统中有两把一样的锁，导致业务处理重复出现错误数据。</p>
</li>
</ol>
<p>问题1，那是因为判断是否拥有锁和解锁是两个步骤，不具有原子性。对于这个问题，我们可以使用lua脚本来解锁。Redis 2.6 版本通过内嵌支持 Lua 环境，会单线程原子性执行 Lua 脚本，保证 Lua 脚本在处理的过程中不会被任意其它请求打断。</p>
<p>lua解锁脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call("get",KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call("del",KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>问题2，客户端发生GC导致停顿过久获得的分布式锁失效，且造成系统中同一时间拥有两把分布式锁。对于这种问题，建议在最终提交业务逻辑之前，再检查一下自身是否还拥有锁，拥有的话提交不拥有的业务回滚。当然，这种方案只是尽可能的减少出错的可能性，并不能完全避免问题发生。<br>另外就是建议，保证业务处理接口的幂等性。例如在数据库层面添加唯一索引，使用数据库进行兜底。</p>
<h5 id="Redis实现分布式锁优缺点"><a href="#Redis实现分布式锁优缺点" class="headerlink" title="Redis实现分布式锁优缺点"></a>Redis实现分布式锁优缺点</h5><ul>
<li>优点</li>
</ul>
<ol>
<li>代码实现起来简单，加锁解锁效率高。</li>
<li>客户端崩溃或者网络延迟也可以自动清除锁，保证不会阻塞所有流程。</li>
<li>Redis的优异的性能，全内存操作，可以支持很高的并发。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li><p>使用Redis实现分布式锁自然是不能使用单个Redis，这样必然有单点故障，起码要使用集群的Redis，例如主从架构的Redis集群。Redis是使用异步复制的方式同步数据到slave，存在数据延迟或者数据丢失的风险，这样就会出现客户端已经在master上获得到了锁，但数据未同步到slave时master宕机，集群高可用重新选举出新的master之后，客户端又可以获得同一把锁，打破分布式锁的互斥性要求。</p>
</li>
<li><p>Redis服务器时钟漂移问题。简单的说，就是Redis服务器上的时间比正常的时钟快，导致锁提前过期释放。但客户端仍然认为自己持有锁，打破分布式锁的互斥性要求。</p>
</li>
</ol>
<h5 id="RedLock算法实现分布式锁"><a href="#RedLock算法实现分布式锁" class="headerlink" title="RedLock算法实现分布式锁"></a>RedLock算法实现分布式锁</h5><p>假设我们有N个master节点，官方文档里将N设置成5，其实大等于3就行。</p>
<ol>
<li>获取当前服务器时间。</li>
<li>轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</li>
<li>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li>
<li>如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li>
<li>如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</li>
</ol>
<p>这个地方说说关于集群相关知识点，节点发生宕机，剩余多少节点集群仍然可以正确使用？<br>计算公式： 当前剩余节点数量 &gt; n/2</p>
<blockquote>
<p>注意公式里大于 &gt; 号，不带等于 = 号，这个主要是为了最大程度上防止选举投票时出现票数相同，提高投票效率。</p>
</blockquote>
<p>问题1: 多少个节点可以搭建成集群</p>
<ol>
<li><p>1个节点能否搭建集群 1-1 ?&gt;0.5 (1是最少宕机1个节点,条件不成立),1个节点不能搭建集群</p>
</li>
<li><p>2个节点能否搭建集群 2-1 ?&gt;1 (条件不成立),2个节点不能搭建集群</p>
</li>
<li><p>3个节点能否搭建集群 3-1 ?&gt;1.5 (条件成立),3个节点是搭建集群的最小单位</p>
</li>
<li><p>4个节点能否搭建集群 4-1 ?&gt;2 (条件成立),4个节点能搭建集群</p>
</li>
</ol>
<p>问题2: 为什么集群节点都是奇数,而不是偶数?</p>
<ol>
<li><p>3个节点允许宕机的最大的数量是几个节点? 3-2 &gt;1.5条件不成立，3-1 &gt;1.5条件成立，因此3个节点最多允许宕机1个节点.</p>
</li>
<li><p>4个节点允许宕机的最大的数量是几个节点? 4-2 &gt;2条件不成立，4-1 &gt;2条件成立，因此4个节点最多允许宕机1个节点。</p>
</li>
</ol>
<p>结论: 5个节点与6个节点搭建的集群最大都是容忍2个节点宕机,所以从成本的角度考虑,5个节点更节省资源。</p>
<h4 id="Zookeeper实现分布式锁"><a href="#Zookeeper实现分布式锁" class="headerlink" title="Zookeeper实现分布式锁"></a>Zookeeper实现分布式锁</h4><p>ZooKeeper是开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现。基于它可以实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。在这里我们就用它来实现以下分布式锁。</p>
<h5 id="Zookeeper如何实现分布式锁"><a href="#Zookeeper如何实现分布式锁" class="headerlink" title="Zookeeper如何实现分布式锁"></a>Zookeeper如何实现分布式锁</h5><h5 id="Zookeeper实现分布式锁优缺点"><a href="#Zookeeper实现分布式锁优缺点" class="headerlink" title="Zookeeper实现分布式锁优缺点"></a>Zookeeper实现分布式锁优缺点</h5><h4 id="如何抉择"><a href="#如何抉择" class="headerlink" title="如何抉择"></a>如何抉择</h4><p>[1]<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">分布式系统专家Martin的《How to do distributed locking》</a></p>

      
    </div>
         
            <div>
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>Sam</a>
    </li>
    <li><span>发布时间: </span>2021-02-28 10:19:27</li>
    <li><span>最后更新: </span>2021-03-13 15:09:52</li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/post/3c363844.html" target="_blank" title="分布式锁实现方案到底有哪些">https://ydstudios.gitee.io/post/3c363844.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网所有文章除特别声明外, 
      禁止未经授权转载，违者依法追究相关法律责任!
    </li>
  </ul>
<div>
         
    <footer class="article-footer">
      <a data-url="https://ydstudios.gitee.io/post/3c363844.html" data-id="ckm9a8er8005gqcy1d26z27xs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/post/b6f085c7.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer >> </strong>
      <div class="article-nav-title">
        
          如何保证RocketMQ消息不丢失
        
      </div>
    </a>
  
  
    <a href="/post/d06ff354.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older << </strong>
      <div class="article-nav-title">孔乙己“茴”字四种写法引起我对策略模式实现的思考</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Sam<br>
      <!--Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>-->
      <p>备案号:<a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">苏ICP备17069935号-1</a></p>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/links" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="https://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>