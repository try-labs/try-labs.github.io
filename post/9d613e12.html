<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java学习系列文章第二篇：字符串 | Sam的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在众多的编程语言里面，字符串都被广泛的使用。在Java中字符串属于对象，语言提供了String类来创建和操作字符串。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习系列文章第二篇：字符串">
<meta property="og:url" content="https://ydstudios.gitee.io/post/9d613e12.html">
<meta property="og:site_name" content="Sam的个人博客">
<meta property="og:description" content="在众多的编程语言里面，字符串都被广泛的使用。在Java中字符串属于对象，语言提供了String类来创建和操作字符串。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-06-29T21:44:13.000Z">
<meta property="article:modified_time" content="2019-12-09T15:03:26.000Z">
<meta property="article:author" content="Sam">
<meta property="article:tag" content="java">
<meta property="article:tag" content="String">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Sam的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Sam的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/links">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ydstudios.gitee.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java学习系列文章第二篇：字符串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/9d613e12.html" class="article-date">
  <time datetime="2018-06-29T21:44:13.000Z" itemprop="datePublished">2018-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java学习系列文章第二篇：字符串
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在众多的编程语言里面，字符串都被广泛的使用。在Java中字符串属于对象，语言提供了String类来创建和操作字符串。</p>
<a id="more"></a>
<h3 id="字符串String简单知识"><a href="#字符串String简单知识" class="headerlink" title="字符串String简单知识"></a>字符串String简单知识</h3><p>Java提供两种方式来定义字符串，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义字符使用单引号，定义字符串使用双引号；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值</span></span><br><span class="line">String str1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>通过对String源码的查看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以得出两点结论：</p>
<ol>
<li>Java中的String类被final修饰。在Java中被final修饰的类不允许被继承，并且成员方法默认被final修饰。在早期的JVM的版本，被final修饰的方法会被转为内嵌调用借此来提升执行效率，但是从Java1.5/6之后，这种方式就被取消了。在之后的版本里，final修饰类只是为了不让类被继承。</li>
<li>String类是通过char数组保存字符串的。</li>
</ol>
<p>对字符串的每一次操作，例如连接子串都会重新创建一个新的String对象。我们可以从String中的concat方法源码中可以看出这一点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当被连接的子串的长度为0时，直接返回自身，连接一个长度不为0的子串，通过char数组的系列操作，重新生成一个新的String对象。<br>所以在此要注意<strong>对String类对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。</strong></p>
<h3 id="深入理解字符串String"><a href="#深入理解字符串String" class="headerlink" title="深入理解字符串String"></a>深入理解字符串String</h3><p>上面写了两种定义字符串的方式，不知道大家知道这两种方式的区别和联系么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接赋值</span></span><br><span class="line">String str1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1==str2);</span><br><span class="line">System.out.println(str1==str3);</span><br><span class="line">System.out.println(str2==str4);</span><br></pre></td></tr></table></figure>
<p>你能直接说出上面的执行结果么？如果不能请继续往下看，能的话也请继续往下看。<br>具体的结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>在class文件中有一部分来存储编译期间生成的字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。在上述的代码中String str1 = “hello world”;和String str2 = new String(“hello world”);都在编译期生成了字面常量和符号引用，运行期间字面常量”hello world”都被存储在运行时常量池。JVM执行引擎会在运行时常量池中查找是否存在相同的字面常量，若有则直接将引用指向已经存在的字面常量；否则在运行时常量池中开辟一个新的空间来存储该字面量，并将引用指向该字面常量，通过这种方式来把String对象跟引用绑定。</p>
<p>通过new关键字生成对象这个过程是在堆heap中进行的，而在堆进行对象生成过程中，不会有检查对象是否已经存在这个行为。因此通过new来创建对象，创建出来的一定是新的对象，即在内存中有着新的内存地址，但字符串的内容是相同的。</p>
<p>下面是Java中不同变量在内存中存放的位置：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>内存位置</th>
</tr>
</thead>
<tbody><tr>
<td>new出来的对象</td>
<td>heap 堆</td>
</tr>
<tr>
<td>局部变量、基本数据类型</td>
<td>stack 栈</td>
</tr>
<tr>
<td>静态变量、字符串、常量</td>
<td>data segment 数据区</td>
</tr>
<tr>
<td>代码</td>
<td>code segment 代码区</td>
</tr>
</tbody></table>
<h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h3><p>为什么已经存在了String了，还会出现StringBuffer、StringBuilder？<br>如果一个字符串需要连接10000次其他的字符串，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        String string = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            string = string.concat(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码不断的new字符串对象，前面已经说了重要的一点<strong>对String类对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。</strong>，这种代码将会有多大的内存消耗。这个时候想必大家已经有了点答案。我将上述的代码稍微的修改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        String string = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            string += <span class="string">"hello"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两部分代码看似只有一点差异，其实两者的内存消耗有着天大的差别。我们通过javap命令来反编译.class文件。具体内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">D:\work\javaLearn\out\production\javaLearn&gt;javap -c Main</span><br><span class="line">Compiled from <span class="string">"Main.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: iconst_0</span><br><span class="line">       <span class="number">4</span>: istore_2</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: sipush        <span class="number">10000</span></span><br><span class="line">       <span class="number">9</span>: if_icmpge     <span class="number">38</span></span><br><span class="line">      12: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">15</span>: dup</span><br><span class="line">      16: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      <span class="number">19</span>: aload_1</span><br><span class="line">      20: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      23: ldc           #6                  // String hello</span><br><span class="line">      25: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      28: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">31</span>: astore_1</span><br><span class="line">      <span class="number">32</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">      <span class="number">35</span>: goto          <span class="number">5</span></span><br><span class="line">      <span class="number">38</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面反编译出来的字节码中可以看出一点门道：string+=”hello”的操作事实上会自动被JVM优化成StringBuilder类的append操作。</p>
<p>那么有人会问既然有了StringBuilder类，为什么还需要StringBuffer类？查看源代码便一目了然，事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说StringBuffer是线程安全的。</p>
<p>我们来看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String str1 = <span class="string">"I "</span>+<span class="string">"love "</span>+<span class="string">"you"</span>;</span><br><span class="line">        String str2 = <span class="string">"I "</span>;</span><br><span class="line">        String str3 = <span class="string">"love "</span>;</span><br><span class="line">        String str4 = <span class="string">"you "</span>;</span><br><span class="line"></span><br><span class="line">        String str5 = str2 + str3 + str4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用javap命令来反编译.class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">D:\work\javaLearn\out\production\javaLearn&gt;javap -c Main</span><br><span class="line">Compiled from <span class="string">"Main.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String I love you</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       3: ldc           #3                  // String I</span><br><span class="line">       <span class="number">5</span>: astore_2</span><br><span class="line">       6: ldc           #4                  // String love</span><br><span class="line">       <span class="number">8</span>: astore_3</span><br><span class="line">       9: ldc           #5                  // String you</span><br><span class="line">      <span class="number">11</span>: astore        <span class="number">4</span></span><br><span class="line">      13: new           #6                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">16</span>: dup</span><br><span class="line">      17: invokespecial #7                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      <span class="number">20</span>: aload_2</span><br><span class="line">      21: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">24</span>: aload_3</span><br><span class="line">      25: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">28</span>: aload         <span class="number">4</span></span><br><span class="line">      30: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      33: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">36</span>: astore        <span class="number">5</span></span><br><span class="line">      <span class="number">38</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>str1在编译之后就被直接赋值为”I love you”;str5却没有什么操作。综上所述我们可以得出一些结论：</p>
<ol>
<li>对于直接通过加号相连字符串效率高，因为编译器直接确定了它的值。就像上面的”I “+”love “+”you”;的字符串相加，在编译期间就被优化成了”I love you“。</li>
<li>对于间接相加的，形如str2 + str3 + str4;编译期不会进行优化。</li>
<li>对于执行效率来说StringBuilder &gt; StringBuffer &gt; String，但这个也不是绝对的。比如String str = “hello”+ “world”的效率就比 StringBuilder st  = new StringBuilder().append(“hello”).append(“world”)要高。但是，当字符串相加的操作或者字符改动的情况较少的时候，采用String肯定是比较好的；当字符串的操作较多的时候推荐使用StringBuilder，如果考虑到线程安全问题，无疑采用StringBuffer是最合适的。<h3 id="常见的字符串相关的面试题"><a href="#常见的字符串相关的面试题" class="headerlink" title="常见的字符串相关的面试题"></a>常见的字符串相关的面试题</h3></li>
<li>下面的代码输出的结果是什么？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"hello2"</span>; 　　</span><br><span class="line">String b = <span class="string">"hello"</span> + <span class="number">2</span>; 　　</span><br><span class="line">System.out.println((a == b));</span><br></pre></td></tr></table></figure>
结果是true，它String b = “hello” + 2; 被编译器优化成了String b = “hello2”; 所以运行时字符串a和b指向同一个对象。</li>
<li>下面的代码输出的结果是什么？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"hello2"</span>; 　  </span><br><span class="line">String b = <span class="string">"hello"</span>;       </span><br><span class="line">String c = b + <span class="number">2</span>;       </span><br><span class="line">System.out.println((a == c));</span><br></pre></td></tr></table></figure>
输出结果为:false。由于有符号引用的存在，所以  String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，通过StringBuilder生成了一个新的对象，因此这种方式生成的对象事实上是保存在堆上的。</li>
<li>下面的代码输出的结果是什么？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"hello2"</span>;</span><br><span class="line"><span class="keyword">final</span> String b = <span class="string">"hello"</span>; </span><br><span class="line">String c = b + <span class="number">2</span>; </span><br><span class="line">System.out.println((a == c));</span><br></pre></td></tr></table></figure>
输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = “hello” + 2;</li>
</ol>
<p>字符串的故事就暂时说到这里，后续有的话就继续更新。</p>

      
    </div>
         
            <div>
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>Sam</a>
    </li>
    <li><span>发布时间: </span>2018-06-29 21:44:13</li>
    <li><span>最后更新: </span>2019-12-09 23:03:26</li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/post/9d613e12.html" target="_blank" title="Java学习系列文章第二篇：字符串">https://ydstudios.gitee.io/post/9d613e12.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网所有文章除特别声明外, 
      禁止未经授权转载，违者依法追究相关法律责任!
    </li>
  </ul>
<div>
         
    <footer class="article-footer">
      <a data-url="https://ydstudios.gitee.io/post/9d613e12.html" data-id="ckso5w0fg001engsz0es48s3w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/" rel="tag">String</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/post/c4de9814.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer >> </strong>
      <div class="article-nav-title">
        
          Java学习系列文章第一篇：基本变量类型
        
      </div>
    </a>
  
  
    <a href="/post/d229aadf.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older << </strong>
      <div class="article-nav-title">CentOS 6.x 下安装Zookeeper</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Sam<br>
      <!--Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>-->
      <p>备案号:<a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">苏ICP备17069935号-1</a></p>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/links" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="https://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>