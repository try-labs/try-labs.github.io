<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MySQL常见加锁场景分析一 | Sam的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言在《MySQL中到底有哪些锁》一文中，描述了MySQL中存在的各种各样的锁，也大致说了一下各种锁出现的场景，但是整个文章通读下来，大家可能知道有这些锁了，或者啥也没有记住。今天这篇文章会找些实际的例子，来具体说说SQL加了什么锁。这样也好让大家加深理解，以便更好的解决真实开发中遇到的死锁问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL常见加锁场景分析一">
<meta property="og:url" content="https://ydstudios.gitee.io/post/412410.html">
<meta property="og:site_name" content="Sam的个人博客">
<meta property="og:description" content="前言在《MySQL中到底有哪些锁》一文中，描述了MySQL中存在的各种各样的锁，也大致说了一下各种锁出现的场景，但是整个文章通读下来，大家可能知道有这些锁了，或者啥也没有记住。今天这篇文章会找些实际的例子，来具体说说SQL加了什么锁。这样也好让大家加深理解，以便更好的解决真实开发中遇到的死锁问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210903151120.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907162548.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907143838.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907143937.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907144638.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907145323.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907145518.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907151825.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907152808.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907153034.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907154612.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907155212.png">
<meta property="og:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907155129.png">
<meta property="article:published_time" content="2021-09-03T14:58:08.000Z">
<meta property="article:modified_time" content="2021-09-09T11:10:24.909Z">
<meta property="article:author" content="Sam">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ydstudios/blogImage/raw/master/img/20210903151120.png">
  
    <link rel="alternate" href="/atom.xml" title="Sam的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Sam的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/links">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ydstudios.gitee.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MySQL常见加锁场景分析一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/412410.html" class="article-date">
  <time datetime="2021-09-03T14:58:08.000Z" itemprop="datePublished">2021-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MySQL常见加锁场景分析一
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在《MySQL中到底有哪些锁》一文中，描述了MySQL中存在的各种各样的锁，也大致说了一下各种锁出现的场景，但是整个文章通读下来，大家可能知道有这些锁了，或者啥也没有记住。今天这篇文章会找些实际的例子，来具体说说SQL加了什么锁。这样也好让大家加深理解，以便更好的解决真实开发中遇到的死锁问题。</p>
<a id="more"></a>

<img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210903151120.png" alt="你记住了么" style="zoom:50%;" />

<h4 id="加锁的约束"><a href="#加锁的约束" class="headerlink" title="加锁的约束"></a>加锁的约束</h4><p>一个SQL对记录加什么锁，这个里面其实有很多的道道的，不是一句话两句话就能说的清楚。（那你就长话短说呗）那么废话不多说，就先来说一说SQL为记录加锁到底有哪些条件约束。</p>
<ol>
<li>事务隔离级别：前面文章也说到过，间隙锁在一般情况下，只有在不小于可重复读的事务隔离级别下出现，但是特殊情况下，读已提交的隔离级别下也会有。这就很明确的告诉我们，SQL给记录加什么锁是受到事务隔离级别的影响的。</li>
<li>SQL执行中是否使用使用索引和索引的类型：我们都知道索引可以分为普通索引、唯一索引、主键索引、联合索引和全文索引等待。MySQL的锁也是基于索引实现的，SQL用到不同的索引和没有到索引，记录上加的锁肯定是不一样的。</li>
<li>查询的方式：SQL是精确查询、模糊查询还是范围查询。</li>
<li>SQL语句的类型：SELECT、INSERT、UPDATE、DELETE语句对记录加锁是不一样的。</li>
</ol>
<h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><ol>
<li>锁定读：指的是以下四种语句：</li>
</ol>
<ul>
<li>SELECT …… LOCK IN SHARE MODE</li>
<li>SELECT …… FOR UPDATE</li>
<li>UPDATE</li>
<li>DELETE</li>
</ul>
<p>快照读：</p>
<ul>
<li>在读未提交的级别下，每次都读取记录的最新版本。</li>
<li>在读已提交的级别下，每次都读取已经提交的版本。</li>
</ul>
<ol start="2">
<li>事务隔离级别对加锁的影响</li>
</ol>
<p>MySQL 的事务隔离等级对加什么锁有很大的影响，所以<strong>在分析具体的加锁场景时，首先要做的就是确定当前的是事务隔离级别</strong>。</p>
<ul>
<li><p>读未提交（Read Uncommitted 后续简称 RU）：读未提交，该级别下脏读、不可重复读、幻读都可能发生。基本没有该隔离级别应用的业务场景，所以直接忽略。</p>
</li>
<li><p>读已提交（Read Committed 后续简称 RC）：该级别下不可重复读、幻读都可能发生，脏读不允许发生。对当前读获取的数据加记录锁。</p>
</li>
<li><p>可重复读（Repeatable Read 后续简称 RR）：该级别下幻读都可能发生，脏读、不可重复读不可能发生，对当前读获取的数据加记录锁，同时对涉及的范围加间隙锁，防止新的数据插入导致幻读。</p>
</li>
<li><p>序列化（Serializable）：不在使用 MVCC 并发控制，直接基于锁的并发控制，不存在快照读，都是当前读，并发效率急剧下降。该事物隔离级别不建议使用，所以也不是本文重点。</p>
</li>
</ul>
<p>读未提交和序列化两个隔离级别因为各自的问题在实际的业务场景用的不多，本文就不对他俩再添笔墨，我们将重点关注<strong>读已提交</strong>和<strong>可重复读</strong>。</p>
<blockquote>
<p>对于这两个隔离级别，你们项目是选择了哪个？那又为什么选择某个级别，你有想过么？</p>
</blockquote>
<p>在这里给出个结论：一般情况下，在读已提交事务隔离级别下，<strong>加锁的基本单位是记录锁</strong>；在可重复读事务隔离级别下，<strong>加锁的基本单位是next key锁</strong>。另外，无论是在哪个隔离级别下，只要是唯一性搜索，并且读取的记录没有被标记删除，就为读取到的记录加记录锁。</p>
<p>满足以下四个条件就可以称之为唯一性搜索：</p>
<ol>
<li>匹配模式为精确匹配</li>
<li>使用的索引为主键或者唯一二级索引</li>
<li>如果使用的索引是唯一二级索引，那么该索引必须不能存NULL值</li>
<li>如果唯一二级索引包含多个列，那每个列都要被用到（注意联合索引的最左匹配原则）</li>
</ol>
<p>那接下来我们就来举例说明不同的SQL到底加了啥锁？</p>
<h4 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h4><p>在具体举例说明之前，我们先准备一些实验材料，例如创建个表<code>test</code>，具体机构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'名称'</span>,</span><br><span class="line">  <span class="string">`no`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'所在城市'</span>,</span><br><span class="line">  <span class="string">`gender`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">  <span class="string">`remark`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk_no`</span> (<span class="string">`no`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_name`</span> (<span class="string">`name`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_city_gender`</span> (<span class="string">`city`</span>,<span class="string">`gender`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">18</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>往表<code>test</code>里插入一些数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'张三'</span>, <span class="string">'133132'</span>, <span class="string">'n南京'</span>, <span class="string">'男'</span>, <span class="string">'epbujch'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span> <span class="keyword">VALUES</span> (<span class="string">'9'</span>, <span class="string">'王五'</span>, <span class="string">'123009'</span>, <span class="string">'h合肥'</span>, <span class="string">'男'</span>, <span class="string">'epbujchuf1k'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span> <span class="keyword">VALUES</span> (<span class="string">'10'</span>, <span class="string">'李翔'</span>, <span class="string">'123000'</span>, <span class="string">'n南京'</span>, <span class="string">'男'</span>, <span class="string">'3roa0'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span> <span class="keyword">VALUES</span> (<span class="string">'15'</span>, <span class="string">'李建'</span>, <span class="string">'123132'</span>, <span class="string">'b北京'</span>, <span class="string">'男'</span>, <span class="string">'g3ruwrnoa0'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span> <span class="keyword">VALUES</span> (<span class="string">'16'</span>, <span class="string">'李四'</span>, <span class="string">'123001'</span>, <span class="string">'s上海'</span>, <span class="string">'男'</span>, <span class="string">'ufuwrn1kg3roa0'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span> <span class="keyword">VALUES</span> (<span class="string">'17'</span>, <span class="string">'李丽'</span>, <span class="string">'123002'</span>, <span class="string">'g广东'</span>, <span class="string">'女'</span>, <span class="string">'ejchufuwrn1kg'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="在读已提交的事务隔离级别下"><a href="#在读已提交的事务隔离级别下" class="headerlink" title="在读已提交的事务隔离级别下"></a>在读已提交的事务隔离级别下</h4><p>SQL到底加什么锁由于涉及到很多条件，所以这里先限定事务隔离级别：读已提交。</p>
<h5 id="普通的SELECT语句"><a href="#普通的SELECT语句" class="headerlink" title="普通的SELECT语句"></a>普通的SELECT语句</h5><p>一般的情况下，系统里都是读多写少，那么我们就先看看普通的SELECT语句会加什么锁。例如下面的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>上面的SQL中where条件id=10，其实不管他是否是主键、其他的索引还是没有用到索引，他都不会对任何数据加锁，他只是一个普通的SQL语句，只进行快照读，只是在不同的事务隔离级别下读取的快照不同：</p>
<ul>
<li>在读已提交（READ COMMITTED）隔离级别下，在每次执行普通的SELECT语句是都会生成一个ReadView，这里理解成执行的时候生成一个快照。执行时不加锁。</li>
<li>在可重复读（REPEATABLE READ）隔离级别下，只在第一次执行普通的SELECT语句时生成一个ReadView，之后的SELECT操作都复用这个ReadView。执行时不加锁。</li>
</ul>
<p><strong>结论：</strong> 普通SELECT语句不加锁。</p>
<h4 id="加锁的流程"><a href="#加锁的流程" class="headerlink" title="加锁的流程"></a>加锁的流程</h4><p>MySQL中读取符合条件的记录大概过程如下：</p>
<ol>
<li>首先要定位到符合边界条件(即用到的索引)的第一条记录，把该记录作为当前记录。</li>
<li>给当前记录加锁。<br>不同的事务隔离级别加锁的类型不同，在读已提交级别下加记录锁；在可重复读的隔离级别下加next key 锁。</li>
<li>判断索引下推的条件是否成立。<br>就是把查询中使用到的二级索引相关的条件下推到存储引擎中去判断。如果当前记录符合下推到引擎层的条件，那么跳到步骤4继续执行。若是不符合直接获取当前记录的下一条记录，作为第一条记录，并跳回步骤2，然后继续执行。前面在判断是否符合下推的条件的同时，还会判断记录是否符合边界条件和是否是最后一条记录，若不符合或者是最后一条记录则直接向server层返回“查询完毕”的信息。另外，该步骤中，不管记录是否符合所有的条件，都不释放步骤2中加的锁。</li>
<li>执行回表操作。<br>如读取的是二级索引记录，则需要进行回表操作，获取到记录对应的聚簇索引记录并给改聚簇索引记录加记录锁。</li>
<li>判断边界条件是否成立。<br>记录符合边界条件，则跳到步骤6继续执行，否则在读已提交事务隔离级别下，释放掉加的锁；在可重复读的隔离级别下，不释放锁；并且向server层返回“查询完毕”的信息。</li>
<li>server层判断其余的条件是否成立。<br>除去索引下推的条件，其余的条件server层要判断条件是否成立。成立则将记录发送到客户端，不成立则在读已提交事务隔离级别下，释放掉加的锁；在可重复读的隔离级别下，不释放锁。</li>
<li>获取刚刚操作的记录所在的单向链表的下一条记录，当做第一条记录跳到第二步，然后重复上述的步骤。</li>
</ol>
<blockquote>
<p>通过主键到聚餐索引中获取完整的记录的过程就叫做<strong>回表</strong>，因为二级索引下面携带的主键信息，他不是相邻的id，即携带的主键是无序的，所以这个回表的过程是一个随机耗时的io操作。</p>
</blockquote>
<blockquote>
<p>索引下推（Index Condition PushDown，ICP），其实就是在查询过程中使用到的二级索引与之相关的搜索条件下推到存储引擎中判断，不是像之前返回到server层再判断。索引下推是一个使用到二级索引时一个简单但是有效的优化措施，他减少了回表次数。他适用于二级索引中的联合索引，且只适合SELECT语句，其他类型的SQL无效。</p>
</blockquote>
<h5 id="使用主键进行等值查询的场景"><a href="#使用主键进行等值查询的场景" class="headerlink" title="使用主键进行等值查询的场景"></a>使用主键进行等值查询的场景</h5><h6 id="使用SELECT-…-LOCK-IN-SHARE-MODE的场景"><a href="#使用SELECT-…-LOCK-IN-SHARE-MODE的场景" class="headerlink" title="使用SELECT … LOCK IN SHARE MODE的场景"></a>使用SELECT … LOCK IN SHARE MODE的场景</h6><p>假设有以下的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为啥要在事务中使用SELECT … LOCK IN SHARE MODE，因为在MySQL中，如果不显示的开启事务，那么每一条语句均为一个独立的事务。这样“SELECT * FROM test LOCK IN SHARE MODE;”的语句，一瞬间就执行完毕了，看不出加锁的效果。</p>
</blockquote>
<p><strong>结论：</strong>上面那个语句执行时需要访问聚餐索引中id=5的记录，给该记录加S型记录锁。如果id=5不存在则不加锁。</p>
<h6 id="使用SELECT-…-FOR-UPDATE的场景"><a href="#使用SELECT-…-FOR-UPDATE的场景" class="headerlink" title="使用SELECT … FOR UPDATE的场景"></a>使用SELECT … FOR UPDATE的场景</h6><p>假设有以下的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong>上面那个语句执行时需要访问聚簇索引中id=5的记录，给该记录加X型记录锁。如果id=5不存在则不加锁。</p>
<h6 id="使用-UPDATE-的场景"><a href="#使用-UPDATE-的场景" class="headerlink" title="使用 UPDATE 的场景"></a>使用 UPDATE 的场景</h6><p>使用UPDATE的场景里面还需要区分两种情况，一种是更新了索引，另外一种是没有更新索引的。</p>
<p>情况1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> remark = <span class="string">'xx'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>这里更新的字段没有涉及到索引列，所以加锁情况和使用<code>SELECT ... FOR UPDATE</code>的场景相同，就是给主键加了 一个X型排他锁。</p>
<p>情况2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">no</span> = <span class="string">'133132'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>上面的UPDATE的语句更新了二级索引列，他其实是用id = 5条件先定位到具体的聚簇索引位置，给该条记录加<code>X型记录锁</code>，然后由于他要更新二级索引列，所以也要给 索引 <code>uk_no</code>对应的记录加锁，也加上<code>X型记录锁</code>。</p>
<p><strong>结论：</strong> 先给主键加<code>X型记录锁</code>再给对应的二级索引加上<code>X型记录锁</code>。</p>
<h6 id="使用-DELETE-的场景"><a href="#使用-DELETE-的场景" class="headerlink" title="使用 DELETE 的场景"></a>使用 DELETE 的场景</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span> <span class="keyword">test</span>  <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><code>DELETE</code>不用多说，这种肯定也是加X型排他锁的情况。他的执行过程其实就是先在B+树中定位到这条记录的位置，然后获取这个记录的X锁，最后执行delete mark操作。（删除一条记录只是打一个标记，并不是马上删除的）如果有涉及到二级索引的，肯定是在获取主键的<code>X型记录锁</code>之后，再获取二级索引对应记录的<code>X型记录锁</code>。</p>
<p><strong>结论：</strong>先给主键加<code>X型记录锁</code>，若有涉及到二级索引的，再给二级索引对应记录的<code>X型记录锁</code>。看这个结论其实和前面 <code>UPDATE</code>的第二种情况的加锁结论相同。</p>
<h5 id="使用主键进行范围查询的场景"><a href="#使用主键进行范围查询的场景" class="headerlink" title="使用主键进行范围查询的场景"></a>使用主键进行范围查询的场景</h5><h6 id="使用SELECT-…-LOCK-IN-SHARE-MODE的场景-1"><a href="#使用SELECT-…-LOCK-IN-SHARE-MODE的场景-1" class="headerlink" title="使用SELECT … LOCK IN SHARE MODE的场景"></a>使用SELECT … LOCK IN SHARE MODE的场景</h6><p>假设有以下的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt;= <span class="number">15</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>
<p>这个SQL执行的时候，首先需要定位到符合条件的第一条记录id=5，然后顺着单向列表一个个往后找记录，符合条件的给加上<code>S型记录锁</code>。直到找到id=15的之后，正常来说他是一个主键，主键的特性就是全局唯一，id=15之后的记录，id一定是比他大的，但是实际上，SQL还是向后找到id=16的记录，先给他加锁，判断条件不符合之后，MySQL的Server再释放掉锁。所以这个过程中id=16的记录有先加锁，再释放锁的过程。</p>
<p><strong>结论：</strong>上述SQL给记录[5,9,10,15]加<code>S型记录锁</code>，id=16的记录先加锁后又释放锁。</p>
<h6 id="使用SELECT-…-FOR-UPDATE的场景-1"><a href="#使用SELECT-…-FOR-UPDATE的场景-1" class="headerlink" title="使用SELECT … FOR UPDATE的场景"></a>使用SELECT … FOR UPDATE的场景</h6><p>和使用<code>SELECT ... LOCK IN SHARE MODE</code>的场景类似，只不过加的是<code>X型记录锁</code>。</p>
<h6 id="使用-UPDATE-的场景-1"><a href="#使用-UPDATE-的场景-1" class="headerlink" title="使用 UPDATE 的场景"></a>使用 UPDATE 的场景</h6><p>使用UPDATE的场景里面还需要区分两种情况，一种是更新了索引，另外一种是没有更新索引的。</p>
<ul>
<li><p>更新二级索引<br>直接先给聚簇索引加X锁，然后给对应二级索引加X锁，依次类推。</p>
</li>
<li><p>未更新二级索引<br>只给聚簇索引加X锁，依次类推。</p>
</li>
</ul>
<blockquote>
<p>注意上面说到的边界记录，先加锁后又判断条件不符合又释放锁的情况</p>
</blockquote>
<h6 id="使用-DELETE-的场景-1"><a href="#使用-DELETE-的场景-1" class="headerlink" title="使用 DELETE 的场景"></a>使用 DELETE 的场景</h6><p>使用 <code>DELETE</code> 的和使用 <code>UPDATE</code> 的场景相同，就不在赘述了。</p>
<h5 id="使用二级索引进行等值查询的场景"><a href="#使用二级索引进行等值查询的场景" class="headerlink" title="使用二级索引进行等值查询的场景"></a>使用二级索引进行等值查询的场景</h5><p>这里的二级索引，不单单指的是普通的二级索引，也包含唯一二级索引。因为两者在加锁的过程是一样的，这里就一起说明了。<br>我们都知道二级索引相对于聚簇索引的区别，类似下面图一样：</p>
<img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907162548.png" alt="二级索引相对于聚簇索引的区别" style="zoom:50%;" />

<p>二级索引只保存索引列和主键，聚簇索引保存整个记录的数据。假设有SQL对二级索引加锁，但是不对主键进行加锁，会出现什么问题？这样就会有其他的事务对主键进行修改，导致二级索引对应的数据发生了错误；所以某事务对二级索引加锁时，同时也要获取聚餐索引上的锁。</p>
<h6 id="使用SELECT-…-LOCK-IN-SHARE-MODE的场景-2"><a href="#使用SELECT-…-LOCK-IN-SHARE-MODE的场景-2" class="headerlink" title="使用SELECT … LOCK IN SHARE MODE的场景"></a>使用SELECT … LOCK IN SHARE MODE的场景</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">no</span>=<span class="string">'123132'</span>  <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>
<p>上面的SQL，他首先通过二级索引 <code>uk_no</code>定位到满足<code>no=&#39;123132&#39;</code>条件的记录，给他加上<code>S型记录锁</code>，再回表给对应的聚簇索引加一个<code>S型记录锁</code>。</p>
<blockquote>
<p>这里的二级索引如果是一个普通的二级索引，譬如是<code>idx_name</code>,结果也是一样的。那是因为Innodb引擎对等值匹配的条件进行了特殊的处理，规定Innodb引擎在处理等值匹配时，在查找当前记录的下一条记录时，在对其加锁前要直接判断该记录是否满足等值匹配的条件，如果不满足直接返回，满足再加锁之后返回给server层。</p>
</blockquote>
<p><strong>结论：</strong>使用二级索引进行SELECT … LOCK IN SHARE MODE时对二级索引及其后面的索引加<code>S型记录锁</code>，同时给聚簇索引也加<code>S型记录锁</code>。</p>
<h6 id="使用SELECT-…-FOR-UPDATE的场景-2"><a href="#使用SELECT-…-FOR-UPDATE的场景-2" class="headerlink" title="使用SELECT … FOR UPDATE的场景"></a>使用SELECT … FOR UPDATE的场景</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">no</span>=<span class="string">'123132'</span>  <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>
<p>这个加锁基本上和使用<code>SELECT ... LOCK IN SHARE MODE</code>的场景类似，区别只在于前者加的是<code>S型记录锁</code>，而这里给二级索引和聚簇索引加的是<code>X型记录锁</code>。</p>
<h6 id="使用-UPDATE-的场景-2"><a href="#使用-UPDATE-的场景-2" class="headerlink" title="使用 UPDATE 的场景"></a>使用 UPDATE 的场景</h6><p>这个和<code>SELECT ... FOR UPDATE</code>的场景类似，只更新普通的字段时，只给二级索引和对应的聚簇索引加<code>X型记录锁</code>。若同时更新了其他的索引，也要给对应的索引记录加<code>X型记录锁</code>。</p>
<h6 id="使用-DELETE-的场景-2"><a href="#使用-DELETE-的场景-2" class="headerlink" title="使用 DELETE 的场景"></a>使用 DELETE 的场景</h6><p>这个和<code>UPDATE</code>的场景相同，就不重复说了。</p>
<h5 id="使用二级索引进行范围查询的场景"><a href="#使用二级索引进行范围查询的场景" class="headerlink" title="使用二级索引进行范围查询的场景"></a>使用二级索引进行范围查询的场景</h5><p>这里的二级索引包含普通的二级索引和唯一二级索引。</p>
<h6 id="使用SELECT-…-LOCK-IN-SHARE-MODE的场景-3"><a href="#使用SELECT-…-LOCK-IN-SHARE-MODE的场景-3" class="headerlink" title="使用SELECT … LOCK IN SHARE MODE的场景"></a>使用SELECT … LOCK IN SHARE MODE的场景</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">FORCE</span> <span class="keyword">INDEX</span>(uk_no) <span class="keyword">WHERE</span> <span class="keyword">no</span>&lt;=<span class="string">'123001'</span>  <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为目前表里的数据太少，MySQL有可能认为全表扫描更快就不走索引了，这里为了不干扰结果，所以这里用FORCE INDEX强制让SQL走索引。</p>
</blockquote>
<p><strong>结论：</strong> 按照前文的SQL加锁流程的叙述，这里给<code>uk_no</code>索引[123000,123001,123002]加<code>S型记录锁</code>,以及对应的聚簇索引[10,16]也加<code>S型记录锁</code></p>
<h6 id="使用SELECT-…-FOR-UPDATE的场景-3"><a href="#使用SELECT-…-FOR-UPDATE的场景-3" class="headerlink" title="使用SELECT … FOR UPDATE的场景"></a>使用SELECT … FOR UPDATE的场景</h6><p>这个和使用<code>SELECT ... LOCK IN SHARE MODE</code>的场景类似，只不过加的是<code>X型记录锁</code>。<br><strong>结论：</strong>按照前文的SQL加锁流程的叙述，这里给<code>uk_no</code>索引[123000,123001,123002]加<code>X型记录锁</code>,以及对应的聚簇索引[10,16]也加<code>X型记录锁</code>。</p>
<h6 id="使用-UPDATE-的场景-3"><a href="#使用-UPDATE-的场景-3" class="headerlink" title="使用 UPDATE 的场景"></a>使用 UPDATE 的场景</h6><p>同理，<code>UPDATE</code>也是分两种情况，更新了索引和未更新索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SQL1</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> remark=<span class="string">'222'</span> <span class="keyword">WHERE</span> <span class="keyword">no</span>&lt;=<span class="string">'123002'</span>;</span><br><span class="line"><span class="comment"># SQL2</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'大刀王五'</span> <span class="keyword">WHERE</span> <span class="keyword">no</span>&lt;=<span class="string">'123002'</span>;</span><br></pre></td></tr></table></figure>
<p>假设SQL1使用到了索引<code>uk_no</code>,上面的SQL也就是先给索引<code>uk_no</code>[123000,123001,123002,123009]加<code>X型记录锁</code>和对应的聚簇索引记录[10,16，17]也加<code>X型记录锁</code>。</p>
<p>假设SQL2使用到了索引<code>uk_no</code>,上面的SQL也就是先给索引<code>uk_no</code>[123000,123001,123002,123009]加<code>X型记录锁</code>、索引<code>idx_name</code>[李翔,李四,李丽]和对应的聚簇索引记录[10,16,17]也加<code>X型记录锁</code>。</p>
<h6 id="使用-DELETE-的场景-3"><a href="#使用-DELETE-的场景-3" class="headerlink" title="使用 DELETE 的场景"></a>使用 DELETE 的场景</h6><p>这个和<code>UPDATE</code>的场景相同，就不重复说了。</p>
<h5 id="使用-INSERT-的场景"><a href="#使用-INSERT-的场景" class="headerlink" title="使用 INSERT 的场景"></a>使用 INSERT 的场景</h5><p><code>INSERT</code>加什么锁情况比较复杂。一般情况下执行INSERT语句是不需要加锁的，但是如果一个事务T1插入数据，另外一个事务T2给这个数据使用DELETE、UPDATE、INSERT、SELECT … LOCK IN SHARE MODE甚至是SELECT … FOR UPDATE加锁，那就是不一样的情况了。在前面的文章(MySQL中到底有哪些锁)中有提到过这个场景。INSERT这里的大部分场景可以通过SQL展现具体加了什么锁，能展示的我就直接给出展示，毕竟要以事实说话嘛！</p>
<p>在可重复读的事务隔离级别下，如果一个即将插入的间隙已经被其他事务加了Gap锁，则本次的插入操作会阻塞，并将间隙上加入一个自己的间隙锁。这个是<strong>可重复读与读已提交事务隔离级别的差异</strong>。</p>
<p>假设事务T1插入了一条记录，但是未提交事务。这个时候其他事务，使用DELETE、UPDATE、INSERT、SELECT … LOCK IN SHARE MODE甚至是SELECT … FOR UPDATE加锁，这个时候MySQL是怎么处理的？</p>
<p>这些情况想都不要想，其他事务肯定是不能获取到这条记录的任何形式的锁，为什么这么说？还是那个老一套的答案：脏读、脏写的问题。</p>
<ul>
<li>假设其他事务T2能够获取这条记录的S锁，那不就是一个事务读取了另一个事务未提交的数据，这种情况不就是脏读。</li>
<li>假设其他事务T2能够获取这条记录的X锁进行修改，那不就是一个事务修改了另一个未提交事务修改的数据，这不就是发生了脏写。</li>
</ul>
<p>这又是脏读又是脏写的，这个是可用事务不可容忍的。所以MySQL开发者为了解决这个问题做了以下的动作：<strong>事务T2帮助事务T1，让事务T1给记录加一个X锁，事务T2自己为获得对应的锁进行等待。</strong> 事情又完美解决了，不会发生脏读或者幻读了。</p>
<p>接下来我们就来一一介绍不同场景的加锁区别：</p>
<ol>
<li>同一个SQL在不同事务中执行<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> ( <span class="keyword">name</span>, <span class="keyword">no</span>, city, gender, remark)</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">'杨丽'</span>, <span class="string">'123003'</span>, <span class="string">'d东莞'</span>, <span class="string">'女'</span>, <span class="string">'ejufuwrn1kg'</span>);</span><br></pre></td></tr></table></figure>
具体的执行截图如下：<br>事务T1：<br><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907143838.png" alt="事务T1"></li>
</ol>
<p>事务T2：<br><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907143937.png" alt="事务T2"></p>
<p>从图中就可以看出事务1执行完INSERT语句后，再去事务2中执行同样的SQL时，事务2阻塞了。使用SQL查询当前事务加锁情况，具体如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> trx.trx_id,trx.trx_state,trx.trx_query,trx.trx_isolation_level,</span><br><span class="line">trx.trx_rows_locked,lock_mode,locks.lock_type,lock_index,lock_data</span><br><span class="line"><span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TRX trx</span><br><span class="line"><span class="keyword">JOIN</span> INFORMATION_SCHEMA.INNODB_LOCKS locks <span class="keyword">ON</span> trx.trx_id = locks.lock_trx_id;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907144638.png" alt="事务加锁情况"><br>从截图中我们可以看到，事务T1获取了索引<code>uk_no</code>的 123003 记录的X锁，事务T2获取了该记录的S锁。（这里我比较疑惑，为什么获得的是S锁，按理说应该是X锁啊)</p>
<ol start="2">
<li>同一个SQL指定同一个id在不同事务中执行</li>
</ol>
<p>还是上面的SQL，在事务T1执行完后，获取插入记录的主键id=20，然后事务T2将SQL主键指定为20进行插入，具体情况如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> (<span class="keyword">id</span>, <span class="keyword">name</span>, <span class="keyword">no</span>, city, gender, remark)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'20'</span>, <span class="string">'杨丽'</span>, <span class="string">'123003'</span>, <span class="string">'d东莞'</span>, <span class="string">'女'</span>, <span class="string">'ejufuwrn1kg'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907145323.png" alt="指定id进行插入"><br>加锁情况：</p>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907145518.png" alt="加锁情况"><br>这时候锁已经是加在了主键id=20上，不再是锁二级索引 <code>uk_no</code>了，其他还是一样，事务T1获取主键的<code>X锁</code>，事务T2获取主键的<code>S锁</code>，读写不能并行，所以事务T2必须阻塞在那。</p>
<ol start="3">
<li>在二级索引<code>uk_no</code>后面的间隙插入数据</li>
</ol>
<p>在二级索引 <code>uk_no</code> 的 123003 记录后面插入记录123004，具体SQL如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> (<span class="keyword">name</span>, <span class="keyword">no</span>, city, gender, remark) </span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">'王凯丽'</span>, <span class="string">'123004'</span>, <span class="string">'d东莞'</span>, <span class="string">'女'</span>, <span class="string">'ejufuwrn1kg'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907151825.png" alt="事务T2"><br>这个SQL在事务T1执行之后，再执行没有任何问题，不会阻塞。因为在读以提交的事务隔离级别下，无需解决幻读的问题，即事务T1没有在（123002，正无穷大）上加间隙锁。</p>
<ol start="4">
<li>使用 <code>INSERT …… ON DUPLICATE KEY UPDATE</code>语句</li>
</ol>
<p>事务T1还是执行之前的那个SQL，事务T2执行下面的SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> ( <span class="keyword">name</span>, <span class="keyword">no</span>, city, gender, remark) </span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="string">'杨丽'</span>, <span class="string">'123003'</span>, <span class="string">'d东莞'</span>, <span class="string">'女'</span>, <span class="string">'ejufuwrn1kg'</span>)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> <span class="keyword">no</span>=<span class="string">'123004'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907152808.png" alt="事务T2执行情况"></p>
<p>两个事务加锁情况如下：</p>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907153034.png" alt="两个事务加锁情况"><br>从截图中我们可以看到，事务T1获取了索引uk_key2的443341830记录的<code>X锁</code>，事务T2也获取了该记录的<code>X锁</code>。这里的情况就正常了，都是获得记录的<code>X锁</code>了。</p>
<p><strong>结论：</strong> 在使用<code>INSERT …… ON DUPLICATE KEY UPDATE</code>语法来插入记录时，如果遇到主键或者唯一二级索引列的值重复，则对数据表中已经存在的记录加X锁，而不是S锁。</p>
<ol start="5">
<li><p>主键重复（duplicate key）</p>
<p>这里我们只需要执行一条SQL即可，插入的SQL主键是已经存在的，具体如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> ( <span class="keyword">id</span>,<span class="keyword">name</span>, <span class="keyword">no</span>, city, gender, remark) </span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="number">17</span>,<span class="string">'杨丽'</span>, <span class="string">'123003'</span>, <span class="string">'s深圳'</span>, <span class="string">'女'</span>, <span class="string">'ejufuwrn1kg'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907154612.png" alt="主键已经存在，重复插入"></p>
<p>这里直接使用上面查看事务加锁的SQL查询加锁情况，是查询不到数据的，具体原因前文也有提到。这里我们再执行一个SQL获取这个主键id=17记录的X锁，看看具体情况如何：</p>
</li>
</ol>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907155212.png" alt="直接获取主键id=17记录的X锁"></p>
<p><img src="https://gitee.com/ydstudios/blogImage/raw/master/img/20210907155129.png" alt="事务加锁情况"></p>
<p>   从图中可以看出，前者获得了记录的<code>S锁</code>，后者要获取记录的<code>X锁</code>。因为前者获得到了<code>S锁</code>，所以后者阻塞在那里。</p>
<p>   <strong>结论：</strong> 在主键重复的情况下，事务给重复的记录加上<code>S锁</code>。</p>
<blockquote>
<p>其实还有一种情况，这里就直接给出结论：无论是在哪个隔离级别，插入新记录时遇到唯一二级索引列重复，都会给已经存在B+树中的那条二级索引加next key 锁。这个就是间隙锁出现在读已提交隔离级别的特殊场景。</p>
</blockquote>
<h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>对应的字段没有索引或者查询没有使用上索引，导致全表扫描的情况。比如下面的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> remark = <span class="string">'epbujch'</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure>

<p>因为这个<code>remark</code>字段没有索引，所以只能采用全表扫描的方式执行SQL，在定位到第一条聚簇索引，给他加<code>S型记录锁</code>。因为没有形成索引下推的条件，就返回到server层判断，记录符合条件的就返回给客户端，不符合的就释放掉锁。</p>
<p>使用<code>SELECT ... FOR UPDATE</code>的场景和上面的结果类似，只不过加的是<code>X型记录锁</code>。<code>UPDATE</code>和<code>DELETE</code>也是给对应的聚簇索引加<code>X型记录锁</code>。若<code>UPDATE</code>更新了二级索引的话，还会给二级索引记录加<code>X型记录锁</code>。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>读已提交事物隔离级别的加锁情况，就暂时先介绍这么多，可重复读隔离级别的加锁情况再开篇介绍。上面使用查询<code>INFORMATION_SCHEMA.INNODB_TRX</code> 和<code>INFORMATION_SCHEMA.INNODB_LOCKS</code>两个表的信息来分析SQL到底加了什么锁，其实是不够太直观的，后面会介绍如何使用<code>show engine innodb status</code>语句查看SQL的加锁情况。</p>
<p>[1] <a href="">MySQL是怎样运行的</a></p>

      
    </div>
         
            <div>
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>Sam</a>
    </li>
    <li><span>发布时间: </span>2021-09-03 14:58:08</li>
    <li><span>最后更新: </span>2021-09-09 19:10:24</li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/post/412410.html" target="_blank" title="MySQL常见加锁场景分析一">https://ydstudios.gitee.io/post/412410.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网所有文章除特别声明外, 
      禁止未经授权转载，违者依法追究相关法律责任!
    </li>
  </ul>
<div>
         
    <footer class="article-footer">
      <a data-url="https://ydstudios.gitee.io/post/412410.html" data-id="cl5zaho2p002ubssz2pc7hi1d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/post/74299493.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer >> </strong>
      <div class="article-nav-title">
        
          Windows下搭建Vagrant+VirtualBox环境
        
      </div>
    </a>
  
  
    <a href="/post/18fb62ad.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older << </strong>
      <div class="article-nav-title">MySQL中到底有哪些锁</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Sam<br>
      <!--Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>-->
      <p>备案号:<a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">苏ICP备17069935号-1</a></p>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/links" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="https://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>